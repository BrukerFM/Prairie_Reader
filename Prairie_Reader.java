import java.util.Vector;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.io.File.*;
import java.lang.Math.*;
import java.lang.Object;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Date;
import java.io.*;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import ij.plugin.frame.*;
import ij.*;
import ij.io.*;
import ij.process.*;
import ij.gui.*;
import ij.plugin.PlugIn;
import ij.measure.*;
import javax.swing.event.HyperlinkEvent;
import org.w3c.dom.Document;
import org.w3c.dom.*;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import javax.swing.*;
import javax.swing.text.*;
import javax.swing.text.rtf.*;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import ij.process.LUT;
import java.awt.image.*;
import java.util.HashSet;
import java.util.Set;
import javax.imageio.*;
import javax.script.*;
import javax.swing.text.html.HTMLEditorKit;
import javax.swing.text.html.HTMLFrameHyperlinkEvent;
import javax.swing.text.html.HTMLDocument;


//***************************************
//
// import statements from ini4j
//
//***************************************

import java.io.Serializable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
//import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import java.lang.reflect.Array;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import java.lang.reflect.Array;
import java.lang.reflect.Proxy;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import java.util.ArrayList;
//import java.util.List;
import java.util.regex.Pattern;

import java.util.Map;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import java.io.Serializable;

import java.nio.charset.Charset;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Serializable;
import java.io.Writer;

import java.net.URL;

import java.util.ArrayList;
import java.util.Collections;
import java.util.concurrent.*;
import java.util.HashMap;
//import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;

import java.net.URL;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

import java.net.URL;

import java.util.ArrayList;
//import java.util.List;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;

import java.io.InputStream;

import java.net.URI;
import java.net.URL;

import java.util.Properties;
import java.util.prefs.Preferences;
import java.util.prefs.PreferencesFactory;

import java.io.IOException;

//import java.util.List;
import java.util.Map;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;

import java.net.URL;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;

import java.net.URL;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;

import java.net.URL;

import java.nio.charset.Charset;

import java.util.HashMap;
import java.util.Map;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

import java.net.URL;

import java.beans.Introspector;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyVetoException;
import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;

import java.lang.reflect.Array;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

import java.io.PrintWriter;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

import java.net.URL;

import java.util.Locale;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;

import java.io.File;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

import java.net.URI;
import java.net.URL;

import java.util.TimeZone;

import java.io.PrintWriter;
import java.io.Writer;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

import java.net.URL;

import java.util.Locale;

import java.io.IOException;
import java.io.InputStream;
import java.io.LineNumberReader;
import java.io.Reader;

import java.net.URL;

import java.io.PrintWriter;
import java.io.Writer;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

import java.net.URL;

import java.io.UnsupportedEncodingException;

import java.nio.charset.Charset;

import java.util.Arrays;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PushbackInputStream;
import java.io.Reader;

import java.nio.charset.Charset;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

import java.net.URL;

import java.util.Locale;

//***************************************
//
// end of import statements from ini4j
//
//***************************************

class ExtensionFileFilter extends FileFilter {
      String description;

      String extensions[];

      public ExtensionFileFilter(String description, String extension) {
        this(description, new String[] { extension });
      }

      public ExtensionFileFilter(String description, String extensions[]) {
        if (description == null) {
          this.description = extensions[0];
        } else {
          this.description = description;
        }
        this.extensions = (String[]) extensions.clone();
        toLower(this.extensions);
      }

      private void toLower(String array[]) {
        for (int i = 0, n = array.length; i < n; i++) {
          array[i] = array[i].toLowerCase();
        }
      }

      public String getDescription() {
        return description;
      }

      public boolean accept(File file) {
        if (file.isDirectory()) {
          return true;
        } else {
          String path = file.getAbsolutePath().toLowerCase();
          for (int i = 0, n = extensions.length; i < n; i++) {
            String extension = extensions[i];
            if ((path.endsWith(extension) && (path.charAt(path.length() - extension.length() - 1)) == '.')) {
              return true;
            }
          }
        }
        return false;
      }
}

        
/*
	Prairie View image sequence reader.  Parses XML files saved along with Prairie View image sets
	and displays metadata/images associated with the selected image sequence.
*/

public class Prairie_Reader extends PlugInFrame implements ActionListener, ItemListener, ImageListener {

	static Frame instance;
	static List sequenceSelection;
	static List frameSelection;
        static TextArea currentFile;
	static TextArea metadata;
	static Prairie_DataSet data;
	static Prairie_Sequence currentSequence;
	static Prairie_Frame currentFrame;
        String PrairieReaderVersion = "v5.5";
        
        CheckboxMenuItem optionsMenuItemImageStitchingProcessOverlapCopy;
        CheckboxMenuItem optionsMenuItemImageStitchingProcessOverlapBrightest;
        CheckboxMenuItem optionsMenuItemImageStitchingProcessOverlapAverage;
        
        static java.awt.List listImageStitichingOverlap;
        static int ImageStitchingOverlapOption = 0;
        
	public Prairie_Reader() {
		super("Prairie Reader");
		if (IJ.versionLessThan("1.49"))
			return;
		if (instance!=null) {
			instance.toFront();
			return;
		}
                instance = this;
		addKeyListener(IJ.getInstance());

                instance.setTitle("Prairie Reader " + PrairieReaderVersion);
                
		setLayout(new BorderLayout());
		
                Panel fileData = new Panel();
                fileData.setLayout(new GridLayout(1,1));
                
		MenuBar prairieMenuBar = new MenuBar();
                
                Menu prairieMenuFile = new Menu("File");
                MenuItem fileMenuItemLoadImages = new MenuItem("Load Images...");
                fileMenuItemLoadImages.addActionListener(this);
                fileMenuItemLoadImages.setActionCommand("FileLoadImages");
                prairieMenuFile.add(fileMenuItemLoadImages);
                prairieMenuBar.add(prairieMenuFile);
                
                Menu prairieMenuOptions = new Menu("Options");
                Menu optionsMenuItemImageStitching = new Menu("Image Stitching");
                Menu optionsMenuItemImageStitchingProcessOverlap = new Menu(" Process Overlap");
                optionsMenuItemImageStitchingProcessOverlapCopy = new CheckboxMenuItem("Copy Pixels", true);
                optionsMenuItemImageStitchingProcessOverlapCopy.addItemListener(this);
                optionsMenuItemImageStitchingProcessOverlap.add(optionsMenuItemImageStitchingProcessOverlapCopy);
                optionsMenuItemImageStitchingProcessOverlapBrightest = new CheckboxMenuItem("Brightest Pixel", false);
                optionsMenuItemImageStitchingProcessOverlapBrightest.addItemListener(this);
                optionsMenuItemImageStitchingProcessOverlap.add(optionsMenuItemImageStitchingProcessOverlapBrightest);
                optionsMenuItemImageStitchingProcessOverlapAverage = new CheckboxMenuItem("Average Pixel", false);
                optionsMenuItemImageStitchingProcessOverlapAverage.addItemListener(this);
                optionsMenuItemImageStitchingProcessOverlap.add(optionsMenuItemImageStitchingProcessOverlapAverage);
                optionsMenuItemImageStitching.add(optionsMenuItemImageStitchingProcessOverlap);
                prairieMenuOptions.add(optionsMenuItemImageStitching);
                prairieMenuBar.add(prairieMenuOptions);
                
//                Menu prairieMenuProcess = new Menu("Process");
//                MenuItem processMenuItemRatio = new MenuItem("MergeViaScript");
//                processMenuItemRatio.addActionListener(this);
//                processMenuItemRatio.setActionCommand("ProcessMergeViaScript");
//                prairieMenuProcess.add(processMenuItemRatio);
//                //prairieMenuBar.add(prairieMenuProcess);
//                
//                MenuItem processMenuMergeTIFF = new MenuItem("MergeViaCode");
//                processMenuMergeTIFF.addActionListener(this);
//                processMenuMergeTIFF.setActionCommand("ProcessMergeViaCode");
//                prairieMenuProcess.add(processMenuMergeTIFF);
//                prairieMenuBar.add(prairieMenuProcess);
                
                Menu prairieMenuHelp = new Menu("Help");
                MenuItem helpMenuItemRevisionHistory = new MenuItem("Revision History");
                helpMenuItemRevisionHistory.addActionListener(this);
                helpMenuItemRevisionHistory.setActionCommand("HelpRevisionHistory");
                prairieMenuHelp.add(helpMenuItemRevisionHistory);
                prairieMenuBar.add(prairieMenuHelp);
                       
                // Don't display the menu bar any longer (v3.9)
                //instance.setMenuBar(prairieMenuBar);
                
                /* Added text area at top to display currently loaded file name */
                currentFile = new TextArea("",1,50);
                currentFile.setEditable(false);
                fileData.add(currentFile);
                add(fileData, BorderLayout.PAGE_START);

		Panel selection = new Panel();	
		selection.setLayout(new GridLayout(1, 2));

                sequenceSelection = new List(15, false);
		sequenceSelection.addItemListener(this);
		selection.add(sequenceSelection);

		frameSelection = new List(15, false);
		frameSelection.addItemListener(this);
		selection.add(frameSelection);

		add(selection, BorderLayout.CENTER);

		metadata = new TextArea("",25,50);
		metadata.setEditable(false);
		//add(metadata, BorderLayout.CENTER);
                add(metadata, BorderLayout.LINE_END);
		
                Panel panelMenu = new Panel();
                panelMenu.setLayout(new GridLayout(1,1));
                add(panelMenu, BorderLayout.PAGE_END);

                //**********************************************************************
                // Start: Code inserted from "Prairie_Reader_Main_options.java"
                //**********************************************************************

                // Variables declaration - do not modify                     
                java.awt.Button buttonLoadImages;
                java.awt.Button buttonRevisionHistory;
                java.awt.Label labelImageStitchingOverlap;
                //java.awt.List listImageStitichingOverlap;
                //java.awt.Panel panelMenu;
                // End of variables declaration                   

                //panelMenu = new java.awt.Panel();
                buttonLoadImages = new java.awt.Button();
                buttonRevisionHistory = new java.awt.Button();
                labelImageStitchingOverlap = new java.awt.Label();
                listImageStitichingOverlap = new java.awt.List();

                //setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

                buttonLoadImages.setLabel("Load Images...");
                buttonLoadImages.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        buttonLoadImagesActionPerformed(evt);
                    }
                });

                buttonRevisionHistory.setLabel("Revision History...");
                buttonRevisionHistory.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        buttonRevisionHistoryActionPerformed(evt);
                    }
                });

                labelImageStitchingOverlap.setAlignment(java.awt.Label.RIGHT);
                labelImageStitchingOverlap.setText("Image Stitching Overlap");

                listImageStitichingOverlap.addItemListener(new java.awt.event.ItemListener() {
                    public void itemStateChanged(java.awt.event.ItemEvent evt) {
                        listImageStitichingOverlapItemStateChanged(evt);
                    }
                });

                javax.swing.GroupLayout panelMenuLayout = new javax.swing.GroupLayout(panelMenu);
                panelMenu.setLayout(panelMenuLayout);
                panelMenuLayout.setHorizontalGroup(
                    panelMenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(panelMenuLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(panelMenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(buttonRevisionHistory, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 127, Short.MAX_VALUE)
                            .addComponent(buttonLoadImages, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelImageStitchingOverlap, javax.swing.GroupLayout.PREFERRED_SIZE, 164, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(32, 32, 32)
                        .addComponent(listImageStitichingOverlap, javax.swing.GroupLayout.PREFERRED_SIZE, 109, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(97, Short.MAX_VALUE))
                );
                panelMenuLayout.setVerticalGroup(
                    panelMenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(panelMenuLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(panelMenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(listImageStitichingOverlap, javax.swing.GroupLayout.Alignment.TRAILING, 0, 0, Short.MAX_VALUE)
                            .addGroup(panelMenuLayout.createSequentialGroup()
                                .addComponent(buttonLoadImages, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(buttonRevisionHistory, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(panelMenuLayout.createSequentialGroup()
                                .addGap(2, 2, 2)
                                .addComponent(labelImageStitchingOverlap, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addContainerGap(22, Short.MAX_VALUE))
                );

                pack();
                
                //**********************************************************************
                // End: Code inserted from "Prairie_Reader_Main_options.java"
                //**********************************************************************
                
                
//		Button loadImages = new Button("Load Image(s)...");
//		loadImages.addActionListener(this);
//		loadImages.setActionCommand("load");
//		add(loadImages, BorderLayout.PAGE_END);
		
                listImageStitichingOverlap.add("Copy Pixels");
                listImageStitichingOverlap.add("Brightest Pixel");
                listImageStitichingOverlap.add("Average Pixel");
                listImageStitichingOverlap.select(0);
                ImageStitchingOverlapOption = 0;
                
                pack();
		GUI.center(this);
		setVisible(true);
                
                // Read the functions file if one exists.
                PrairieReaderFunctions = new Vector<FunctionSettings>();
                readFunctions();
                
                FileCheck(1000);
        }

        private void buttonLoadImagesActionPerformed(java.awt.event.ActionEvent evt) {
            // TODO add your handling code here:
            load();
        }

        private void buttonRevisionHistoryActionPerformed(java.awt.event.ActionEvent evt) {
            // TODO add your handling code here:
            RevisionHistory rh = new RevisionHistory(this, false);
            rh.setVisible(true);
            rh.toFront();
        }

        private void listImageStitichingOverlapItemStateChanged(java.awt.event.ItemEvent evt) {
            // TODO add your handling code here:
            ImageStitchingOverlapOption = listImageStitichingOverlap.getSelectedIndex();
        }

        Vector<FunctionSettings> PrairieReaderFunctions;
        
        private void readFunctions() {
           // This method is used to read the profiles for the current sequence from an xml file.
           String xmlFileName;
           //xmlFileName = IJ.getDirectory("plugins") + "Prairie_ReaderFunctions.xml";
           xmlFileName = "C:\\Documents and Settings\\All Users\\Application Data\\Prairie Technologies, Inc\\Prairie_Reader\\Prairie_ReaderFunctions.xml";
           
           File functionsFile = new File(xmlFileName);
           if (functionsFile.exists()) {
               // Functions file was found, so read it.

               try {
                    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
                    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
                    Document doc = docBuilder.parse(new File(xmlFileName));

                    if (doc.getDocumentElement().getNodeName().equals("Functions")) {
                        Node functions = doc.getElementsByTagName("Functions").item(0);
                        NodeList functionDefinitions = functions.getChildNodes();
                        for(int i = 0; i < functionDefinitions.getLength(); i++) {
                            FunctionSettings newFunction = new FunctionSettings();
                            Node mathFunction = functionDefinitions.item(i);
                            if (mathFunction.getNodeName().equals("Function")) {
                                newFunction.functionName = mathFunction.getAttributes().getNamedItem("name").getNodeValue();
                                newFunction.functionExpression = mathFunction.getAttributes().getNamedItem("function").getNodeValue();
                            }
                            PrairieReaderFunctions.add(newFunction);
                        }
                    }
               } catch (Throwable t) {
                    try {
                        FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                        PrintStream logStream = new PrintStream(logFile);
                        t.printStackTrace(logStream);
                        logStream.flush();
                        logStream.close();
                        logFile.flush();
                        logFile.close();
                        IJ.showMessage("Prairie Reader", "Error Parsing: " + xmlFileName + "\n" + "Error: " + "\n" + t.toString());
                    } catch (IOException exception) {}
               }
            }
        }
        
        private void writeFunctions() {
           // This method is used to write/save the function definitions to an xml file.
           String xmlFileName;
           
           File folderExisting = new File("C:\\Documents and Settings\\All Users\\Application Data\\Prairie Technologies, Inc\\Prairie_Reader");
           if (!folderExisting.isDirectory()) {
               folderExisting.mkdirs();
           }
           //xmlFileName = IJ.getDirectory("plugins") + "Prairie_ReaderFunctions.xml";
           xmlFileName = "C:\\Documents and Settings\\All Users\\Application Data\\Prairie Technologies, Inc\\Prairie_Reader\\Prairie_ReaderFunctions.xml";
           
           try {
                DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
                DocumentBuilder docBuilder = docFactory.newDocumentBuilder();

                // root elements
                Document doc = docBuilder.newDocument();
                Element rootElement = doc.createElement("Functions");
                doc.appendChild(rootElement);

                for (int i = 0; i < PrairieReaderFunctions.size(); i++) {
                    // staff elements
                    Element profile = doc.createElement("Function");
                    rootElement.appendChild(profile);

                    profile.setAttribute("name", String.valueOf(PrairieReaderFunctions.elementAt(i).functionName));
                    profile.setAttribute("function", String.valueOf(String.valueOf(PrairieReaderFunctions.elementAt(i).functionExpression)));
                    
                    // write the content into xml file
                    TransformerFactory transformerFactory = TransformerFactory.newInstance();
                    Transformer transformer = transformerFactory.newTransformer();
                    DOMSource source = new DOMSource(doc);
                    StreamResult result = new StreamResult(new File(xmlFileName));

                    // Output to console for testing
                    // StreamResult result = new StreamResult(System.out);

                    transformer.transform(source, result);
                }
           } catch (ParserConfigurationException pce) {
                pce.printStackTrace();
           } catch (TransformerException tfe) {
                tfe.printStackTrace();
           }
        }
        
        public void windowClosing(WindowEvent e) {
            timer.cancel();
            this.close();
        }
        
        public void actionPerformed(ActionEvent e) {
            if (e.getActionCommand().equals("FileLoadImages")) {
                load();
            }
            else if(e.getActionCommand().equals("HelpRevisionHistory")) {
                RevisionHistory rh = new RevisionHistory(this, false);
                rh.setVisible(true);
                rh.toFront();
//                RTFView revHistory = new RTFView(this, "Revision History", false);
//                revHistory.setVisible(true);
            }
            else if(e.getActionCommand().equals("ProcessMergeViaScript")) {
                ij.plugin.Macro_Runner test2 = new ij.plugin.Macro_Runner();
                test2.run("Todd-CombineLinescanImages.ijm");
            }
            else if(e.getActionCommand().equals("ProcessMergeViaCode")) {
                File file1 = new File("C:\\Test2", "LineScan-08012012-1517-1790_Cycle00001_CurrentSettings_Ch1_000001.tif");
                File file2 = new File("C:\\Test2", "LineScan-08012012-1517-1790_Cycle00001_CurrentSettings_Ch1_000002.tif");
                File file3 = new File("C:\\Test2", "LineScan-08012012-1517-1790_Cycle00001_CurrentSettings_Ch1_000003.tif");
                File file4 = new File("C:\\Test2", "LineScan-08012012-1517-1790_Cycle00001_CurrentSettings_Ch1_000004.tif");
//                try {
                   ImagePlus ip1 = new ImagePlus();
                   ImagePlus ip2 = new ImagePlus();
                   ImagePlus ip3 = new ImagePlus();
                   ImagePlus ip4 = new ImagePlus();
                   ip1 = IJ.openImage("C:\\Test2\\LineScan-08012012-1517-1790_Cycle00001_CurrentSettings_Ch1_000001.tif");
                   ip2 = IJ.openImage("C:\\Test2\\LineScan-08012012-1517-1790_Cycle00001_CurrentSettings_Ch1_000002.tif");
                   ip3 = IJ.openImage("C:\\Test2\\LineScan-08012012-1517-1790_Cycle00001_CurrentSettings_Ch1_000003.tif");
                   ip4 = IJ.openImage("C:\\Test2\\LineScan-08012012-1517-1790_Cycle00001_CurrentSettings_Ch1_000004.tif");
                   //IJ.showMessage("1: " + ip1.getWidth() + ", " + ip1.getHeight() + "  2: " + ip2.getWidth() + ", " + ip2.getHeight() + "  3: " + ip3.getWidth() + ", " + ip3.getHeight() + "  4: " + ip4.getWidth() + ", " + ip4.getHeight());
                   //ip4.getProcessor().
                   ImagePlus ipOut = IJ.createImage("compImage", "16-bit Black", ip1.getWidth(), ip1.getHeight()+ip2.getHeight()+ip3.getHeight()+ip4.getHeight(), 1);
                   //ImageProcessor ipOutProcessor = ipOut.getProcessor();
                   int sourcePixelRow[] = new int[ip1.getWidth()];
                   for (int intI = 0; intI < ip1.getHeight(); intI++) {
                       ip1.getProcessor().getRow(0, intI, sourcePixelRow, ip1.getWidth());
                       ipOut.getProcessor().putRow(0, intI, sourcePixelRow, ip1.getWidth());
                   }
                   for (int intI = 0; intI < ip2.getHeight(); intI++) {
                       ip2.getProcessor().getRow(0, intI, sourcePixelRow, ip2.getWidth());
                       ipOut.getProcessor().putRow(0, 1000 + intI, sourcePixelRow, ip2.getWidth());
                   }
                   for (int intI = 0; intI < ip3.getHeight(); intI++) {
                       ip3.getProcessor().getRow(0, intI, sourcePixelRow, ip3.getWidth());
                       ipOut.getProcessor().putRow(0, 2000 + intI, sourcePixelRow, ip3.getWidth());
                   }
                   for (int intI = 0; intI < ip4.getHeight(); intI++) {
                       ip4.getProcessor().getRow(0, intI, sourcePixelRow, ip4.getWidth());
                       ipOut.getProcessor().putRow(0, 3000 + intI, sourcePixelRow, ip4.getWidth());
                   }
                   ipOut.show();
                   IJ.save(ipOut, "C:\\Test2\\temp1.tif");
                   
//                   File outputFile = new File("C:\\Test2\\compositeImage.tif");
//                   ImageIO.write(image1, "tiff", outputFile);
//                }
//                catch (IOException pmvce) {
//                    IJ.showMessage("TIFF merge Error: " + pmvce.getMessage());
//                }
             }
            else if(e.getActionCommand().equals("ProcessRatio")) {
                // Make sure that there are at least two channels associated with
                // the current data set.
                if (currentSequence == null) {
                    IJ.showMessage("Ratio Feature Unavailable" ,"No data set is currently loaded.");
                }
                else if (currentSequence.ChannelCount() < 2){
                    IJ.showMessage("Ratio Feature Unavailable" ,"The current data set does not include two or more channels of data.");
                }
                else {
                    //IJ.showMessage("Ratio Feature available" ,"The current data set has " + currentSequence.ChannelCount() + " channels.");
                    IJ.doCommand("Ratio Plus");
                }
            }
	}

        public void itemStateChanged(ItemEvent e) {
            if (e.getItemSelectable() == sequenceSelection) {
                currentSequence = data.Sequences.elementAt(sequenceSelection.getSelectedIndex());
                LoadSequence();
            }
            else if (e.getItemSelectable() == frameSelection) {
                currentFrame = currentSequence.Frames.elementAt(frameSelection.getSelectedIndex());
                LoadFrame(false);
            }
            else if (e.getItemSelectable() == optionsMenuItemImageStitchingProcessOverlapCopy) {
                optionsMenuItemImageStitchingProcessOverlapCopy.setState(true);
                optionsMenuItemImageStitchingProcessOverlapBrightest.setState(false);
                optionsMenuItemImageStitchingProcessOverlapAverage.setState(false);
            }
	    else if (e.getItemSelectable() == optionsMenuItemImageStitchingProcessOverlapBrightest) {
                optionsMenuItemImageStitchingProcessOverlapBrightest.setState(true);
                optionsMenuItemImageStitchingProcessOverlapCopy.setState(false);
                optionsMenuItemImageStitchingProcessOverlapAverage.setState(false);
            }
            else if (e.getItemSelectable() == optionsMenuItemImageStitchingProcessOverlapAverage) {
                optionsMenuItemImageStitchingProcessOverlapAverage.setState(true);
                optionsMenuItemImageStitchingProcessOverlapCopy.setState(false);
                optionsMenuItemImageStitchingProcessOverlapBrightest.setState(false);
            }
	}
        
        public class RevisionHistory extends javax.swing.JDialog {

            /** Creates new form RevisionHistory */
            public RevisionHistory(java.awt.Frame parent, boolean modal) {
                super(parent, modal);
                initComponents();
                
                jTextPaneRevisionHistory.setCaretPosition(0);
            }

            /** This method is called from within the constructor to
             * initialize the form.
             * WARNING: Do NOT modify this code. The content of this method is
             * always regenerated by the Form Editor.
             */
            @SuppressWarnings("unchecked")
            // <editor-fold defaultstate="collapsed" desc="Generated Code">
            private void initComponents() {

                jScrollPane1 = new javax.swing.JScrollPane();
                jTextPaneRevisionHistory = new javax.swing.JTextPane();
                jLabel1 = new javax.swing.JLabel();

                setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

                jTextPaneRevisionHistory.setText("BRUKER NANO FM\n" +
                                                "PRAIRIE_READER REVISION HISTORY\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 5.5\n" +
                                                "\n" +
                                                "New methods have been added to allow macros to change the current sequence and/or frame numbers.  These are in addition to the existing method to change data sets. #3863\n" +
                                                "\n" +
                                                "call(\"Prairie_Reader.SetFile\", filename);  //filename is the path/filename of the XML metadata file\n" +
                                                "\n" +
                                                "call(\"Prairie_Reader.SetSequence\", index);  //index is the seqeuence number to show (1 indexed to match the UI)\n" +
                                                "\n" +
                                                "call(\"Prairie_Reader.SetFrame\", index);  //index is the frame number to show (1 indexed to match the UI)\n" +
                                                "\n" +
                                                "There are also methods to get the current number of sequences and the number of frames within the active sequence:\n" +
                                                "\n" +
                                                "call(\"Prairie_Reader.GetSequenceCount\");\n" +
                                                "\n" +
                                                "call(\"Prairie_Reader.GetFrameCount\");\n" +
                                                "\n" +
                                                "Displaying filenames in image window headers to make it possible to distinguish between data sets when image windows for multiple data sets are open. #3864\n" +
                                                "\n" +
                                                "Fixed an issue where a sequence would not reopen a second time after the image window for that sequence had been closed. #3865\n" +
                                                "\n" +
                                                "Version 5.4\n" +
                                                "\n" +
                                                "Fixed error when copying profiles in Line Scan Analysis. #3741\n" +
                                                "\n" +
                                                "Version 5.3\n" +
                                                "\n" +
                                                "Fixed issue reading some data sets. #3124\n" +
                                                "\n" +
                                                "Version 5.2\n" +
                                                "\n" +
                                                "Fixed issue reading line scan data acquired in Prairie View 5.3 with one or more line profiles defined. #2854\n" +
                                                "\n" +
                                                "Version 5.1\n" +
                                                "\n" +
                                                "Fixed some issues reading the smaller XML format introduced with version 5.2 of Prairie View. #2751\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 5.0\n" +
                                                "\n" +
                                                "Modified so that the .xml file format changes with version 5.2 of Prairie View will be supported and all necessary parameters properly interpreted.\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 4.4\n" +
                                                "\n" +
                                                "Corrected a problem where an \"ArrayIndexOutOfBoundsException: 0 >= 0\" error message would be displayed when loading linescan data that did not include the simultaneous collection of analog data.  This error message did not cause the software to crash or to behave improperly once the message was dismissed, but it did create an unnecessary annoyance.\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 4.3\n" +
                                                "\n" +
                                                "When image sequences collected in version 4.x and earlier \"dropped\" images, the saved value for the last good frame was not being scaled by the number of frames that were being averaged for each final image in the sequence.  This correction will make sure that the Prairie_Reader generates the proper value for the last good/valid frame number.\n" +
                                                "\n" +
                                                "Corrected a problem with the \"exporting\" of analog data from within the Linescan Analysis dialog when profiles are being \"exported\" to a file.  If the very first available analog input (AI 0) did not contain any data, then no values were written to the export file.\n" +
                                                "\n" +
                                                "Added \"Functions\" capability to the analog data within the Linescan Analysis dialog.  This feature implements the same capabilities as the \"Functions\" for profiles within the Linescan Analysis dialog. When the Create/Edit Function dialog is opened to create/edit/delete a function, the Function Help section will display information worded specifically for profiles or analog data depending upon what feature was used to open this dialog.\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 4.2\n" +
                                                "\n" +
                                                "Corrected a problem when reading in a linescan data set with an associated voltage recording.  If the voltage recording was an empty file, it would generate an error that would prevent the operator from creating profiles and other data processing on the linescans.\n" +
                                                "\n" +
                                                "Corrected a problem where if certain fields in a voltage recording experiment are not \"set\" from Prairie View, then the generation of the plot windows showing the analog data in ImageJ would result in errors that prevented the plot windows from being created.\n" +
                                                "\n" +
                                                "Added support for the proper scaling of voltage recording data that is read from Prairie View voltage recording experiments.\n" +
                                                "\n" +
                                                "Added two new function capabilities to the linescan function editor.  First, the operator can easily specify a way to generate a single value that is the \"average\" of an entire profile, {Profile Number^}, where \"Profile Number\" would be replaced by the desired profile number.  Second, the operator can easily specify a way to generate a single value that is the \"average\" of a segment of a profile, {Profile Number^Line Start-Line Stop}, where \"Profile Number\" would be replaced by the desired profile number, \"Line Start\" would be replaced by the starting line number in the profile to use for the average calculation and \"Line Stop\" would be replace by the stopping line number in the profile.  The \"Line Start\" and \"Line Stop\" lines are included in the average calculation.\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 4.1\n" +
                                                "\n" +
                                                "Corrected a problem when reading in a linescan data set with \"profiles\" created in the Prairie View Linescan Control dialog.\n" +
                                                "\n" +
                                                "Corrected a problem with the displaying of the \"profiles\" that could occasionally result in an array index error.\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 4.0\n" +
                                                "\n" +
                                                "Added the display of the channel PMT high voltage values in the metadata window.\n" +
                                                "\n" +
                                                "Made modifications to support changes to the .xml file format for Prairie View version 5.0.x.x.  This included changes to the preamplifier values and the addition of the \"smaller\" .xml file format (available under the \"Preferences -> Use Smaller XML File Format\" menu option in Prairie View).\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 3.9\n" +
                                                "\n" +
                                                "The menu bar at the top of the Prairie_Reader dialog has been removed.  This has been done since operators attempting to run the plugin on a Mac could not see the menu bar.  In its place, the various operations that had been available via the menu bar have been placed in a set of controls located at the bottom of the Prairie_Reader dialog.  While this interface is not as elegant as the menu bar, it appears to work on multiple computer platforms.\n" +
                                                "The \"File -> Load Images\" menu option has been replaced by a button labeled \"Load Images...\".\n" +
                                                "\n" +
                                                "The \"Help -> Revision History...\" menu option has been replaced by a button labeled \"Revision History\".\n" +
                                                "\n" +
                                                "The \"Options -> Image Stitching -> Process Overlap\" has been replaced by a \"list\" control labeled \"Image Stitching Overlap\".\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 3.8\n" +
                                                "\n" +
                                                "Modified the display of the revision history (Help -> Revision History) so that the contents are actually included in the plugin and are no longer a separate file.  This will allow this plugin to be used in various configurations (e.g. Fiji) and still have all of the \"content\" available.\n" +
                                                "\n" +
                                                "Prairie Linescan Analysis Dialog\n" +
                                                "Added the ability to read and display the analog data acquired in Prairie View version 5.0 when it is acquired in conjunction with a Linescan acquisition.\n" +
                                                "\n" +
                                                "Added a \"Profile Functions\" feature.  This feature is similar to the \"Functions\" capability in the Brightness Over Time (BOT) dialog within Prairie View.  The operator has the ability to create mathematical functions using the \"Profiles\".  For example, the operator could create two profiles on the linescan image and then create a \"Profile Function\" that displays the intensity difference between these two profiles.\n" +
                                                "\n" +
                                                "Profile Functions are automatically saved with the linescan data so if the data is loaded again, the Profile Functions will be reloaded automatically.\n" +
                                                "\n" +
                                                "Profile Functions are automatically saved to a general file so that any functions created are automatically available with any linescan data set.\n" +
                                                "\n" +
                                                "Profile Functions will be exported just like the Profiles.\n" +
                                                "\n" +
                                                "To create a Profile Function click on the \"Create Function...\" button.  This will bring up a modal dialog allowing the operator to create Profile Functions.  Once the dialog is open, click on \"New Template\" to create a default function.  Then, change the \"Function Name\" and be sure to hit the \"Enter\" key for the name change to be recognized.  Next, enter the desired function and once again be sure to hit the \"Enter\" key for the function definition to be recognized.  Hit the \"Accept\" key to retain the function(s) definitions or \"Cancel\" to reject changes made since the dialog was opened.  Whatever function is selected when the \"Accept\" button is pressed will then show up in the \"Profile Functions\" list in the Linescan Analysis dialog.\n" +
                                                "\n" +
                                                "If the \"Remove Function(s)\" button is pressed, only the currently selected functions will be removed from the list of Profile Functions for this particular linescan data set.\n" +
                                                "\n" +
                                                "If the \"Clear All Functions\" button is pressed, all functions will be removed from the list of Profile Functions for this particular linescan data set.\n" +
                                                "\n" +
                                                "To permanently delete a Profile Function definition from the \"global\" list press on the \"Create Function...\" button to bring up the \"Create/Edit Function dialog\".  Then select the desired function and press the \"Delete Template\" button.\n" +
                                                "\n" +
                                                "While efforts have been made to make sure that the entered function definitions are valid, it is possible that an invalid function definition can be entered.  When an invalid function is encountered when that function is selected in the Linescan Analysis dialog, the operator will be presented with an error message that should provide some indication as to what the problem is and that function will stop being evaluated.\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 3.5\n" +
                                                "\n" +
                                                "Added logic to read the \"lastGoodFrame\" or \"validData\" flags in the .xml files generated by Prairie View.  If either of these flags are present in the data and indicate an error in the data integrity, a warning message to that affect will be displayed at the start and end of the metadata list for each frame in the affected image sequence.  The \"lastGoodFrame\" value was implemented to replace the \"validData\" value, so a given .xml file will contain at most only one of these parameters.\n" +
                                                "\n" +
                                                "Prairie Linescan Analysis Dialog\n" +
                                                "Corrected a problem where the timestamp for the very first entry for a profile was being computed incorrectly.  The logic wasn't taking into account the location of the profile relative to the start of the linescan.\n" +
                                                "\n" +
                                                "Started adding support for Prairie View version 5.0\n" +
                                                "If \"profiles\" are generated in the Linescan Control dialog in Prairie View, they are imported into the Prairie_Reader.  The location and width of the profile are maintained.  These profiles are listed in the Profile List with \"(Prairie View)\" as part of the profile name.  Once these profiles are in the Prairie_Reader, the user can edit them just like any other profile.  These profile edits will be saved (although not in the Prairie View generated .xml file) and recalled automatically when this data is loaded again.  These Prairie View generated profiles cannot be deleted from the list of profiles for a given sequence.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 3.4\n" +
                                                "\n" +
                                                "Added a new feature to automatically generate 'mosaic' (stitched) images.\n" +
                                                "When the .xml file is selected via the 'Files -> Load Images...' menu option, if certain criteria are met, then the software will automatically stitch together the appropriate images to create the mosaic view(s).  This will work with 2D or 3D T-series data.\n" +
                                                "\n" +
                                                "The criteria consist of several tests on the actual data.  First, the 'Grid Definition' feature on the 'XY-Stage' tab in Prairie View must have been used for generating the table of stage locations used for the image collection within the T-series.\n" +
                                                "\n" +
                                                "Second, there must be more than one image in the X or Y dimension of the Grid definition.\n" +
                                                "\n" +
                                                "Third, the total number of images in the entire T-series must be equal to the product of the number of images in the X dimension multiplied by the number of images in the Y dimension multiplied by the number of images in the Z dimension multiplied by the number of channels multiplied by the number of T-series 'Iterations'.  If there are extra images or if the T-series was aborted before it finished normally, the program will not generate the mosaic image(s).\n" +
                                                "\n" +
                                                "And fourth, there must be the same number of images in the Z dimension for each X,Y stage location.\n" +
                                                "\n" +
                                                "To support this new feature, there is a new menu option called 'Options'.  Under the 'Options' menu item there is an 'Image Stitching' option, and under this is the 'Process Overlap' option.  The three options under 'Process Overlap' determine how the software treats the pixels in the areas of 'overlap' between images in the mosaic.  The first option is 'Copy Pixels'.  With this option, in the area where two or more images overlap, the pixel value will simply be that of the corresponding pixel from the last image to be used.  The second option is 'Brightest Pixel'.  With this option, in the area where two or more images overlap, the pixel value will be the pixel value from the image with the maximum intensity at that specific location.  The third option is 'Average Pixel'.  With this option, in the area where two or more images overlap, the pixel value will be the average value of all of the corresponding pixel values from the various images.\n" +
                                                "\n" +
                                                "When the .xml file is loaded, the mosaic images will be automatically generated using the selected 'Process Overlap' option.  As the images from the T-series are being processed, there will be a status message displayed in the main ImageJ dialog informing the operator of the number of images processed and what percentage have been processed.\n" +
                                                "\n" +
                                                "The mosaic images will be automatically saved in the directory with the original T-series data.  These new files will use the same base T-series name as the original data but include 'Mosaic' as part of the name.  This allows the operator to use these images in other programs.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 3.3\n" +
                                                "\n" +
                                                "Corrected a problem with the display of 'PointScan' data.  The time scale (x axis) was 1/1000 of what it should've been.  For example, if the actual PointScan acquisition time was 100ms, the displayed time scale said 0.1ms.\n" +
                                                "\n" +
                                                "Corrected a problem where the reference image for a multiple channel linescan acquisition was not being displayed properly.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 3.2\n" +
                                                "\n" +
                                                "Corrected a problem with the ImageJ image windows where if less than seven images made up an image sequence (e.g. three slice Z-series), then the image window was displayed using the 'Channel' control to scroll through the images instead of the 'Slice' control.\n" +
                                                "\n" +
                                                "\n" +
                                                "Corrected a problem where displaying multiple channel Z-series data sets could result in the image display 'bouncing' back and forth between the first image in the Z-series and the desired image.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 3.1\n" +
                                                "\n" +
                                                "Prairie Linescan Analysis Dialog\n" +
                                                "Added the button 'Delete All Profile(s)'.  When this button is pressed the operator will be prompted to confirm that all profiles should be deleted.  If the operator selects 'OK', then all profiles will be deleted for the current data set.\n" +
                                                "\n" +
                                                "Modified the 'Delete Selected Profile(s)' action so that the operator will be prompted to confirm that the selected profile(s) should be deleted.\n" +
                                                "\n" +
                                                "The display of the profile in the linescan image window has been modified.  Now the profile display will be drawn such that the outline itself does not include any of the profile area.  For example, previously, if the profile width is 1, then the profile display was just a single line one pixel wide corresponding to the position of the profile.  Now, if the profile width is 1, the profile display will be a box three pixels wide.  One pixel on the top and bottom for the profile outline with one pixel in the middle to visualize the actual linescan data.\n" +
                                                "\n" +
                                                "Added a 'Threshold' option for intensity profiles.  When the 'Threshold Profile' checkbox is checked and the profile width is greater than 1, then the threshold minimum and threshold maximum act as a mask for determining which pixels within the profile are used in the calculation of the profile intensity values.  The operator may only edit the threshold minimum and maximum values when a single profile is selected in the profile list.  When the 'Edit' button is pressed, the sliders that allow the operator to adjust the threshold minimum and maximum are made active and all of the other profile controls are made inactive.  As the operator adjusts the minimum and/or maximum, the profile display on the linescan image(s) and the profile graph will be automatically updated.  Pixels that have an intensity that is less than the minimum or greater than the maximum will not be included in the intensity calculations for the profile graph and those pixels will be overlaid in the profile color on the linescan images.  By excluding those pixels from the intensity calculations, the data will not be influenced by those pixels.  Where this could be useful is if during the linescan acquisition the sample were to slightly move so that there is a shift in the linescan image, the profile can be made wide enough to compensate for the shift, but by adjusting the threshold settings, most of the extra background pixels can be eliminated from the intensity calculations.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 3.0\n" +
                                                "\n" +
                                                "Prairie Linescan Analysis Dialog\n" +
                                                "Corrected a problem where when the last profile(s) for a given sequence were deleted, the file that kept the profile information was not being deleted.  This resulted in the deleted profile(s) not being permanently removed, but rather, would re-appear when that particular data set was loaded again.\n" +
                                                "\n" +
                                                "Corrected a problem where the word 'Position' was not being fully displayed as part of the 'Profile Position' control on the 'Intensity Profiles' tab.\n" +
                                                "\n" +
                                                "When a new profile or profiles are 'created' they will be automatically 'selected' in the profile list.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 2.9\n" +
                                                "\n" +
                                                "Prairie Linescan Analysis Dialog\n" +
                                                "Corrected a problem where for single channel linescan data sets, the vertical scale on the profile plots was not being properly set.  This resulted in profile intensity plots that were not being properly displayed.\n" +
                                                "\n" +
                                                "Added a new combo box control to the 'Intensity Profiles' tab.  This combo box is labeled 'If Profile Width >1 ...'.  The combo box provides two options; Average and Total.  If 'Average' is selected, then if a profile width is greater than 1 then the computed intensity profile will be based on the average of the pixel samples from the specified profile width.  If 'Total' is selected, then if a profile width is greater than 1 then the computed intensity profile will be based on the total of the pixel samples from the specified profile width.\n" +
                                                "\n" +
                                                "Profile locations are now drawn on the reference images on top of the general linescan trace. These profile locations match the color and width of the profile definition.  This allows for direct referencing of the profile to the reference image.\n" +
                                                "\n" +
                                                "Added a new checkbox control to the 'Analog Data' tab called 'Apply TriggerSync Scaling?'.  By default, this option is 'checked'.  When checked, the same scaling factor that is applied within TriggerSync to the analog input data will be applied.  The scaling factor in TriggerSync is set via the 'ADC Configuration' dialog that is brought up via the menu option 'Configuration -> ADC Configuration...'.  There is a separate 'Manual Sensitivity' value (i.e. scaling factor) for each channel.  The scaling factor is applied to the raw data using the following formula; (( 1 / scaling factor) * 1000).  If this option is unchecked, the scaling factor is not applied.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 2.8\n" +
                                                "\n" +
                                                "Prairie Linescan Analysis Dialog\n" +
                                                "Support has been added for analog data acquired with TriggerSync and saved in the 'Igor' Format.\n" +
                                                "\n" +
                                                "Corrected a problem where the plot window for a profile was not being removed when the profile was deleted.\n" +
                                                "\n" +
                                                "Corrected a problem where is a profile was deleted, the name of the profile in the plot windows for the remaining profiles were not being properly updated.\n" +
                                                "\n" +
                                                "Corrected a problem where if all of the profiles were deleted, the profile traces in the linescan windows were not removed.\n" +
                                                "\n" +
                                                "Added a checkbox to the 'Intensity Profiles' tab labeled 'Close Linescan Windows with dialog'.  When this option is 'checked', then when the Linescan Analysis Dialog is closed, all windows associated with this particular linescan sequence will be closed.  This includes all profile displays, analog data displays, the linescan image(s), and the linescan reference image(s).  When this item is 'unchecked', then when the Linescan Analysis Dialog is closed, only the profile displays and analog data displays will be closed.  The linescan image(s) and linescan reference image(s) will remain visible.\n" +
                                                "\n" +
                                                "Added the ability to 'Copy' and 'Paste' profiles.  To use this feature, simply select the profile(s) for a sequence that you wish to copy and press the 'Copy Selected Profile(s)' button in that particular Linescan Analysis Dialog.  Then, in the sequence that you wish to paste these profile definitions into, simply press the 'Paste Profile(s)' button in that sequence's Linescan Analysis Dialog.  If you wish to paste the profile(s) into another linescan acquisition (not one of the sequences in the current linescan acquisition) simply load the linescan acquisition using the 'Prairie Reader' 'File -> Load Images...' menu option and when the Linescan Analysis Dialog for the data is displayed, press the 'Paste Profile(s)' button.  When the 'Paste Profile(s)' button is pressed, the profiles will be analyzed to see if they are valid for the linescan data they are intended for.  First, a check will be made to see if the 'channel' associated with the copied profile exists and second, a check will be made to see if the 'position' of the copied profile falls within the limits of the intended linescan data.  If either of these criteria is not met, the profile will not be used with the intended linescan data.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 2.7\n" +
                                                "\n" +
                                                "Corrected a problem with the display of the 'Field of View (FOV)' parameter where it was being incorrectly calculated for images acquired with Prairie View version 4.3.2.12 and later.\n" +
                                                "\n" +
                                                "Modified the parameter display so that the 'Field of View (FOV)' parameter is not displayed when 'Linescan' data is loaded.\n" +
                                                "\n" +
                                                "If analog data (acquired) via TriggerSync is associated with a linescan data set, the 'Prairie Linescan Analysis' dialog will automatically load the data and display it.\n" +
                                                "Currently, the program will read the binary (native TriggerSync) format, and the spreadsheet format (tab, comma, or semi-colon separated) files generated via TriggerSync.\n" +
                                                "\n" +
                                                "Each analog data channel will be displayed in an independent plot window.  If analog channel labels and units have been specified in TriggerSync, those values will be imported here and displayed for each channel.  Also, the defined color used in TriggerSync for each analog data channel is retained here.\n" +
                                                "\n" +
                                                "Using the 'Analog Data' tab, the operator may choose to display or not display the plot window for a particular analog data channel by clicking on the button at the top of each analog channel control group.\n" +
                                                "\n" +
                                                "If either the 'Export Selected Profile(s)...' or 'Export All Profile(s)...' button is pressed, if there is analog data associated with the linescan data, the operator will be prompted to save the analog data as well.  If the operator chooses to save the analog data, it will be saved in a separate file from the profile data.  The name of the file for the profile data will be '<operator entered name>-Profiles.csv' and the name of the file for the analog data will be '<operator entered name>-AnalogData.csv'.\n" +
                                                "\n" +
                                                "Added a 'checkbox' control to the 'Intensity Profiles' tab labeled 'Profiles in Separate Windows'.  When this item is checked, then each profile will be displayed in a separate window.  When this item is not checked, all of the profiles from the same acquisition channel will be displayed in one window.  In addition, another window will show all of the selected profiles regardless of which acquisition channel they are associated with.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 2.6\n" +
                                                "\n" +
                                                "When 'Linescan' data is loaded, a new dialog 'Prairie Linescan Analysis' will be automatically displayed.  This dialog provides some of the capabilities of the 'LinescanViewer' program within ImageJ.  An early enhancement over the LinescanViewer program is that this will display multiple channel data.\n" +
                                                "When linescan data is loaded, the images will be automatically rotated 90 degrees to the left.  In this manner 'time' increases going left to right, just as in the graphs.\n" +
                                                "\n" +
                                                "If multiple channels were acquired, then there will be a separate window for each channel as well as a window showing the 'composite' linescan images from all channels.\n" +
                                                "\n" +
                                                "In addition to the linescan images being displayed, there will be a 'Reference Image' (part of the window title) displayed for each channel with the linescan pattern displayed on these images.  If multiple channels were acquired, then there will be a separate 'Reference Image' window showing the 'composite' reference image from all channels.\n" +
                                                "\n" +
                                                "The 'Intensity Profiles' tab provides the operator with the chance to create 'profiles' on the linescan data  The operator needs to select the channel or channels to create a profile for and then press the 'Create' button to generate the desired profile(s).  The newly created profile(s) will have the values defined by the 'Profile Width' and 'Profile Color' controls.  An outline of the profile will be shown on the linescan image(s).  This outline will be drawn in the specified profile color and width.  The current profiles will be displayed in the 'Select a Profile' list.  When one or more profiles are selected within this control, one or more graph windows will appear displaying the intensity versus time data for the selected profiles.  There will be a separate graph window for data from the profiles for each individual channel as well as a composite graph window showing the data from all selected profiles regardless of the channel.  The graph windows will only be shown when one or more profile is selected, otherwise, the display of the graph windows dynamically changes as profiles are selected and/or deselected.\n" +
                                                "\n" +
                                                "To change the size of the graph, use the ImageJ menu option, 'Edit -> Options -> Profile Plot Options...'.  Set the desired values in this dialog before loading the linescan data files.\n" +
                                                "\n" +
                                                "When only one profile is selected, the operator may use the 'Profile Width' and 'Profile Color' controls to edit those particular values for the selected profile.  The 'Profile Position' control will work when one or more profiles are selected.\n" +
                                                "\n" +
                                                "Profiles are automatically saved as they are created and/or edited.  In this manner, if this linescan data is loaded again, the profile information will be automatically loaded as well.\n" +
                                                "\n" +
                                                "If the particular linescan data set includes multiple independent linescans, then each individual linescan will appear as a separate 'Sequence' in the main Prairie Reader window.  Since these independent linescans could be acquired with different linescan patterns (freehand and etc.) as well as different reference images, each 'sequence' will have its own 'Linescan Analysis' window, linescan windows, reference image windows, and graph windows.\n" +
                                                "\n" +
                                                "If the 'Delete Selected Profile(s)' button is pressed, then the currently selected profiles will be deleted.\n" +
                                                "\n" +
                                                "If the 'Export Selected Profile(s)...' button is pressed, then the currently selected profiles will be saved as a csv (comma separated values) file.  Each profile will consist of two columns, one for time and one for intensity.\n" +
                                                "\n" +
                                                "If the 'Export All Profile(s)...' button is pressed, then all of the profiles will be saved as a csv (comma separated values) file.  Each profile will consist of two columns, one for time and one for intensity.\n" +
                                                "\n" +
                                                "Currently the features on the 'Analog Data' tab are disabled.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 2.5\n" +
                                                "\n" +
                                                "When 'Linescan' data is loaded, the linescan images will be displayed and for each linescan that makes up the data set, the source image will be displayed along with an overlay showing the linescan pattern.\n" +
                                                "If a linescan data set had been saved as more than one .tif image (due to a large number of linescan lines or some other reason), the multiple separate images will be merged and displayed as a single image.  This 'composite' image will also be automatically saved in the directory with the original linescan data.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 2.4\n" +
                                                "\n" +
                                                "Modified the calculation for the 'microns per pixel' values (for non-camera based images) based upon the version of Prairie View that the data was acquired with.  Prior to version 4.3.2.12, to properly compute the 'microns per pixel' values (for non-camera based images) the 'microns per pixel' values saved in the .xml files had to be divided by the 'optical zoom' to get the correct value.  Starting with version 4.3.2.12 this is no longer necessary.\n" +
                                                "\n" +
                                                "\n" +
                                                "\n" +
                                                "Version 2.3\n" +
                                                "\n" +
                                                "Added the menu bar to the Prairie Reader dialog.\n" +
                                                "\n" +
                                                "Corrected a problem where reading .xml files with more than four preamplifier channel settings would cause a read error.\n" +
                                                "\n" +
                                                "Modified how linescan data is interpreted.\n" +
                                                "When linescan data is read, the image calibration will be set such that the y axis spacing (microns/pixel) will actually be the 'scan line period' from the linescan data.  In this manner, if the image is rotated 90 degrees left and then if a 'Profile' is generated from the rotated image, the x axis scale in the 'Profile' graph while displaying the string 'microns', will actually be 'milliseconds'.\n" +
                                                "\n" +
                                                "Modified the title bar when multiple channel data is being displayed.  The individual channel windows title will still start with 'I1', 'I2', and etc.  Following this will be the label of the channel from Prairie View.  Following this will be additional text defining the data being displayed.\n" +
                                                "\n" +
                                                "Removed the 'Load Images...' button at the bottom of the dialog and placed that functionality under the 'File -> Load Images...' menu option.\n" +
                                                "\n" +
                                                "Added logic to read the laser names and use the names when displaying laser power values in the metadata display area.\n" +
                                                "\n" +
                                                "Added the ability to read Point Scan acquisition files.\n" +
                                                "The Point Scan graph data is automatically displayed.\n" +
                                                "To change the size of the graph, use the ImageJ menu option, 'Edit -> Options -> Profile Plot Options...'.  Set the desired values in this dialog before loading the Point Scan data files.\n" +
                                                "");
                
                jScrollPane1.setViewportView(jTextPaneRevisionHistory);

                jLabel1.setText("Revision History");

                javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
                getContentPane().setLayout(layout);
                layout.setHorizontalGroup(
                    layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 744, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap(315, Short.MAX_VALUE)
                        .addComponent(jLabel1)
                        .addGap(352, 352, 352))
                );
                layout.setVerticalGroup(
                    layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE))
                );

                pack();
            }// </editor-fold>

            // Variables declaration - do not modify
            private javax.swing.JLabel jLabel1;
            private javax.swing.JScrollPane jScrollPane1;
            private javax.swing.JTextPane jTextPaneRevisionHistory;
            // End of variables declaration
        }
        
        public class FunctionSettings {
            String functionName = "";
            String functionExpression = "";
            Color color = Color.RED;
        }
        
        public class FunctionEditor extends javax.swing.JDialog {

            Frame feDialogParentFrame;
            Vector<FunctionSettings> origFunctions = new Vector<FunctionSettings>();
            boolean validFunction = true;
            int functionIndex = -1;
            
            /** Creates new form FunctionEditor */
            public FunctionEditor(java.awt.Frame parent, boolean modal, int mode) {
                
                // mode = 0 then handle this as functions for intensity (linescan and etc.) data.
                // mode = 1 then handle this as functions for analog data.
                
                super(parent, modal);
                feDialogParentFrame = parent;
                initComponents();
                
//                // Display the function help information
//                HTMLEditorKit kit = new HTMLEditorKit();
//                jEditorPaneFunctionEditorHelp.setEditorKit(kit);
//                jEditorPaneFunctionEditorHelp.addHyperlinkListener(new javax.swing.event.HyperlinkListener() { 
//                    public void hyperlinkUpdate(javax.swing.event.HyperlinkEvent evt) { 
//                        jEditorPaneFunctionEditorHelpHyperlinkUpdate(evt); 
//                    } 
//                }); 
//                
//                try {
//                    jEditorPaneFunctionEditorHelp.setPage(new URL("file:///C:/Program Files/ImageJ/plugins/Input-Output/functionHelp.html"));
//                    //jEditorPaneFunctionEditorHelp.setPage(new URL("http://www.yahoo.com"));
//                } catch (java.io.IOException ioexc) {
//                    try {
//                        FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
//                        PrintStream logStream = new PrintStream(logFile);
//                        ioexc.printStackTrace(logStream);
//                        logStream.flush();
//                        logStream.close();
//                        logFile.flush();
//                        logFile.close();
//                    } catch (IOException exception) {}
//                }
                
                // Set the help text based upon the "mode" selection.
                if (mode == 0) 
                    jTextPaneFunctionEditorHelp.setText("Quick Reference (Basic Overview)\nNote: Bold text is entered as is; grey italicized text needs to be replaced with actual values before entered.\n\nIntensity Values\n{Profile Number} - Current intensity of specified profile number (1-n).\n{Profile Number:Line Offset} - Intensity of specified profile number at a relative line offset.\n{Profile Number,Line Number} -ï¿½Intensity of specified profile number at an absolute line offset.\n{Profile Number^} ï¿½ Average intensity of specified profile number.\n{Profile Number^Line Start-Line Stop} ï¿½ Average intensity of specified profile number for a specified range of lines.\n\nTimestamps\n{t Profile Number } - Current timestamp in milliseconds for the specified profile number.\n{t Profile Number:Line Offset} - Timestamp of specified profile number at a relative line offset in milliseconds.\n{t Profile Number,Line Number} - Timestamp of specified profile number at an absolute line offset in milliseconds.\n\nFrame Number\n{f} - Current line number.\n\nOperators & Functions\nYou can use any common operators such asï¿½+,ï¿½-,ï¿½/ orï¿½* as well as any valid JavaScript math syntax such as Math.max(Expression #1,Expression #2), Math.abs(Expression) and Math.log(Expression). ï¿½Note that expressions are case sensitive.\n\nIntensity Values (Top)\nThere are three different ways to include intensity values in your functions: by profile number, by profile number and a relative line offset and by profile number with an absolute line number.\n\nTo include the current intensity value in your function simply enclose the profile number you are interested in within curly braces,ï¿½{Profile Number}. ï¿½For example, to subtract the intensity values for profile one from those of profile two the function would be the following, '{2} - {1}'. ï¿½These intensities will vary as the function is recalculated for each line.\n\nTo include intensity values from past and/or future lines enclose the profile number followed by the line offset separated by a colon in curly braces, {Profile Number:Line Offset}. ï¿½For example, to calculate the change in intensity forï¿½profile one over each line the function would be the following, '{1} - {1:-1}'. ï¿½This takes the intensity for profile one for the current line and subtracts from it the intensity value for the previous line.\n\nIf an offset should reference a nonexistent line either before the first line or after the last line then the values for the first and last lines are used insteadï¿½respectively.\n\nTo include intensity values for a specific lineï¿½enclose the profile number followed by the line number separated by a comma in curly braces, {Profile Number,Line Number}. ï¿½For example, to calculate F over F0 for profile one where F is the current intensity value and F0 is the average of the first 5 lines, the function would be the following, '{1}/(({1,1} + {1,2} + {1,3} + {1,4} + {1,5}) / 5)' or ï¿½{1}/{1^1-5}ï¿½. ï¿½This takes the current intensity of profile one and divides it by the average intensity of the first 5 lines.\n\nTo include an intensity value that is the average value for an entire profile, enclose the profile number followed by a caret in curly braces, {Profile Number^}.  For example, to calculate the average value for the second profile, the syntax would be the following, ï¿½{2^}ï¿½.\n\nTo include an intensity value that is the average value for a section of a profile, enclose the profile number followed by a caret, followed by the line number indicating the starting line number, followed by a hyphen, and followed by the line number indicating the stopping line number in curly braces, {Profile Number^Line Start-Line Stop}.  For example, to calculate the average value for the first ten lines of profile one, the syntax would be the following, ï¿½[1^1-10}ï¿½.\n\nTimestamps (Top)\nThere are three different ways to include timestamp values in your functions: for the current line, for a relative line offset and for an absolute line number. ï¿½All timestamps are all in milliseconds.\n\nTo include theï¿½timestamp value for the current line in your function simplyï¿½enclose a lowercase T followed by the profile number within curly braces, {t Profile Number }. ï¿½For example, to display theï¿½timestamp value for each line for profile 1, the function would be the following, '{t1}'. ï¿½Theï¿½timestamp will vary as the function is recalculated for each line.\n\nTo include timestamp values from past and/or future lines enclose a lowercase T followed by the profile number, followed by the line offset separated by a colon in curly braces {t Profile Number:Line Offset}. ï¿½For example, to display the line period for profile 2, the function would be the following, '{t2} - {t2:-1}'. ï¿½This takes the timestamp value for the current line and subtracts from it theï¿½timestamp value for the previous line which will generate a horizontal line.\n\nIf an offset should reference a nonexistent line either before the first line or after the last line then the values for the first and last lines are used insteadï¿½respectively.\n \nFinally to includeï¿½timestamp values for a specific lineï¿½enclose a lowercase T followed by the profile number, followed by the line number separated by a comma in curly braces, {t Profile Number,Line Number}. ï¿½For example, to display the current line's timestamp relative to the 2nd line's timestamp for profile 3, the function would be the following, '{t3} - {t3,2}'. ï¿½This takes the timestamp of the current line and subtracts is from the timestamp of the 2nd line.\n\nFrame Numberï¿½(Top)\nTo include the current line number in your function simply enclose a lowercase f within curly braces, {f}. ï¿½For example to display the current line number the function would be the following, '{f}'. ï¿½This will result in a diagonal line increasing by one each line. ï¿½Not all too exciting on its own, but used in combination with other variables can prove invaluable.\n\nOperators & Functions (Top)\nAny of the four standard arithmetic operators can be used on the variables mentioned in this document: ï¿½addition (+), subtraction (-), division (/) and multiplication (*). ï¿½Theï¿½modulus operatorï¿½(%) can also be used.\n\nIn addition to variables and operators any numeric constants can be used as desired.\n\nIf basic operators, variables and constants are insufficient the entire JavaScript math library is available as well. ï¿½Keep in mind that JavaScript is case sensitive which is also true for any expressions entered for functions. ï¿½A few commonly used math functions are:\n\nMath.abs(Expression) - Calculates the absolute value ofï¿½given expression.\nMath.min(Expression #1,Expression #2) - Calculates the minimum value of two expressions.\nMath.max(Expression #1,Expression #2) - Calculates the maximum value of two expressions.\nMath.log(Expression) - Calculates the natural logï¿½ofï¿½given expression.\nMath.sqrt(Expression) - Calculates the square root of given expression.\nMath.pow(Expression #1,Expression #2) - Calculates the value of the first expression raised to the power determined byï¿½the value of the second expression.\nMath.cos(Expression) - Calculates the cosine ofï¿½given expression in radians.\nMath.sin(Expression) - Calculates theï¿½sine ofï¿½given expression in radians.\nMath.tan(Expression) - Calculates the tangent ofï¿½given expression in radians.\n\nBasic Overviewï¿½(Top)\nFunctions can be used to display raw brightness over time data in different ways. ï¿½Functions consist of a few variables used to access intensity data consisting of profile and line numbers enclosed in curly braces { } in combination with some basic arithmetic operators and optionally some JavaScript syntax for advanced users.\n\nFunctions are added by clicking the Create Function button which will give focus to a text box highlighting the text 'Enter expression' at which point a function can be typed in (syntax is explained in the rest of this document), the highlighted text will be replaced by the first character typed. ï¿½When the expression is complete press Enter, at which point the expression will be evaluated for correctness and saved. ï¿½To cancel simply clear out the expression field and press Enter. ï¿½If the expression if found to be incorrect a message box will pop up at which point the expression can be fixed and accepted again\n\nThere is a combo box above the text box used to select expression templates used to quickly add frequently used expressions. ï¿½The templates contained within the combo box are loaded from an XML file ï¿½C:\\Documents and Settings\\All Users\\Application Data\\Prairie Technologies, Inc\\Prairie_Reader\\Prairie_ReaderFunctions.xmlï¿½. \n");
                else if (mode == 1)
                    jTextPaneFunctionEditorHelp.setText("Quick Reference (Basic Overview)\nNote: Bold text is entered as is; grey italicized text needs to be replaced with actual values before entered.\n\nAnalog Data Values\n{Analog Input Number} - Current value of specified analog input number (1-n).\n{ Analog Input Number:Sample Offset} - Value of specified analog input number at a relative sample offset.\n{ Analog Input Number,Sample Number} -ï¿½Value of specified analog input number at an absolute sample offset.\n{ Analog Input^} ï¿½ Average value of specified analog input number.\n{ Analog Input Number^Sample Start-Sample Stop} ï¿½ Average value of specified analog input number for a specified range of samples.\n\nTimestamps\n{t Analog Input Number } - Current timestamp in milliseconds for the specified analog input number.\n{t Analog Input Number:Sample Offset} - Timestamp of specified analog input number at a relative sample offset in milliseconds.\n{t Analog Input Number,Sample Number} - Timestamp of specified analog input number at an absolute sample offset in milliseconds.\n\nFrame Number\n{f} - Current analog input number.\n\nOperators & Functions\nYou can use any common operators such asï¿½+,ï¿½-,ï¿½/ orï¿½* as well as any valid JavaScript math syntax such as Math.max(Expression #1,Expression #2), Math.abs(Expression) and Math.log(Expression). ï¿½Note that expressions are case sensitive.\n\nAnalog Data Values (Top)\nThere are three different ways to include analog data values in your functions: by analog input number, by analog input number and a relative sample offset and by analog input number with an absolute sample number.\n\nTo include the current analog input value in your function simply enclose the analog input number you are interested in within curly braces,ï¿½{ Analog Input Number}. ï¿½For example, to subtract the values for analog input number one from those of analog input number, two the function would be the following, '{2} - {1}'. ï¿½These values will vary as the function is recalculated for each sample.\n\nTo include analog data values from past and/or future samples enclose the analog input number followed by the sample offset separated by a colon in curly braces, { Analog Input Number:Sample Offset}. ï¿½For example, to calculate the change in analog value forï¿½analog input one over each sample, the function would be the following, '{1} - {1:-1}'. ï¿½This takes the analog value for analog input one for the current sample and subtracts from it the analog value for the previous sample.\n\nIf an offset should reference a nonexistent sample either before the first sample or after the last sample then the values for the first and last samples are used insteadï¿½respectively.\n\nTo include analog data values for a specific sampleï¿½enclose the analog input number followed by the sample number separated by a comma in curly braces, { Analog Input Number,Sample Number}. ï¿½For example, to calculate F over F0 for profile one where F is the current analog data value and F0 is the average of the first 5 samples, the function would be the following, '{1}/(({1,1} + {1,2} + {1,3} + {1,4} + {1,5}) / 5)' or ï¿½{1}/{1^1-5}ï¿½. ï¿½This takes the current analog value of profile one and divides it by the average analog values of the first 5 samples.\n\nTo include an analog data value that is the average value for an entire analog input, enclose the analog input number followed by a caret in curly braces, { Analog Input Number^}.  For example, to calculate the average value for the second analog input, the syntax would be the following, ï¿½{2^}ï¿½.\n\nTo include an analog data value that is the average value for a section of an analog input, enclose the analog input number followed by a caret, followed by the sample number indicating the starting sample number, followed by a hyphen, and followed by the sample number indicating the stopping sample number in curly braces, { Analog Input Number^Sample Start-Sample Stop}.  For example, to calculate the average value for the first ten samples of analog input one, the syntax would be the following, ï¿½[1^1-10}ï¿½.\n\nTimestamps (Top)\nThere are three different ways to include timestamp values in your functions: for the current sample, for a relative sample offset and for an absolute sample number. ï¿½All timestamps are in milliseconds.\n\nTo include theï¿½timestamp value for the current sample in your function simplyï¿½enclose a lowercase T followed by the profile number within curly braces, {t Analog Input Number }. ï¿½For example, to display theï¿½timestamp value for each sample for analog input 1, the function would be the following, '{t1}'. ï¿½Theï¿½timestamp will vary as the function is recalculated for each sample.\n\nTo include timestamp values from past and/or future samples enclose a lowercase T followed by the analog input number, followed by the sample offset separated by a colon in curly braces {t Analog Input Number:Sample Offset}. ï¿½For example, to display the sample period for analog input 2, the function would be the following, '{t2} - {t2:-1}'. ï¿½This takes the timestamp value for the current samples and subtracts from it theï¿½timestamp value for the previous sample which will generate a horizontal line.\n\nIf an offset should reference a nonexistent sample either before the first sample or after the last sample then the values for the first and last samples are used insteadï¿½respectively.\n \nFinally to includeï¿½timestamp values for a specific sampleï¿½enclose a lowercase T followed by the analog input number, followed by the sample number separated by a comma in curly braces, {t Analog Input Number,Sample Number}. ï¿½For example, to display the current sampleï¿½s timestamp relative to the 2nd sampleï¿½s timestamp for analog input 3, the function would be the following, '{t3} - {t3,2}'. ï¿½This takes the timestamp of the current sample and subtracts is from the timestamp of the 2nd sample.\n\nFrame Numberï¿½(Top)\nTo include the current sample number in your function simply enclose a lowercase f within curly braces, {f}. ï¿½For example to display the current sample number the function would be the following, '{f}'. ï¿½This will result in a diagonal line increasing by the sample period for each line. ï¿½Not all too exciting on its own, but used in combination with other variables can prove invaluable.\n\nOperators & Functions (Top)\nAny of the four standard arithmetic operators can be used on the variables mentioned in this document: ï¿½addition (+), subtraction (-), division (/) and multiplication (*). ï¿½Theï¿½modulus operatorï¿½(%) can also be used.\n\nIn addition to variables and operators any numeric constants can be used as desired.\n\nIf basic operators, variables and constants are insufficient the entire JavaScript math library is available as well. ï¿½Keep in mind that JavaScript is case sensitive which is also true for any expressions entered for functions. ï¿½A few commonly used math functions are:\n\nMath.abs(Expression) - Calculates the absolute value ofï¿½given expression.\nMath.min(Expression #1,Expression #2) - Calculates the minimum value of two expressions.\nMath.max(Expression #1,Expression #2) - Calculates the maximum value of two expressions.\nMath.log(Expression) - Calculates the natural logï¿½ofï¿½given expression.\nMath.sqrt(Expression) - Calculates the square root of given expression.\nMath.pow(Expression #1,Expression #2) - Calculates the value of the first expression raised to the power determined byï¿½the value of the second expression.\nMath.cos(Expression) - Calculates the cosine ofï¿½given expression in radians.\nMath.sin(Expression) - Calculates theï¿½sine ofï¿½given expression in radians.\nMath.tan(Expression) - Calculates the tangent ofï¿½given expression in radians.\n\nBasic Overviewï¿½(Top)\nFunctions can be used to display raw analog data in different ways. ï¿½Functions consist of a few variables used to access analog data consisting of analog input number and sample numbers enclosed in curly braces { } in combination with some basic arithmetic operators and optionally some JavaScript syntax for advanced users.\n\nFunctions are added by clicking the Create Function button which will give focus to a text box highlighting the text 'Enter expression' at which point a function can be typed in (syntax is explained in the rest of this document), the highlighted text will be replaced by the first character typed. ï¿½When the expression is complete press Enter, at which point the expression will be evaluated for correctness and saved. ï¿½To cancel simply clear out the expression field and press Enter. ï¿½If the expression if found to be incorrect a message box will pop up at which point the expression can be fixed and accepted again\n\nThere is a combo box above the text box used to select expression templates used to quickly add frequently used expressions. ï¿½The templates contained within the combo box are loaded from an XML file ï¿½C:\\Documents and Settings\\All Users\\Application Data\\Prairie Technologies, Inc\\Prairie_Reader\\Prairie_ReaderFunctions.xmlï¿½. \n");
        
                // Place the "caret" for the help text at the beginning.
                jTextPaneFunctionEditorHelp.setCaretPosition(0);
                
                // Make a copy of the functions in case the "Cancel" option is selected
                origFunctions.removeAllElements();
                for (int i = 0; i < PrairieReaderFunctions.size(); i++) {
                    origFunctions.addElement(PrairieReaderFunctions.elementAt(i));
                }
                
                // First, clear the current list
                listFunctionTemplates.removeAll();
                
                // Update the user interface with the current list of functions
                for (int i = 0; i < PrairieReaderFunctions.size(); i++) {
                    listFunctionTemplates.add(PrairieReaderFunctions.get(i).functionName);
                }
                listFunctionTemplates.repaint();
                
                if (functionEditorCreateMode) {
                    // Select the first item in the list
                    if (PrairieReaderFunctions.size() > 0) {
                        listFunctionTemplates.select(0);
                        jTextFieldFunctionEntry.setText(PrairieReaderFunctions.get(0).functionExpression);
                        jTextFieldFunctionName.setText(PrairieReaderFunctions.get(0).functionName);
                    }
                }
                else {
                    // Select the item to be edited.
                    for (int i = 0; i < PrairieReaderFunctions.size(); i++) {
                        if (PrairieReaderFunctions.elementAt(i).functionName.equals(functionEditorFunctionName)) {
                            listFunctionTemplates.select(i);
                            jTextFieldFunctionEntry.setText(PrairieReaderFunctions.get(i).functionExpression);
                            jTextFieldFunctionName.setText(PrairieReaderFunctions.get(i).functionName);
                            i = PrairieReaderFunctions.size();
                        }
                    }
                }
            }

            private void jEditorPaneFunctionEditorHelpHyperlinkUpdate(javax.swing.event.HyperlinkEvent e) {
            if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                 JEditorPane pane = (JEditorPane) e.getSource();
                 if (e instanceof HTMLFrameHyperlinkEvent) {
                     HTMLFrameHyperlinkEvent  evt = (HTMLFrameHyperlinkEvent)e;
                     HTMLDocument doc = (HTMLDocument)pane.getDocument();
                     doc.processHTMLFrameHyperlinkEvent(evt);
                 } else {
                     try {
                         pane.setPage(e.getURL());
                     } catch (Throwable t) {
                        try {
                            FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                            PrintStream logStream = new PrintStream(logFile);
                            t.printStackTrace(logStream);
                            logStream.flush();
                            logStream.close();
                            logFile.flush();
                            logFile.close();
                        } catch (IOException exception) {}
                    }
                 }
             }
            }
            
            /** This method is called from within the constructor to
             * initialize the form.
             * WARNING: Do NOT modify this code. The content of this method is
             * always regenerated by the Form Editor.
             */
            @SuppressWarnings("unchecked")
            // <editor-fold defaultstate="collapsed" desc="Generated Code">
            private void initComponents() {

                //***********************************************
                // GUI code generated from FunctionEditor project
                //***********************************************
    
                jPanelFunctionEditorMain = new javax.swing.JPanel();
                jPanelFunctionEditorFunctionEnter = new javax.swing.JPanel();
                jLabelFunctionEnter1 = new javax.swing.JLabel();
                jTextFieldFunctionEntry = new javax.swing.JTextField();
                jLabelFunctionEnter2 = new javax.swing.JLabel();
                jPanelFunctionEditorFunctionTemplate = new javax.swing.JPanel();
                jLabelFunctionTemplates1 = new javax.swing.JLabel();
                jButtonFunctionTemplatesNew = new javax.swing.JButton();
                jButtonFunctionTemplatesDelete = new javax.swing.JButton();
                listFunctionTemplates = new java.awt.List();
                jTextFieldFunctionName = new javax.swing.JTextField();
                jLabel2 = new javax.swing.JLabel();
                jLabel3 = new javax.swing.JLabel();
                jButtonFunctionEditorCancel = new javax.swing.JButton();
                jButtonFunctionEditorAccept = new javax.swing.JButton();
                jLabel1 = new javax.swing.JLabel();
                jPanelFunctionEditorHelp = new javax.swing.JPanel();
                jScrollPaneFunctionEditorHelp = new javax.swing.JScrollPane();
                jTextPaneFunctionEditorHelp = new javax.swing.JTextPane();


                setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
                setTitle("Create/Edit Function");
                setModal(true);
                setResizable(false);

                jLabelFunctionEnter1.setText("Enter your function here");

                jTextFieldFunctionEntry.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jTextFieldFunctionEntryActionPerformed(evt);
                    }
                });
        
                jLabelFunctionEnter2.setText("Be sure to hit the \"Enter\" key after editing!");

                javax.swing.GroupLayout jPanelFunctionEditorFunctionEnterLayout = new javax.swing.GroupLayout(jPanelFunctionEditorFunctionEnter);
                jPanelFunctionEditorFunctionEnter.setLayout(jPanelFunctionEditorFunctionEnterLayout);
                jPanelFunctionEditorFunctionEnterLayout.setHorizontalGroup(
                    jPanelFunctionEditorFunctionEnterLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelFunctionEditorFunctionEnterLayout.createSequentialGroup()
                        .addGap(19, 19, 19)
                        .addGroup(jPanelFunctionEditorFunctionEnterLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabelFunctionEnter2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jTextFieldFunctionEntry)
                            .addComponent(jLabelFunctionEnter1, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE))
                        .addGap(15, 15, 15))
                );
                jPanelFunctionEditorFunctionEnterLayout.setVerticalGroup(
                    jPanelFunctionEditorFunctionEnterLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelFunctionEditorFunctionEnterLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabelFunctionEnter1)
                        .addGap(18, 18, 18)
                        .addComponent(jTextFieldFunctionEntry, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelFunctionEnter2)
                        .addContainerGap(82, Short.MAX_VALUE))
                );

                jLabelFunctionTemplates1.setText("Function Templates");

                jButtonFunctionTemplatesNew.setText("New Template");
                jButtonFunctionTemplatesNew.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonFunctionTemplatesNewActionPerformed(evt);
                    }
                });

                jButtonFunctionTemplatesDelete.setText("Delete Template");
                jButtonFunctionTemplatesDelete.setActionCommand("Save Template");
                jButtonFunctionTemplatesDelete.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonFunctionTemplatesDeleteActionPerformed(evt);
                    }
                });

                listFunctionTemplates.addMouseListener(new java.awt.event.MouseAdapter() {
                    public void mouseReleased(java.awt.event.MouseEvent evt) {
                        listFunctionTemplatesMouseReleased(evt);
                    }
                });

                jTextFieldFunctionName.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jTextFieldFunctionNameActionPerformed(evt);
                    }
                });
        
                jLabel2.setText("Function Name");

                jLabel3.setText("\"Enter\" after editing!");

                javax.swing.GroupLayout jPanelFunctionEditorFunctionTemplateLayout = new javax.swing.GroupLayout(jPanelFunctionEditorFunctionTemplate);
                jPanelFunctionEditorFunctionTemplate.setLayout(jPanelFunctionEditorFunctionTemplateLayout);
                jPanelFunctionEditorFunctionTemplateLayout.setHorizontalGroup(
                    jPanelFunctionEditorFunctionTemplateLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabelFunctionTemplates1, javax.swing.GroupLayout.PREFERRED_SIZE, 255, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createSequentialGroup()
                                .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jTextFieldFunctionName, javax.swing.GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE)
                                    .addComponent(listFunctionTemplates, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 137, Short.MAX_VALUE)
                                    .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, 137, Short.MAX_VALUE)
                                    .addComponent(jButtonFunctionTemplatesDelete, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jButtonFunctionTemplatesNew, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                );
                jPanelFunctionEditorFunctionTemplateLayout.setVerticalGroup(
                    jPanelFunctionEditorFunctionTemplateLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabelFunctionTemplates1)
                        .addGap(18, 18, 18)
                        .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelFunctionEditorFunctionTemplateLayout.createSequentialGroup()
                                .addComponent(jButtonFunctionTemplatesNew)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 26, Short.MAX_VALUE)
                                .addComponent(jButtonFunctionTemplatesDelete))
                            .addComponent(listFunctionTemplates, javax.swing.GroupLayout.PREFERRED_SIZE, 72, Short.MAX_VALUE))
                        .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createSequentialGroup()
                                .addGap(19, 19, 19)
                                .addComponent(jTextFieldFunctionName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanelFunctionEditorFunctionTemplateLayout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel3)))
                        .addContainerGap())
                );

                jButtonFunctionEditorCancel.setText("Cancel");
                jButtonFunctionEditorCancel.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonFunctionEditorCancelActionPerformed(evt);
                    }
                });

                jButtonFunctionEditorAccept.setText("Accept");
                jButtonFunctionEditorAccept.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonFunctionEditorAcceptActionPerformed(evt);
                    }
                });

                jLabel1.setText("Function Help");

                javax.swing.GroupLayout jPanelFunctionEditorMainLayout = new javax.swing.GroupLayout(jPanelFunctionEditorMain);
                jPanelFunctionEditorMain.setLayout(jPanelFunctionEditorMainLayout);
                jPanelFunctionEditorMainLayout.setHorizontalGroup(
                    jPanelFunctionEditorMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelFunctionEditorMainLayout.createSequentialGroup()
                        .addComponent(jPanelFunctionEditorFunctionEnter, javax.swing.GroupLayout.DEFAULT_SIZE, 334, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jPanelFunctionEditorFunctionTemplate, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelFunctionEditorMainLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 406, Short.MAX_VALUE)
                        .addComponent(jButtonFunctionEditorCancel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonFunctionEditorAccept)
                        .addGap(17, 17, 17))
                );
                jPanelFunctionEditorMainLayout.setVerticalGroup(
                    jPanelFunctionEditorMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelFunctionEditorMainLayout.createSequentialGroup()
                        .addGroup(jPanelFunctionEditorMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jPanelFunctionEditorFunctionEnter, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jPanelFunctionEditorFunctionTemplate, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelFunctionEditorMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanelFunctionEditorMainLayout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(jPanelFunctionEditorMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jButtonFunctionEditorAccept)
                                    .addComponent(jButtonFunctionEditorCancel))
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGroup(jPanelFunctionEditorMainLayout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel1)
                                .addContainerGap())))
                );

//                jEditorPaneFunctionEditorHelp.setContentType("text/html");
//                jEditorPaneFunctionEditorHelp.setEditable(false);
//                jScrollPane3.setViewportView(jEditorPaneFunctionEditorHelp);

                jTextPaneFunctionEditorHelp.setText("Quick Reference (Basic Overview)\nNote: Bold text is entered as is; grey italicized text needs to be replaced with actual values before entered.\n\nIntensity Values\n{Profile Number} - Current intensity of specified profile number.\n{Profile Number:Line Offset} - Intensity of specified profile number at a relative line offset.\n{Profile Number,Line Number} -ï¿½Intensity of specified profile number at an absolute line offset.\n{Profile Number^} ï¿½ Average intensity of specified profile number.\n{Profile Number^Line Start-Line Stop} ï¿½ Average intensity of specified profile number for a specified range of lines.\n\nTimestamps\n{t Profile Number } - Current timestamp in milliseconds for the specified profile number.\n{t Profile Number:Line Offset} - Timestamp of specified profile number at a relative line offset in milliseconds.\n{t Profile Number,Line Number} - Timestamp of specified profile number at an absolute line offset in milliseconds.\n\nFrame Number\n{f} - Current line number.\n\nOperators & Functions\nYou can use any common operators such asï¿½+,ï¿½-,ï¿½/ orï¿½* as well as any valid JavaScript math syntax such as Math.max(Expression \n#1,Expression #2), Math.abs(Expression) and Math.log(Expression). ï¿½Note that expressions are case sensitive.\n\nIntensity Values\nThere are three different ways to include intensity values in your functions: by profile number, by profile number and a relative \nline offset and by profile number with an absolute line number.\n\nTo include the current intensity value in your function simply enclose the profile number you are interested in within curly \nbraces,ï¿½{Profile Number}. ï¿½For example, to subtract the intensity values for profile one from those of profile two the function \nwould be the following, '{2} - {1}'. ï¿½These intensities will vary as the function is recalculated for each line.\n\nTo include intensity values from past and/or future lines enclose the profile number followed by the line offset separated by a \ncolon in curly braces, {Profile Number:Line Offset}. ï¿½For example, to calculate the change in intensity forï¿½profile one over each \nline the function would be the following, '{1} - {1:-1}'. ï¿½This takes the intensity for profile one for the current line and \nsubtracts from it the intensity value for the previous line.\n\nIf an offset should reference a nonexistent line either before the first line or after the last line then the values for the \nfirst and last lines are used insteadï¿½respectively.\n\nTo include intensity values for a specific lineï¿½enclose the profile number followed by the line number separated by a comma in \ncurly braces, {Profile Number,Line Number}. ï¿½For example, to calculate F over F0 for profile one where F is the current intensity \nvalue and F0 is the average of the first 5 lines, the function would be the following, '{1}/(({1,1} + {1,2} + {1,3} + {1,4} + \n{1,5}) / 5)' or ï¿½{1}/{1^1-5}ï¿½. ï¿½This takes the current intensity of profile one and divides it by the average intensity of the \nfirst 5 lines.\n\nTo include an intensity value that is the average value for an entire profile, enclose the profile number followed by a caret in \ncurly braces, {Profile Number^}.  For example, to calculate the average value for the second profile, the syntax would be the \nfollowing, ï¿½{2^}ï¿½.\n\nTo include an intensity value that is the average value for a section of a profile, enclose the profile number followed by a \ncaret, followed by the line number indicating the starting line number, followed by a hyphen, and followed by the line number \nindicating the stopping line number in curly braces, {Profile Number^Line Start-Line Stop}.  For example, to calculate the \naverage value for the first ten lines of profile one, the syntax would be the following, ï¿½[1^1-10}ï¿½.\n\nTimestamps\nThere are three different ways to include timestamp values in your functions: for the current line, for a relative line offset \nand for an absolute line number. ï¿½All timestamps are all in milliseconds.\n\nTo include theï¿½timestamp value for the current line in your function simplyï¿½enclose a lowercase T followed by the profile number \nwithin curly braces, {t Profile Number }. ï¿½For example, to display theï¿½timestamp value for each line for profile 1, the function \nwould be the following, '{t1}'. ï¿½Theï¿½timestamp will vary as the function is recalculated for each line.\n\nTo include timestamp values from past and/or future lines enclose a lowercase T followed by the profile number, followed by the \nline offset separated by a colon in curly braces {t Profile Number:Line Offset}. ï¿½For example, to display the line period for \nprofile 2, the function would be the following, '{t2} - {t2:-1}'. ï¿½This takes the timestamp value for the current line and \nsubtracts from it theï¿½timestamp value for the previous line which will generate a horizontal line.\n\nIf an offset should reference a nonexistent line either before the first line or after the last line then the values for the \nfirst and last lines are used insteadï¿½respectively.\n \nFinally to includeï¿½timestamp values for a specific lineï¿½enclose a lowercase T followed by the profile number, followed by the \nline number separated by a comma in curly braces, {t Profile Number,Line Number}. ï¿½For example, to display the current line's \ntimestamp relative to the 2nd line's timestamp for profile 3, the function would be the following, '{t3} - {t3,2}'. ï¿½This takes \nthe timestamp of the current line and subtracts is from the timestamp of the 2nd line.\n\nFrame Number\nTo include the current line number in your function simply enclose a lowercase f within curly braces, {f}. ï¿½For example to \ndisplay the current line number the function would be the following, '{f}'. ï¿½This will result in a diagonal line increasing by \none each line. ï¿½Not all too exciting on its own, but used in combination with other variables can prove invaluable.\n\nOperators & Functions (Top)\nAny of the four standard arithmetic operators can be used on the variables mentioned in this document: ï¿½addition (+), subtraction \n(-), division (/) and multiplication (*). ï¿½Theï¿½modulus operatorï¿½(%) can also be used.\n\nIn addition to variables and operators any numeric constants can be used as desired.\n\nIf basic operators, variables and constants are insufficient the entire JavaScript math library is available as well. ï¿½Keep in \nmind that JavaScript is case sensitive which is also true for any expressions entered for functions. ï¿½A few commonly used math \nfunctions are:\n\nMath.abs(Expression) - Calculates the absolute value ofï¿½given expression.\nMath.min(Expression #1,Expression #2) - Calculates the minimum value of two expressions.\nMath.max(Expression #1,Expression #2) - Calculates the maximum value of two expressions.\nMath.log(Expression) - Calculates the natural logï¿½ofï¿½given expression.\nMath.sqrt(Expression) - Calculates the square root of given expression.\nMath.pow(Expression #1,Expression #2) - Calculates the value of the first expression raised to the power determined byï¿½the value \nof the second expression.\nMath.cos(Expression) - Calculates the cosine ofï¿½given expression in radians.\nMath.sin(Expression) - Calculates theï¿½sine ofï¿½given expression in radians.\nMath.tan(Expression) - Calculates the tangent ofï¿½given expression in radians.\n\nBasic Overview\nFunctions can be used to display raw brightness over time data in different ways. ï¿½Functions consist of a few variables used to \naccess intensity data consisting of profile and line numbers enclosed in curly braces { } in combination with some basic \narithmetic operators and optionally some JavaScript syntax for advanced users.\n\nFunctions are added by clicking the Create Function button which will give focus to a text box highlighting the text 'Enter \nexpression' at which point a function can be typed in (syntax is explained in the rest of this document), the highlighted text \nwill be replaced by the first character typed. ï¿½When the expression is complete press Enter, at which point the expression will \nbe evaluated for correctness and saved. ï¿½To cancel simply clear out the expression field and press Enter. ï¿½If the expression if \nfound to be incorrect a message box will pop up at which point the expression can be fixed and accepted again\n\nThere is a combo box above the text box used to select expression templates used to quickly add frequently used expressions. ï¿½The \ntemplates contained within the combo box are loaded from an XML file in the plugins folder called Prairie_ReaderFunctions.xml. \n");
                jScrollPaneFunctionEditorHelp.setViewportView(jTextPaneFunctionEditorHelp);

                javax.swing.GroupLayout jPanelFunctionEditorHelpLayout = new javax.swing.GroupLayout(jPanelFunctionEditorHelp);
                jPanelFunctionEditorHelp.setLayout(jPanelFunctionEditorHelpLayout);
                jPanelFunctionEditorHelpLayout.setHorizontalGroup(
                    jPanelFunctionEditorHelpLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPaneFunctionEditorHelp, javax.swing.GroupLayout.DEFAULT_SIZE, 652, Short.MAX_VALUE)
                );
                jPanelFunctionEditorHelpLayout.setVerticalGroup(
                    jPanelFunctionEditorHelpLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPaneFunctionEditorHelp, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 177, Short.MAX_VALUE)
                );
        
                javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
                getContentPane().setLayout(layout);
                layout.setHorizontalGroup(
                    layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanelFunctionEditorMain, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(jPanelFunctionEditorHelp, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                );
                layout.setVerticalGroup(
                    layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanelFunctionEditorMain, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelFunctionEditorHelp, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                );

                pack();
            }// </editor-fold>

            //*************************
            // End of GUI code
            //*************************
                
            //***************************************************
            // Declarations generated from FunctionEditor project
            //***************************************************

            // Variables declaration - do not modify
            private javax.swing.JButton jButtonFunctionEditorAccept;
            private javax.swing.JButton jButtonFunctionEditorCancel;
            private javax.swing.JButton jButtonFunctionTemplatesDelete;
            private javax.swing.JButton jButtonFunctionTemplatesNew;
            private javax.swing.JLabel jLabel1;
            private javax.swing.JLabel jLabel2;
            private javax.swing.JLabel jLabel3;
            private javax.swing.JLabel jLabelFunctionEnter1;
            private javax.swing.JLabel jLabelFunctionEnter2;
            private javax.swing.JLabel jLabelFunctionTemplates1;
            private javax.swing.JPanel jPanelFunctionEditorFunctionEnter;
            private javax.swing.JPanel jPanelFunctionEditorFunctionTemplate;
            private javax.swing.JPanel jPanelFunctionEditorHelp;
            private javax.swing.JPanel jPanelFunctionEditorMain;
            private javax.swing.JScrollPane jScrollPaneFunctionEditorHelp;
            private javax.swing.JTextField jTextFieldFunctionEntry;
            private javax.swing.JTextField jTextFieldFunctionName;
            private javax.swing.JTextPane jTextPaneFunctionEditorHelp;
            private java.awt.List listFunctionTemplates;
            // End of variables declaration
            
            private void jButtonFunctionTemplatesNewActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                FunctionSettings newFunc = new FunctionSettings();
                newFunc.functionExpression = "{1}";
                newFunc.functionName = "func" + System.currentTimeMillis();
                PrairieReaderFunctions.add(newFunc);
                
                // First, clear the current list
                listFunctionTemplates.removeAll();
                
                // Update the user interface with the current list of functions
                for (int i = 0; i < PrairieReaderFunctions.size(); i++) {
                    listFunctionTemplates.add(PrairieReaderFunctions.get(i).functionName);
                }
                listFunctionTemplates.repaint();
                
                // Select the first item in the list
                if (PrairieReaderFunctions.size() > 0) {
                    listFunctionTemplates.select(PrairieReaderFunctions.size() - 1);
                    jTextFieldFunctionEntry.setText(PrairieReaderFunctions.get(PrairieReaderFunctions.size() - 1).functionExpression);
                    jTextFieldFunctionName.setText(PrairieReaderFunctions.get(PrairieReaderFunctions.size() - 1).functionName);
                }
            }

            private void jButtonFunctionTemplatesDeleteActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                if (PrairieReaderFunctions.size() == 0) return;
                if (listFunctionTemplates.getSelectedIndexes().length != 1) return;
                boolean canceled = IJ.showMessageWithCancel("Delete Function", "Are you sure you want to delete the function '" + PrairieReaderFunctions.elementAt(listFunctionTemplates.getSelectedIndex()).functionName + "'?");
                if (canceled == false) return;
                
                if (functionIndex == listFunctionTemplates.getSelectedIndex())
                    validFunction = true;
                
                PrairieReaderFunctions.removeElementAt(listFunctionTemplates.getSelectedIndex());
                
                // First, clear the current list
                listFunctionTemplates.removeAll();
                
                // Update the user interface with the current list of functions
                for (int i = 0; i < PrairieReaderFunctions.size(); i++) {
                    listFunctionTemplates.add(PrairieReaderFunctions.get(i).functionName);
                }
                listFunctionTemplates.repaint();
                
                // Select the first function if any functions still exist
                if (PrairieReaderFunctions.size() > 0) {
                    listFunctionTemplates.select(0);
                    jTextFieldFunctionEntry.setText(PrairieReaderFunctions.get(0).functionExpression);
                    jTextFieldFunctionName.setText(PrairieReaderFunctions.get(0).functionName);
                }
            }

            private void jButtonFunctionEditorCancelActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                // The operator has decided to "cancel" out of this dialog, so restore the function
                // list to the contents when the dialog was entered.
                PrairieReaderFunctions.removeAllElements();
                for (int i = 0; i < origFunctions.size(); i++) {
                    PrairieReaderFunctions.addElement(origFunctions.elementAt(i));
                }
                
                functionEditorCanceled = true;
                functionEditorSelectedFunction = -1;
                
                // Close the dialog and dispose of it
                this.setVisible(false);
                this.dispose();
            }

            private void jButtonFunctionEditorAcceptActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                
                if (PrairieReaderFunctions.size() > 0)
                    functionEditorSelectedFunction = listFunctionTemplates.getSelectedIndex();
                else
                    functionEditorSelectedFunction = -1;
                
                for (int i = 0; i < PrairieReaderFunctions.size(); i++) {
                    listFunctionTemplates.select(i);
                    jTextFieldFunctionEntry.setText(PrairieReaderFunctions.get(i).functionExpression);
                    jTextFieldFunctionName.setText(PrairieReaderFunctions.get(i).functionName);
                    if (!validateFunction(i)) {
                        IJ.showMessage("The function definition for \"" + PrairieReaderFunctions.elementAt(i).functionName +"\" is not valid!\nIt must be corrected or deleted");
                        return;
                    }
                }
                
                functionEditorCanceled = false;
                
                // Be sure to save the function definitions.
                writeFunctions();
                
                // Close the dialog and dispose of it
                this.setVisible(false);
                this.dispose();
            }

            private void listFunctionTemplatesMouseReleased(java.awt.event.MouseEvent evt) {
                // TODO add your handling code here:}
                int selectedIndex = listFunctionTemplates.getSelectedIndex();
                jTextFieldFunctionEntry.setText(PrairieReaderFunctions.get(selectedIndex).functionExpression);
                jTextFieldFunctionName.setText(PrairieReaderFunctions.get(selectedIndex).functionName);
            }
    
            private void jTextFieldFunctionNameActionPerformed(java.awt.event.ActionEvent evt) {
               // TODO add your handling code here:
               if (jTextFieldFunctionName.getText().length() == 0) {
                   IJ.showMessage("A Function name must be entered!");
                   jTextFieldFunctionName.setText("Function Name Here");
               } else {
                   PrairieReaderFunctions.elementAt(listFunctionTemplates.getSelectedIndex()).functionName = jTextFieldFunctionName.getText();
                   int selectedIndex = listFunctionTemplates.getSelectedIndex();
               
                   // First, clear the current list
                   listFunctionTemplates.removeAll();

                    // Update the user interface with the current list of functions
                    for (int i = 0; i < PrairieReaderFunctions.size(); i++) {
                        listFunctionTemplates.add(PrairieReaderFunctions.get(i).functionName);
                    }
                    listFunctionTemplates.repaint();
                    
                    listFunctionTemplates.select(selectedIndex);
               }
            }
 
            private void jTextFieldFunctionEntryActionPerformed(java.awt.event.ActionEvent evt) {
               // TODO add your handling code here:
                
                validateFunction(listFunctionTemplates.getSelectedIndex());
            }
            
            private boolean validateFunction (int index) {
             
                functionIndex = index;
                
                // Perform some basic validation of the function definition.
                
                // Has an empty string been entered?
                if (jTextFieldFunctionEntry.getText().length() == 0) {
                   validFunction = false;
                   IJ.showMessage("A Function must be entered!");
                   jTextFieldFunctionEntry.setText("{1}");
                   return false;
                }
                
                int leftParenCount = 0;
                int rightParenCount = 0;
                int leftCurlyBracket = 0;
                int rightCurlyBracket = 0;
                String functionStr = jTextFieldFunctionEntry.getText();
                char[] functionChars = functionStr.toCharArray();
                for (int i = 0; i < functionChars.length; i++) {
                    if (functionChars[i] == '(')
                        leftParenCount++;
                    else if (functionChars[i] == ')')
                        rightParenCount++;
                    else if (functionChars[i] == '{')
                        leftCurlyBracket++;
                    else if (functionChars[i] == '}')
                        rightCurlyBracket++;    
                }
                
                // Does the function have an equal number of "{" and "}"?
                if (leftParenCount != rightParenCount) {
                    validFunction = false;
                    IJ.showMessage("There must be equal numbers of \"(\" and \")\"!");
                    return false;
                }
                
                // Does the function have an equal number of "(" and ")"?
                if (leftCurlyBracket != rightCurlyBracket) {
                    validFunction = false;
                    IJ.showMessage("There must be equal numbers of \"{\" and \"}\"!");
                    return false;
                }
                
                // If the word "math" is inlcuded in the function, it must be "Math".
                functionStr = functionStr.replace("math", "Math");
                functionStr = functionStr.replace("mAth", "Math");
                functionStr = functionStr.replace("maTh", "Math");
                functionStr = functionStr.replace("matH", "Math");
                functionStr = functionStr.replace("mATh", "Math");
                functionStr = functionStr.replace("mAtH", "Math");
                functionStr = functionStr.replace("maTH", "Math");
                functionStr = functionStr.replace("MAth", "Math");
                functionStr = functionStr.replace("MaTh", "Math");
                functionStr = functionStr.replace("MatH", "Math");
                functionStr = functionStr.replace("MATh", "Math");
                functionStr = functionStr.replace("mATH", "Math");
                functionStr = functionStr.replace("MaTH", "Math");
                functionStr = functionStr.replace("MAtH", "Math");
                
                // The function definition has passed all validity tests, so record it
                PrairieReaderFunctions.elementAt(index).functionExpression = functionStr;
                jTextFieldFunctionEntry.setText(functionStr);
                   
                return true;
            }
        }

        public class FunctionProcessing {
            boolean validString = true;
            Vector<Integer> elementType = new Vector<Integer>();            // 0 = String, 1 = profile, 2 = timestamp, 3 = frame number, 4 = profile average
            Vector<Integer> profileNumber = new Vector<Integer>();
            Vector<Integer> offset = new Vector<Integer>();
            Vector<Boolean> useOffset = new Vector<Boolean>();
            Vector<Integer> frameNumber = new Vector<Integer>();
            Vector<Boolean> useFrameNumber = new Vector<Boolean>();
            Vector<String> element = new Vector<String>(); 
        }
              
        public FunctionProcessing ParseExpression(String functionExpression) {
            // Parse the functionExpression string and return the necessary settings.
            FunctionProcessing funcProc = new FunctionProcessing();
            
            // Remove white space from the function string.
            String functionNoWhiteSpace = functionExpression.replaceAll("\\s", "");
                          
            // Parse through the expression string and break it up into individual components that
            // can be reassembled into a new string for processing via JavaScript.
            String elementChars = "";
            for (int i = 0; i < functionNoWhiteSpace.length(); i++) {
                if (functionNoWhiteSpace.charAt(i) == '{') {
                    // First, if previous characters had been identified, then save those before processing th
                    // profile number, timestamp, or frame number.
                    if (elementChars.length() > 0) {
                        funcProc.elementType.add(0);
                        funcProc.element.add(elementChars);
                        funcProc.profileNumber.add(-1);
                        funcProc.frameNumber.add(-1);
                        funcProc.offset.add(-1);
                        funcProc.useFrameNumber.add(false);
                        funcProc.useOffset.add(false);
                        elementChars = "";
                    }
                    
                    // Now, process the profile number, timestamp, or frame number
                    
                    if ((functionNoWhiteSpace.charAt(i+1) == 't') || (functionNoWhiteSpace.charAt(i+1) == 'T')) {
                        // Process a "timestamp"
                        funcProc.elementType.add(2);
                        funcProc.element.add("NA");
                        int iPosColon = functionNoWhiteSpace.indexOf(':', i);
                        int iPosComma = functionNoWhiteSpace.indexOf(',', i);
                        int iPosCloseBracket = functionNoWhiteSpace.indexOf('}', i);
                        if ((iPosColon >= 0) && (iPosColon < iPosCloseBracket)) {
                            // Process a relative timestamp offset
                            int profileNumber = Integer.parseInt(functionNoWhiteSpace.substring(i + 2, iPosColon));
                            funcProc.profileNumber.add(profileNumber);
                            int frameOffset = Integer.parseInt(functionNoWhiteSpace.substring(iPosColon + 1, iPosCloseBracket));
                            funcProc.frameNumber.add(frameOffset);
                            funcProc.useFrameNumber.add(false);
                            funcProc.offset.add(-1);
                            funcProc.useOffset.add(true);
                        }
                        else if ((iPosComma >= 0) && (iPosComma < iPosCloseBracket)) {
                            // Process an absolute frame timestamp offset
                            int profileNumber = Integer.parseInt(functionNoWhiteSpace.substring(i + 2, iPosComma));
                            funcProc.profileNumber.add(profileNumber);
                            int frameNumber = Integer.parseInt(functionNoWhiteSpace.substring(iPosComma + 1, iPosCloseBracket));
                            funcProc.frameNumber.add(-1);
                            funcProc.useFrameNumber.add(true);
                            funcProc.offset.add(frameNumber);
                            funcProc.useOffset.add(false);
                        }
                        else {
                            int profileNumber = Integer.parseInt(functionNoWhiteSpace.substring(i + 2, iPosCloseBracket));
                            funcProc.profileNumber.add(profileNumber);
                            funcProc.frameNumber.add(-1);
                            funcProc.offset.add(-1);
                            funcProc.useFrameNumber.add(false);
                            funcProc.useOffset.add(false);
                        }
                        // Skip ahead to the "}" character
                        i = iPosCloseBracket;
                    }
                    else if ((functionNoWhiteSpace.charAt(i+1) == 'f') || (functionNoWhiteSpace.charAt(i+1) == 'F')) {
                        // Process a "frame number"
                        funcProc.elementType.add(3);
                        funcProc.profileNumber.add(-1);
                        funcProc.frameNumber.add(-1);
                        funcProc.offset.add(-1);
                        funcProc.element.add("NA");
                        funcProc.useFrameNumber.add(false);
                        funcProc.useOffset.add(false);
                        // Skip ahead to the "}" character
                        i = functionNoWhiteSpace.indexOf('}', i);
                    }
                    else {
                        // a profile number has been specified.
                        funcProc.element.add("NA");
                        int iPosColon = functionNoWhiteSpace.indexOf(':', i);
                        int iPosComma = functionNoWhiteSpace.indexOf(',', i);
                        int iPosCaret = functionNoWhiteSpace.indexOf('^', i);
                        int iPosHyphen = functionNoWhiteSpace.indexOf('-', i);
                        int iPosCloseBracket = functionNoWhiteSpace.indexOf('}', i);
                        if ((iPosColon >= 0) && (iPosColon < iPosCloseBracket)) {
                            // Process a relative profile offset
                            int profileOffset = Integer.parseInt(functionNoWhiteSpace.substring(iPosColon + 1, iPosCloseBracket));
                            int profileNumber = Integer.parseInt(functionNoWhiteSpace.substring(i + 1, iPosColon));
                            funcProc.elementType.add(1);
                            funcProc.profileNumber.add(profileNumber);
                            funcProc.frameNumber.add(-1);
                            funcProc.offset.add(profileOffset);
                            funcProc.useFrameNumber.add(false);
                            funcProc.useOffset.add(true);
                        }
                        else if ((iPosComma >= 0) && (iPosComma < iPosCloseBracket)) {
                            // Process an absolute profile offset
                            funcProc.elementType.add(1);
                            int profileNumber = Integer.parseInt(functionNoWhiteSpace.substring(i + 1, iPosComma));
                            funcProc.profileNumber.add(profileNumber);
                            profileNumber = Integer.parseInt(functionNoWhiteSpace.substring(iPosComma + 1, iPosCloseBracket));
                            funcProc.frameNumber.add(profileNumber);
                            funcProc.offset.add(-1);
                            funcProc.useFrameNumber.add(true);
                            funcProc.useOffset.add(false);
                        }
                        else if ((iPosCaret >= 0) && (iPosCaret < iPosCloseBracket)) {
                            // Process an "average" calculation for a profile
                            // Now determine if the "average" is based upon the entire profile
                            // or just a range of the profile.
                            int profileNumber = Integer.parseInt(functionNoWhiteSpace.substring(i + 1, iPosCaret));
                                if ((iPosHyphen >= 0) && (iPosHyphen < iPosCloseBracket)) {
                                // the "average" value is a function of just a portion of the profile
                                int profileStartLine = Integer.parseInt(functionNoWhiteSpace.substring(iPosCaret + 1, iPosHyphen));
                                int profileStopLine = Integer.parseInt(functionNoWhiteSpace.substring(iPosHyphen + 1, iPosCloseBracket));
                                funcProc.elementType.add(4);
                                funcProc.profileNumber.add(profileNumber);
                                if (profileStartLine <= profileStopLine) {
                                    funcProc.frameNumber.add(profileStartLine);
                                    funcProc.offset.add(profileStopLine);
                                }
                                else {
                                    funcProc.frameNumber.add(profileStopLine);
                                    funcProc.offset.add(profileStartLine);
                                }
                                funcProc.useFrameNumber.add(true);
                                funcProc.useOffset.add(false);
                            }
                            else {
                                // the "average" value is a function of the entire profile
                                funcProc.elementType.add(4);
                                funcProc.profileNumber.add(profileNumber);
                                funcProc.frameNumber.add(-1);
                                funcProc.offset.add(-1);
                                funcProc.useFrameNumber.add(false);
                                funcProc.useOffset.add(false);
                            }
                        }
                        else {
                            // Just use the profile
                            int profileNumber = Integer.parseInt(functionNoWhiteSpace.substring(i + 1, iPosCloseBracket));
                            funcProc.elementType.add(1);
                            funcProc.profileNumber.add(profileNumber);
                            funcProc.frameNumber.add(-1);
                            funcProc.offset.add(-1);
                            funcProc.useFrameNumber.add(false);
                            funcProc.useOffset.add(false);
                        }
                        // Skip ahead to the "}" character
                        i = iPosCloseBracket;
                    }
                }
                else {
                    elementChars += functionNoWhiteSpace.charAt(i);
                }
            }
            
            // Be sure to add the last string entry that might be present
            if (elementChars.length() > 0) {
                funcProc.elementType.add(0);
                funcProc.element.add(elementChars);
                funcProc.profileNumber.add(-1);
                funcProc.frameNumber.add(-1);
                funcProc.offset.add(-1);
                elementChars = "";
            }
                    
//            for (int i = 0; i < funcProc.element.size(); i++) {
//                IJ.showMessage("element " + i + "  type = " + funcProc.elementType.elementAt(i) + " " + "   element = " + funcProc.element.elementAt(i) + "  profile = " + funcProc.profileNumber.elementAt(i) + "   offset = " + funcProc.offset.elementAt(i));
//            }
            return funcProc;
        }

        int LinescanTypeLine = 0;
        int LinescanTypeFreehand = 1;
        int LinescanTypeSpiral = 2;
        int LinescanTypeLissajous = 3;
        int LinescanTypeCircle = 4;
        
        boolean functionEditorCanceled = true;
        int functionEditorSelectedFunction = -1;
        boolean functionEditorCreateMode = true;
        String functionEditorFunctionName = "";
            
        
        public class LinescanAnalysis extends JDialog {

            Frame lsDialogParentFrame;
            
            //**************************************************
            // Declarations generated from LSViewerUI project
            //**************************************************

            // Variables declaration - do not modify
            private javax.swing.JButton jButtonAI0Color;
            private javax.swing.JButton jButtonAI1Color;
            private javax.swing.JButton jButtonAI2Color;
            private javax.swing.JButton jButtonAI3Color;
            private javax.swing.JButton jButtonAI4Color;
            private javax.swing.JButton jButtonAI5Color;
            private javax.swing.JButton jButtonAI6Color;
            private javax.swing.JButton jButtonAI7Color;
            private javax.swing.JButton jButtonAnalogDataClearFunctions;
            private javax.swing.JButton jButtonAnalogDataCreateFunction;
            private javax.swing.JButton jButtonAnalogDataEditFunction;
            private javax.swing.JButton jButtonAnalogDataRemoveFunction;
            private javax.swing.JButton jButtonAnalogDataSelectFunctionColor;
            private javax.swing.JButton jButtonCopyProfiles;
            private javax.swing.JButton jButtonCreateProfile;
            private javax.swing.JButton jButtonDeleteAllProfiles;
            private javax.swing.JButton jButtonDeleteProfile;
            private javax.swing.JButton jButtonExportAllProfiles;
            private javax.swing.JButton jButtonExportSelectedProfiles;
            private javax.swing.JButton jButtonPasteProfiles;
            private javax.swing.JButton jButtonProfileClearFunctions;
            private javax.swing.JButton jButtonProfileCreateFunction;
            private javax.swing.JButton jButtonProfileEditFunction;
            private javax.swing.JButton jButtonProfileRemoveFunction;
            private javax.swing.JButton jButtonSelectFunctionColor;
            private javax.swing.JButton jButtonSelectProfileColor;
            private javax.swing.JButton jButtonThresholdMaxReset;
            private javax.swing.JButton jButtonThresholdMinReset;
            private javax.swing.JCheckBox jCheckBoxApplyTriggerSyncScaling;
            private javax.swing.JCheckBox jCheckBoxCloseWindowsOnClosing;
            private javax.swing.JCheckBox jCheckBoxProfilesInSeparateWindows;
            private javax.swing.JCheckBox jCheckBoxThresholdProfile;
            private javax.swing.JComboBox jComboBoxChannelSelection;
            private javax.swing.JComboBox jComboBoxIntensityMethod;
            private javax.swing.JFileChooser jFileChooserSaveProfiles;
            private javax.swing.JLabel jLabelAI0Name;
            private javax.swing.JLabel jLabelAI0Units;
            private javax.swing.JLabel jLabelAI1Name;
            private javax.swing.JLabel jLabelAI1Units;
            private javax.swing.JLabel jLabelAI2Name;
            private javax.swing.JLabel jLabelAI2Units;
            private javax.swing.JLabel jLabelAI3Name;
            private javax.swing.JLabel jLabelAI3Units;
            private javax.swing.JLabel jLabelAI4Name;
            private javax.swing.JLabel jLabelAI4Units;
            private javax.swing.JLabel jLabelAI5Name;
            private javax.swing.JLabel jLabelAI5Units;
            private javax.swing.JLabel jLabelAI6Name;
            private javax.swing.JLabel jLabelAI6Units;
            private javax.swing.JLabel jLabelAI7Name;
            private javax.swing.JLabel jLabelAI7Units;
            private javax.swing.JLabel jLabelAnalogDataFunctionColor;
            private javax.swing.JLabel jLabelAnalogDataSelection;
            private javax.swing.JLabel jLabelChannelSelection1;
            private javax.swing.JLabel jLabelChannelSelection2;
            private javax.swing.JLabel jLabelCloseWindowsOnClosing;
            private javax.swing.JLabel jLabelFunctionColor;
            private javax.swing.JLabel jLabelIntensityMethod1;
            private javax.swing.JLabel jLabelIntensityMethod2;
            private javax.swing.JLabel jLabelProfileColor1;
            private javax.swing.JLabel jLabelProfilePosition1;
            private javax.swing.JLabel jLabelProfilePosition2;
            private javax.swing.JLabel jLabelProfileSelection1;
            private javax.swing.JLabel jLabelProfileSelection2;
            private javax.swing.JLabel jLabelProfileWidth;
            private javax.swing.JLabel jLabelProfileWidthValue;
            private javax.swing.JLabel jLabelThresholdMax;
            private javax.swing.JLabel jLabelThresholdMaxValue;
            private javax.swing.JLabel jLabelThresholdMin;
            private javax.swing.JLabel jLabelThresholdMinValue;
            private javax.swing.JPanel jPanel6;
            private javax.swing.JPanel jPanelAI0;
            private javax.swing.JPanel jPanelAI1;
            private javax.swing.JPanel jPanelAI2;
            private javax.swing.JPanel jPanelAI3;
            private javax.swing.JPanel jPanelAI4;
            private javax.swing.JPanel jPanelAI5;
            private javax.swing.JPanel jPanelAI6;
            private javax.swing.JPanel jPanelAI7;
            private javax.swing.JPanel jPanelAIFunctions;
            private javax.swing.JPanel jPanelAnalogDataFunctionColor;
            private javax.swing.JPanel jPanelAnalogDataTab;
            private javax.swing.JPanel jPanelFunctionColor;
            private javax.swing.JPanel jPanelIntensityProfilesAll;
            private javax.swing.JPanel jPanelIntensityProfilesGroup1;
            private javax.swing.JPanel jPanelIntensityProfilesGroup2;
            private javax.swing.JPanel jPanelIntensityProfilesGroup3;
            private javax.swing.JPanel jPanelIntensityProfilesGroup4;
            private javax.swing.JPanel jPanelIntensityProfilesTab;
            private javax.swing.JPanel jPanelProfileColor;
            private javax.swing.JScrollBar jScrollBarProfilePosition;
            private javax.swing.JScrollBar jScrollBarThresholdMax;
            private javax.swing.JScrollBar jScrollBarThresholdMin;
            private javax.swing.JSlider jSliderProfileWidth;
            private javax.swing.JTabbedPane jTabbedPaneControls;
            private javax.swing.JToggleButton jToggleButtonAI0;
            private javax.swing.JToggleButton jToggleButtonAI1;
            private javax.swing.JToggleButton jToggleButtonAI2;
            private javax.swing.JToggleButton jToggleButtonAI3;
            private javax.swing.JToggleButton jToggleButtonAI4;
            private javax.swing.JToggleButton jToggleButtonAI5;
            private javax.swing.JToggleButton jToggleButtonAI6;
            private javax.swing.JToggleButton jToggleButtonAI7;
            private javax.swing.JToggleButton jToggleButtonThresholdEdit;
            private java.awt.List listAnalogDataFunctionList;
            private java.awt.List listProfileFunctionList;
            private java.awt.List listProfileList;
            // End of variables declaration

            public LinescanAnalysis(Frame parent, String title, boolean modal)   {
                super(parent, title, modal);
 		lsDialogParentFrame = parent;
                setTitle( title );
                setSize( 900, 400 );
                setBackground( Color.gray );
                getContentPane().setLayout( new BorderLayout() );
                
                //LinescanAnalysis.this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
                addWindowListener(    
                  new java.awt.event.WindowAdapter()    
                  {   
                    public void windowClosing( java.awt.event.WindowEvent e )    
                    {   
                        // If the linescan windows are not to be closed with the dialog, at
                        // least remove the profiles from the windows.
                        if (!jCheckBoxCloseWindowsOnClosing.isSelected()) {
                            // Need a separate "overlay" for each of the linescan windows.
                            Overlay lsImageOverlay = new Overlay();
                            Overlay lsImageOverlay1 = new Overlay();
                            Overlay lsImageOverlay2 = new Overlay();
                            Overlay lsImageOverlay3 = new Overlay();
                            Overlay lsImageOverlay4 = new Overlay();
 
                            // Add the overlays to the appropriate windows.
                           lsWindow.getImagePlus().setOverlay(lsImageOverlay);
                           lsWindow.getImagePlus().draw();
                           if (lsNumChans > 1) {
                               lsSingleChannelWindow1.getImagePlus().setOverlay(lsImageOverlay1);
                               lsSingleChannelWindow1.getImagePlus().draw();
                               lsSingleChannelWindow2.getImagePlus().setOverlay(lsImageOverlay2);
                               lsSingleChannelWindow2.getImagePlus().draw();
                               if (lsNumChans > 2) {
                                   lsSingleChannelWindow3.getImagePlus().setOverlay(lsImageOverlay3);
                                   lsSingleChannelWindow3.getImagePlus().draw();
                               }
                               if (lsNumChans > 3) {
                                   lsSingleChannelWindow4.getImagePlus().setOverlay(lsImageOverlay4);
                                   lsSingleChannelWindow4.getImagePlus().draw();
                               }
                           }
                        }
                        else {
                            // Close the linescan image windows.
                            if (lsWindow != null)
                                lsWindow.close();
                            if (lsSingleChannelWindow1 != null)
                                lsSingleChannelWindow1.close();
                            if (lsSingleChannelWindow2 != null)
                                lsSingleChannelWindow2.close();
                            if (lsSingleChannelWindow3 != null)
                                lsSingleChannelWindow3.close();
                            if (lsSingleChannelWindow4 != null)
                                lsSingleChannelWindow4.close();
                            
                            // Close the linescan reference image windows.
                            if (lsWindowCompRef != null)
                                lsWindowCompRef.close();
                            if (lsSingleChannelWindow1Ref != null)
                                lsSingleChannelWindow1Ref.close();
                            if (lsSingleChannelWindow2Ref != null)
                                lsSingleChannelWindow2Ref.close();
                            if (lsSingleChannelWindow3Ref != null)
                                lsSingleChannelWindow3Ref.close();
                            if (lsSingleChannelWindow4Ref != null)
                                lsSingleChannelWindow4Ref.close();
                        }
                        
                        if (lsImagePlusPlotWindow != null)
                            lsImagePlusPlotWindow.close();
                        if (lsImagePlusPlotSingleChannelWindow1 != null)
                            lsImagePlusPlotSingleChannelWindow1.close();
                        if (lsImagePlusPlotSingleChannelWindow2 != null)
                            lsImagePlusPlotSingleChannelWindow2.close();
                        if (lsImagePlusPlotSingleChannelWindow3 != null)
                            lsImagePlusPlotSingleChannelWindow3.close();
                        if (lsImagePlusPlotSingleChannelWindow4 != null)
                            lsImagePlusPlotSingleChannelWindow4.close();
                        for (int i = 0; i < lsProfiles.size(); i++) {
                            lsProfiles.elementAt(i).imagePlusPlotWindow.close();
                        }
                        if (lsAnalogDataPresent) {
                            for (int i = 0; i < lsAnalogData.size(); i++) {
                                if (lsAnalogData.elementAt(i).imagePlusPlotWindow != null)
                                    lsAnalogData.elementAt(i).imagePlusPlotWindow.close();
                            }
                        }
                        for (int i = 0; i < lsFunctions.size(); i++) {
                            if (lsFunctions.elementAt(i).imagePlusPlotWindow != null)
                                lsFunctions.elementAt(i).imagePlusPlotWindow.close();
                        }
                        for (int i = 0; i < lsAnalogDataFunctions.size(); i++) {
                            if (lsAnalogDataFunctions.elementAt(i).imagePlusPlotWindow != null)
                            lsAnalogDataFunctions.elementAt(i).imagePlusPlotWindow.close();
                        }
                        LinescanAnalysis.this.dispose();
                        //LinescanAnalysis.this.setVisible(false);
                    }   
                  }   
                );   

                //*******************************************
                // GUI code generated from LSViewerUI project
                //*******************************************
    
                jFileChooserSaveProfiles = new javax.swing.JFileChooser();
                jTabbedPaneControls = new javax.swing.JTabbedPane();
                jPanelIntensityProfilesTab = new javax.swing.JPanel();
                jPanelIntensityProfilesAll = new javax.swing.JPanel();
                jPanelIntensityProfilesGroup1 = new javax.swing.JPanel();
                jLabelChannelSelection1 = new javax.swing.JLabel();
                jLabelChannelSelection2 = new javax.swing.JLabel();
                jComboBoxChannelSelection = new javax.swing.JComboBox();
                jButtonCreateProfile = new javax.swing.JButton();
                jCheckBoxCloseWindowsOnClosing = new javax.swing.JCheckBox();
                jLabelCloseWindowsOnClosing = new javax.swing.JLabel();
                jButtonProfileCreateFunction = new javax.swing.JButton();
                jButtonProfileEditFunction = new javax.swing.JButton();
                jButtonProfileRemoveFunction = new javax.swing.JButton();
                jButtonProfileClearFunctions = new javax.swing.JButton();
                jPanelIntensityProfilesGroup2 = new javax.swing.JPanel();
                jLabelProfileSelection1 = new javax.swing.JLabel();
                jButtonDeleteProfile = new javax.swing.JButton();
                listProfileList = new java.awt.List();
                jButtonExportSelectedProfiles = new javax.swing.JButton();
                jButtonExportAllProfiles = new javax.swing.JButton();
                jCheckBoxProfilesInSeparateWindows = new javax.swing.JCheckBox();
                jButtonCopyProfiles = new javax.swing.JButton();
                jButtonPasteProfiles = new javax.swing.JButton();
                jButtonDeleteAllProfiles = new javax.swing.JButton();
                jCheckBoxThresholdProfile = new javax.swing.JCheckBox();
                jToggleButtonThresholdEdit = new javax.swing.JToggleButton();
                jScrollBarThresholdMin = new javax.swing.JScrollBar();
                jLabelThresholdMin = new javax.swing.JLabel();
                jLabelThresholdMinValue = new javax.swing.JLabel();
                jScrollBarThresholdMax = new javax.swing.JScrollBar();
                jLabelThresholdMax = new javax.swing.JLabel();
                jLabelThresholdMaxValue = new javax.swing.JLabel();
                jButtonThresholdMaxReset = new javax.swing.JButton();
                jButtonThresholdMinReset = new javax.swing.JButton();
                jLabelProfileSelection2 = new javax.swing.JLabel();
                listProfileFunctionList = new java.awt.List();
                jPanelIntensityProfilesGroup3 = new javax.swing.JPanel();
                jLabelProfileWidth = new javax.swing.JLabel();
                jSliderProfileWidth = new javax.swing.JSlider();
                jLabelProfileWidthValue = new javax.swing.JLabel();
                jLabelProfileColor1 = new javax.swing.JLabel();
                jButtonSelectProfileColor = new javax.swing.JButton();
                jPanelProfileColor = new javax.swing.JPanel();
                jLabelIntensityMethod1 = new javax.swing.JLabel();
                jComboBoxIntensityMethod = new javax.swing.JComboBox();
                jLabelIntensityMethod2 = new javax.swing.JLabel();
                jLabelFunctionColor = new javax.swing.JLabel();
                jButtonSelectFunctionColor = new javax.swing.JButton();
                jPanelFunctionColor = new javax.swing.JPanel();
                jPanelIntensityProfilesGroup4 = new javax.swing.JPanel();
                jScrollBarProfilePosition = new javax.swing.JScrollBar();
                jLabelProfilePosition1 = new javax.swing.JLabel();
                jLabelProfilePosition2 = new javax.swing.JLabel();
                jPanelAnalogDataTab = new javax.swing.JPanel();
                jPanel6 = new javax.swing.JPanel();
                jPanelAI0 = new javax.swing.JPanel();
                jToggleButtonAI0 = new javax.swing.JToggleButton();
                jLabelAI0Name = new javax.swing.JLabel();
                jLabelAI0Units = new javax.swing.JLabel();
                jButtonAI0Color = new javax.swing.JButton();
                jPanelAI1 = new javax.swing.JPanel();
                jToggleButtonAI1 = new javax.swing.JToggleButton();
                jLabelAI1Name = new javax.swing.JLabel();
                jLabelAI1Units = new javax.swing.JLabel();
                jButtonAI1Color = new javax.swing.JButton();
                jPanelAI2 = new javax.swing.JPanel();
                jToggleButtonAI2 = new javax.swing.JToggleButton();
                jLabelAI2Name = new javax.swing.JLabel();
                jLabelAI2Units = new javax.swing.JLabel();
                jButtonAI2Color = new javax.swing.JButton();
                jPanelAI3 = new javax.swing.JPanel();
                jToggleButtonAI3 = new javax.swing.JToggleButton();
                jLabelAI3Name = new javax.swing.JLabel();
                jLabelAI3Units = new javax.swing.JLabel();
                jButtonAI3Color = new javax.swing.JButton();
                jPanelAI4 = new javax.swing.JPanel();
                jToggleButtonAI4 = new javax.swing.JToggleButton();
                jLabelAI4Name = new javax.swing.JLabel();
                jLabelAI4Units = new javax.swing.JLabel();
                jButtonAI4Color = new javax.swing.JButton();
                jPanelAI5 = new javax.swing.JPanel();
                jToggleButtonAI5 = new javax.swing.JToggleButton();
                jLabelAI5Name = new javax.swing.JLabel();
                jLabelAI5Units = new javax.swing.JLabel();
                jButtonAI5Color = new javax.swing.JButton();
                jPanelAI6 = new javax.swing.JPanel();
                jToggleButtonAI6 = new javax.swing.JToggleButton();
                jLabelAI6Name = new javax.swing.JLabel();
                jLabelAI6Units = new javax.swing.JLabel();
                jButtonAI6Color = new javax.swing.JButton();
                jPanelAI7 = new javax.swing.JPanel();
                jToggleButtonAI7 = new javax.swing.JToggleButton();
                jLabelAI7Name = new javax.swing.JLabel();
                jLabelAI7Units = new javax.swing.JLabel();
                jButtonAI7Color = new javax.swing.JButton();
                jCheckBoxApplyTriggerSyncScaling = new javax.swing.JCheckBox();
                jPanelAIFunctions = new javax.swing.JPanel();
                jButtonAnalogDataCreateFunction = new javax.swing.JButton();
                jButtonAnalogDataEditFunction = new javax.swing.JButton();
                jButtonAnalogDataRemoveFunction = new javax.swing.JButton();
                jButtonAnalogDataClearFunctions = new javax.swing.JButton();
                jLabelAnalogDataSelection = new javax.swing.JLabel();
                listAnalogDataFunctionList = new java.awt.List();
                jLabelAnalogDataFunctionColor = new javax.swing.JLabel();
                jButtonAnalogDataSelectFunctionColor = new javax.swing.JButton();
                jPanelAnalogDataFunctionColor = new javax.swing.JPanel();

                jFileChooserSaveProfiles.setDialogType(javax.swing.JFileChooser.SAVE_DIALOG);

                setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

                jPanelIntensityProfilesAll.setPreferredSize(new java.awt.Dimension(800, 157));

                jPanelIntensityProfilesGroup1.setPreferredSize(new java.awt.Dimension(139, 145));

                jLabelChannelSelection1.setText("Select the channel(s) to");

                jLabelChannelSelection2.setText("create a 'Profile' within");

                jComboBoxChannelSelection.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

                jButtonCreateProfile.setText("Create Profile(s)");
                jButtonCreateProfile.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonCreateProfileActionPerformed(evt);
                    }
                });

                jCheckBoxCloseWindowsOnClosing.setSelected(true);
                jCheckBoxCloseWindowsOnClosing.setText("Close Linescan Win-");

                jLabelCloseWindowsOnClosing.setText("dows with dialog");

                jButtonProfileCreateFunction.setText("Create Function...");
                jButtonProfileCreateFunction.setMaximumSize(new java.awt.Dimension(97, 23));
                jButtonProfileCreateFunction.setMinimumSize(new java.awt.Dimension(97, 23));
                jButtonProfileCreateFunction.setPreferredSize(new java.awt.Dimension(97, 19));
                jButtonProfileCreateFunction.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonProfileCreateFunctionActionPerformed(evt);
                    }
                });

                jButtonProfileEditFunction.setText("Edit Function...");
                jButtonProfileEditFunction.setPreferredSize(new java.awt.Dimension(149, 19));
                jButtonProfileEditFunction.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonProfileEditFunctionActionPerformed(evt);
                    }
                });

                jButtonProfileRemoveFunction.setText("Remove Function(s)");
                jButtonProfileRemoveFunction.setPreferredSize(new java.awt.Dimension(149, 19));
                jButtonProfileRemoveFunction.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonProfileRemoveFunctionActionPerformed(evt);
                    }
                });

                jButtonProfileClearFunctions.setText("Clear All Functions");
                jButtonProfileClearFunctions.setPreferredSize(new java.awt.Dimension(149, 19));
                jButtonProfileClearFunctions.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonProfileClearFunctionsActionPerformed(evt);
                    }
                });

                javax.swing.GroupLayout jPanelIntensityProfilesGroup1Layout = new javax.swing.GroupLayout(jPanelIntensityProfilesGroup1);
                jPanelIntensityProfilesGroup1.setLayout(jPanelIntensityProfilesGroup1Layout);
                jPanelIntensityProfilesGroup1Layout.setHorizontalGroup(
                    jPanelIntensityProfilesGroup1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesGroup1Layout.createSequentialGroup()
                        .addComponent(jComboBoxChannelSelection, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())
                    .addGroup(jPanelIntensityProfilesGroup1Layout.createSequentialGroup()
                        .addComponent(jButtonCreateProfile)
                        .addContainerGap())
                    .addGroup(jPanelIntensityProfilesGroup1Layout.createSequentialGroup()
                        .addGroup(jPanelIntensityProfilesGroup1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelIntensityProfilesGroup1Layout.createSequentialGroup()
                                .addGap(21, 21, 21)
                                .addComponent(jLabelCloseWindowsOnClosing, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addComponent(jCheckBoxCloseWindowsOnClosing, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelIntensityProfilesGroup1Layout.createSequentialGroup()
                        .addGroup(jPanelIntensityProfilesGroup1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jButtonProfileCreateFunction, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                            .addComponent(jButtonProfileEditFunction, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                            .addComponent(jButtonProfileClearFunctions, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                            .addComponent(jButtonProfileRemoveFunction, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                            .addComponent(jLabelChannelSelection1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                            .addComponent(jLabelChannelSelection2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE))
                        .addGap(10, 10, 10))
                );
                jPanelIntensityProfilesGroup1Layout.setVerticalGroup(
                    jPanelIntensityProfilesGroup1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesGroup1Layout.createSequentialGroup()
                        .addComponent(jLabelChannelSelection1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelChannelSelection2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jComboBoxChannelSelection, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonCreateProfile, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(27, 27, 27)
                        .addComponent(jCheckBoxCloseWindowsOnClosing, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelCloseWindowsOnClosing)
                        .addGap(69, 69, 69)
                        .addComponent(jButtonProfileCreateFunction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonProfileEditFunction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonProfileRemoveFunction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButtonProfileClearFunctions, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())
                );

                jPanelIntensityProfilesGroup2.setPreferredSize(new java.awt.Dimension(167, 145));

                jLabelProfileSelection1.setText("Select a Profile");

                jButtonDeleteProfile.setText("Delete Selected Profile(s)");
                jButtonDeleteProfile.setMaximumSize(new java.awt.Dimension(169, 23));
                jButtonDeleteProfile.setPreferredSize(new java.awt.Dimension(155, 19));
                jButtonDeleteProfile.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonDeleteProfileActionPerformed(evt);
                    }
                });

                listProfileList.setMultipleMode(true);
                listProfileList.addMouseListener(new java.awt.event.MouseAdapter() {
                    public void mouseReleased(java.awt.event.MouseEvent evt) {
                        listProfileListMouseReleased(evt);
                    }
                });

                jButtonExportSelectedProfiles.setText("Export Selected Profile(s)...");
                jButtonExportSelectedProfiles.setPreferredSize(new java.awt.Dimension(169, 19));
                jButtonExportSelectedProfiles.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonExportSelectedProfilesActionPerformed(evt);
                    }
                });

                jButtonExportAllProfiles.setText("Export All Profile(s)...");
                jButtonExportAllProfiles.setPreferredSize(new java.awt.Dimension(139, 19));
                jButtonExportAllProfiles.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonExportAllProfilesActionPerformed(evt);
                    }
                });

                jCheckBoxProfilesInSeparateWindows.setSelected(true);
                jCheckBoxProfilesInSeparateWindows.setText("Profiles in Separate Windows");
                jCheckBoxProfilesInSeparateWindows.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jCheckBoxProfilesInSeparateWindowsActionPerformed(evt);
                    }
                });

                jButtonCopyProfiles.setText("Copy Selected Profile(s)");
                jButtonCopyProfiles.setMaximumSize(new java.awt.Dimension(107, 23));
                jButtonCopyProfiles.setMinimumSize(new java.awt.Dimension(107, 23));
                jButtonCopyProfiles.setPreferredSize(new java.awt.Dimension(149, 19));
                jButtonCopyProfiles.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonCopyProfilesActionPerformed(evt);
                    }
                });

                jButtonPasteProfiles.setText("Paste Profile(s)");
                jButtonPasteProfiles.setPreferredSize(new java.awt.Dimension(149, 19));
                jButtonPasteProfiles.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonPasteProfilesActionPerformed(evt);
                    }
                });

                jButtonDeleteAllProfiles.setText("Delete All Profile(s)");
                jButtonDeleteAllProfiles.setMaximumSize(new java.awt.Dimension(169, 23));
                jButtonDeleteAllProfiles.setPreferredSize(new java.awt.Dimension(155, 19));
                jButtonDeleteAllProfiles.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonDeleteAllProfilesActionPerformed(evt);
                    }
                });

                jCheckBoxThresholdProfile.setText("Threshold Profile");
                jCheckBoxThresholdProfile.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jCheckBoxThresholdProfileActionPerformed(evt);
                    }
                });

                jToggleButtonThresholdEdit.setText("Edit");
                jToggleButtonThresholdEdit.setPreferredSize(new java.awt.Dimension(51, 19));
                jToggleButtonThresholdEdit.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jToggleButtonThresholdEditActionPerformed(evt);
                    }
                });

                jScrollBarThresholdMin.setMaximum(4095);
                jScrollBarThresholdMin.setOrientation(javax.swing.JScrollBar.HORIZONTAL);
                jScrollBarThresholdMin.addAdjustmentListener(new java.awt.event.AdjustmentListener() {
                    public void adjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {
                        jScrollBarThresholdMinAdjustmentValueChanged(evt);
                    }
                });

                jLabelThresholdMin.setText("Min:");

                jLabelThresholdMinValue.setText("0");

                jScrollBarThresholdMax.setMaximum(4095);
                jScrollBarThresholdMax.setOrientation(javax.swing.JScrollBar.HORIZONTAL);
                jScrollBarThresholdMax.setValue(4095);
                jScrollBarThresholdMax.addAdjustmentListener(new java.awt.event.AdjustmentListener() {
                    public void adjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {
                        jScrollBarThresholdMaxAdjustmentValueChanged(evt);
                    }
                });

                jLabelThresholdMax.setText("Max:");

                jLabelThresholdMaxValue.setText("4095");

                jButtonThresholdMaxReset.setText("Reset");
                jButtonThresholdMaxReset.setPreferredSize(new java.awt.Dimension(75, 19));
                jButtonThresholdMaxReset.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonThresholdMaxResetActionPerformed(evt);
                    }
                });

                jButtonThresholdMinReset.setText("Reset");
                jButtonThresholdMinReset.setPreferredSize(new java.awt.Dimension(75, 19));
                jButtonThresholdMinReset.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonThresholdMinResetActionPerformed(evt);
                    }
                });

                jLabelProfileSelection2.setText("Profile Functions");

                listProfileFunctionList.setMultipleMode(true);
                listProfileFunctionList.addMouseListener(new java.awt.event.MouseAdapter() {
                    public void mouseReleased(java.awt.event.MouseEvent evt) {
                        listProfileFunctionListMouseReleased(evt);
                    }
                });

                javax.swing.GroupLayout jPanelIntensityProfilesGroup2Layout = new javax.swing.GroupLayout(jPanelIntensityProfilesGroup2);
                jPanelIntensityProfilesGroup2.setLayout(jPanelIntensityProfilesGroup2Layout);
                jPanelIntensityProfilesGroup2Layout.setHorizontalGroup(
                    jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesGroup2Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabelProfileSelection1, javax.swing.GroupLayout.PREFERRED_SIZE, 88, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(listProfileList, javax.swing.GroupLayout.PREFERRED_SIZE, 223, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(listProfileFunctionList, javax.swing.GroupLayout.PREFERRED_SIZE, 223, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabelProfileSelection2, javax.swing.GroupLayout.PREFERRED_SIZE, 129, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButtonCopyProfiles, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                            .addComponent(jButtonPasteProfiles, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                            .addComponent(jButtonDeleteProfile, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                            .addComponent(jButtonDeleteAllProfiles, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                            .addComponent(jCheckBoxProfilesInSeparateWindows, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                            .addComponent(jButtonExportSelectedProfiles, 0, 182, Short.MAX_VALUE)
                            .addComponent(jButtonExportAllProfiles, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                            .addGroup(jPanelIntensityProfilesGroup2Layout.createSequentialGroup()
                                .addComponent(jLabelThresholdMin)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabelThresholdMinValue, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 36, Short.MAX_VALUE)
                                .addComponent(jButtonThresholdMinReset, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanelIntensityProfilesGroup2Layout.createSequentialGroup()
                                .addComponent(jCheckBoxThresholdProfile)
                                .addGap(18, 18, 18)
                                .addComponent(jToggleButtonThresholdEdit, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE))
                            .addComponent(jScrollBarThresholdMin, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                            .addComponent(jScrollBarThresholdMax, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                            .addGroup(jPanelIntensityProfilesGroup2Layout.createSequentialGroup()
                                .addComponent(jLabelThresholdMax)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabelThresholdMaxValue, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 34, Short.MAX_VALUE)
                                .addComponent(jButtonThresholdMaxReset, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addContainerGap())
                );
                jPanelIntensityProfilesGroup2Layout.setVerticalGroup(
                    jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesGroup2Layout.createSequentialGroup()
                        .addGroup(jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabelProfileSelection1)
                            .addComponent(jCheckBoxProfilesInSeparateWindows))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanelIntensityProfilesGroup2Layout.createSequentialGroup()
                                .addGroup(jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jCheckBoxThresholdProfile)
                                    .addComponent(jToggleButtonThresholdEdit, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jScrollBarThresholdMin, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabelThresholdMin)
                                    .addComponent(jLabelThresholdMinValue)
                                    .addComponent(jButtonThresholdMinReset, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jScrollBarThresholdMax, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabelThresholdMax)
                                    .addComponent(jLabelThresholdMaxValue)
                                    .addComponent(jButtonThresholdMaxReset, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 8, Short.MAX_VALUE)
                                .addComponent(jButtonCopyProfiles, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(listProfileList, javax.swing.GroupLayout.DEFAULT_SIZE, 144, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButtonPasteProfiles, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabelProfileSelection2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelIntensityProfilesGroup2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addGroup(jPanelIntensityProfilesGroup2Layout.createSequentialGroup()
                                .addComponent(jButtonDeleteProfile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButtonDeleteAllProfiles, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButtonExportSelectedProfiles, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButtonExportAllProfiles, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(listProfileFunctionList, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                );

                jPanelIntensityProfilesGroup3.setPreferredSize(new java.awt.Dimension(137, 100));

                jLabelProfileWidth.setText("Profile Width");

                jSliderProfileWidth.setMajorTickSpacing(2);
                jSliderProfileWidth.setMaximum(50);
                jSliderProfileWidth.setMinorTickSpacing(1);
                jSliderProfileWidth.setPaintTicks(true);
                jSliderProfileWidth.setValue(0);
                jSliderProfileWidth.addMouseListener(new java.awt.event.MouseAdapter() {
                    public void mouseReleased(java.awt.event.MouseEvent evt) {
                        jSliderProfileWidthMouseReleased(evt);
                    }
                });
                jSliderProfileWidth.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
                    public void mouseDragged(java.awt.event.MouseEvent evt) {
                        jSliderProfileWidthMouseDragged(evt);
                    }
                });

                jLabelProfileWidthValue.setText("1");

                jLabelProfileColor1.setText("Profile Color");

                jButtonSelectProfileColor.setText("Select Color...");
                jButtonSelectProfileColor.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonSelectProfileColorActionPerformed(evt);
                    }
                });

                jPanelProfileColor.setBackground(new java.awt.Color(255, 0, 51));
                jPanelProfileColor.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
                jPanelProfileColor.setPreferredSize(new java.awt.Dimension(29, 23));

                javax.swing.GroupLayout jPanelProfileColorLayout = new javax.swing.GroupLayout(jPanelProfileColor);
                jPanelProfileColor.setLayout(jPanelProfileColorLayout);
                jPanelProfileColorLayout.setHorizontalGroup(
                    jPanelProfileColorLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGap(0, 33, Short.MAX_VALUE)
                );
                jPanelProfileColorLayout.setVerticalGroup(
                    jPanelProfileColorLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGap(0, 21, Short.MAX_VALUE)
                );

                jLabelIntensityMethod1.setText("If Profile Width >1 compute");

                jComboBoxIntensityMethod.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Average", "Total" }));
                jComboBoxIntensityMethod.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jComboBoxIntensityMethodActionPerformed(evt);
                    }
                });

                jLabelIntensityMethod2.setText("intensity.");

                jLabelFunctionColor.setText("Function Color");

                jButtonSelectFunctionColor.setText("Select Color...");
                jButtonSelectFunctionColor.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonSelectFunctionColorActionPerformed(evt);
                    }
                });

                jPanelFunctionColor.setBackground(new java.awt.Color(255, 0, 51));
                jPanelFunctionColor.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
                jPanelFunctionColor.setPreferredSize(new java.awt.Dimension(29, 23));

                javax.swing.GroupLayout jPanelFunctionColorLayout = new javax.swing.GroupLayout(jPanelFunctionColor);
                jPanelFunctionColor.setLayout(jPanelFunctionColorLayout);
                jPanelFunctionColorLayout.setHorizontalGroup(
                    jPanelFunctionColorLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGap(0, 33, Short.MAX_VALUE)
                );
                jPanelFunctionColorLayout.setVerticalGroup(
                    jPanelFunctionColorLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGap(0, 21, Short.MAX_VALUE)
                );

                javax.swing.GroupLayout jPanelIntensityProfilesGroup3Layout = new javax.swing.GroupLayout(jPanelIntensityProfilesGroup3);
                jPanelIntensityProfilesGroup3.setLayout(jPanelIntensityProfilesGroup3Layout);
                jPanelIntensityProfilesGroup3Layout.setHorizontalGroup(
                    jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                .addComponent(jLabelProfileWidth)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 26, Short.MAX_VALUE)
                                .addComponent(jLabelProfileWidthValue, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(81, 81, 81))
                            .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                .addComponent(jSliderProfileWidth, javax.swing.GroupLayout.PREFERRED_SIZE, 167, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap())
                            .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                .addGroup(jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                        .addGroup(jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jLabelIntensityMethod1)
                                            .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                                .addComponent(jComboBoxIntensityMethod, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jLabelIntensityMethod2)))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 35, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                            .addComponent(jButtonSelectProfileColor, javax.swing.GroupLayout.DEFAULT_SIZE, 127, Short.MAX_VALUE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jPanelProfileColor, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                            .addComponent(jLabelProfileColor1)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 110, javax.swing.GroupLayout.PREFERRED_SIZE))))
                                .addGap(26, 26, 26))
                            .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                .addComponent(jButtonSelectFunctionColor, javax.swing.GroupLayout.DEFAULT_SIZE, 127, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jPanelFunctionColor, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(26, 26, 26))
                            .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                .addComponent(jLabelFunctionColor, javax.swing.GroupLayout.PREFERRED_SIZE, 86, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap())))
                );
                jPanelIntensityProfilesGroup3Layout.setVerticalGroup(
                    jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                        .addGroup(jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabelProfileWidth)
                            .addComponent(jLabelProfileWidthValue))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSliderProfileWidth, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jLabelIntensityMethod1)
                        .addGap(1, 1, 1)
                        .addGroup(jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jComboBoxIntensityMethod, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabelIntensityMethod2))
                        .addGap(18, 18, 18)
                        .addGroup(jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanelIntensityProfilesGroup3Layout.createSequentialGroup()
                                .addComponent(jLabelProfileColor1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButtonSelectProfileColor))
                            .addComponent(jPanelProfileColor, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 99, Short.MAX_VALUE)
                        .addComponent(jLabelFunctionColor)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelIntensityProfilesGroup3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButtonSelectFunctionColor)
                            .addComponent(jPanelFunctionColor, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap())
                );

                javax.swing.GroupLayout jPanelIntensityProfilesAllLayout = new javax.swing.GroupLayout(jPanelIntensityProfilesAll);
                jPanelIntensityProfilesAll.setLayout(jPanelIntensityProfilesAllLayout);
                jPanelIntensityProfilesAllLayout.setHorizontalGroup(
                    jPanelIntensityProfilesAllLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesAllLayout.createSequentialGroup()
                        .addComponent(jPanelIntensityProfilesGroup1, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelIntensityProfilesGroup2, javax.swing.GroupLayout.DEFAULT_SIZE, 435, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jPanelIntensityProfilesGroup3, javax.swing.GroupLayout.PREFERRED_SIZE, 204, javax.swing.GroupLayout.PREFERRED_SIZE))
                );
                jPanelIntensityProfilesAllLayout.setVerticalGroup(
                    jPanelIntensityProfilesAllLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelIntensityProfilesAllLayout.createSequentialGroup()
                        .addGroup(jPanelIntensityProfilesAllLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jPanelIntensityProfilesGroup1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 321, Short.MAX_VALUE)
                            .addComponent(jPanelIntensityProfilesGroup3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 321, Short.MAX_VALUE)
                            .addComponent(jPanelIntensityProfilesGroup2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 321, Short.MAX_VALUE))
                        .addContainerGap())
                );

                jScrollBarProfilePosition.addAdjustmentListener(new java.awt.event.AdjustmentListener() {
                    public void adjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {
                        jScrollBarProfilePositionAdjustmentValueChanged(evt);
                    }
                });

                jLabelProfilePosition1.setText("Profile");

                jLabelProfilePosition2.setText("Position");

                javax.swing.GroupLayout jPanelIntensityProfilesGroup4Layout = new javax.swing.GroupLayout(jPanelIntensityProfilesGroup4);
                jPanelIntensityProfilesGroup4.setLayout(jPanelIntensityProfilesGroup4Layout);
                jPanelIntensityProfilesGroup4Layout.setHorizontalGroup(
                    jPanelIntensityProfilesGroup4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesGroup4Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollBarProfilePosition, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelIntensityProfilesGroup4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabelProfilePosition1)
                            .addComponent(jLabelProfilePosition2))
                        .addContainerGap(25, Short.MAX_VALUE))
                );
                jPanelIntensityProfilesGroup4Layout.setVerticalGroup(
                    jPanelIntensityProfilesGroup4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesGroup4Layout.createSequentialGroup()
                        .addGroup(jPanelIntensityProfilesGroup4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollBarProfilePosition, javax.swing.GroupLayout.DEFAULT_SIZE, 321, Short.MAX_VALUE)
                            .addGroup(jPanelIntensityProfilesGroup4Layout.createSequentialGroup()
                                .addGap(142, 142, 142)
                                .addComponent(jLabelProfilePosition1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabelProfilePosition2)))
                        .addContainerGap())
                );

                javax.swing.GroupLayout jPanelIntensityProfilesTabLayout = new javax.swing.GroupLayout(jPanelIntensityProfilesTab);
                jPanelIntensityProfilesTab.setLayout(jPanelIntensityProfilesTabLayout);
                jPanelIntensityProfilesTabLayout.setHorizontalGroup(
                    jPanelIntensityProfilesTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelIntensityProfilesTabLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jPanelIntensityProfilesAll, javax.swing.GroupLayout.PREFERRED_SIZE, 803, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jPanelIntensityProfilesGroup4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(19, 19, 19))
                );
                jPanelIntensityProfilesTabLayout.setVerticalGroup(
                    jPanelIntensityProfilesTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelIntensityProfilesTabLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanelIntensityProfilesTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jPanelIntensityProfilesGroup4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanelIntensityProfilesAll, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 332, Short.MAX_VALUE))
                        .addContainerGap())
                );

                jTabbedPaneControls.addTab("Intenisty Profiles", jPanelIntensityProfilesTab);

                jToggleButtonAI0.setText("AI 0");
                jToggleButtonAI0.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jToggleButtonAI0ActionPerformed(evt);
                    }
                });

                jLabelAI0Name.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI0Name.setText("name");

                jLabelAI0Units.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI0Units.setText("units");

                jButtonAI0Color.setText("Color");

                javax.swing.GroupLayout jPanelAI0Layout = new javax.swing.GroupLayout(jPanelAI0);
                jPanelAI0.setLayout(jPanelAI0Layout);
                jPanelAI0Layout.setHorizontalGroup(
                    jPanelAI0Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI0Layout.createSequentialGroup()
                        .addGroup(jPanelAI0Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jToggleButtonAI0, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI0Name, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jButtonAI0Color, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabelAI0Units, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE))
                        .addContainerGap())
                );
                jPanelAI0Layout.setVerticalGroup(
                    jPanelAI0Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI0Layout.createSequentialGroup()
                        .addComponent(jToggleButtonAI0)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI0Name)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI0Units)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonAI0Color)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                );

                jToggleButtonAI1.setText("AI 1");
                jToggleButtonAI1.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jToggleButtonAI1ActionPerformed(evt);
                    }
                });

                jLabelAI1Name.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI1Name.setText("name");

                jLabelAI1Units.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI1Units.setText("units");

                jButtonAI1Color.setText("Color");

                javax.swing.GroupLayout jPanelAI1Layout = new javax.swing.GroupLayout(jPanelAI1);
                jPanelAI1.setLayout(jPanelAI1Layout);
                jPanelAI1Layout.setHorizontalGroup(
                    jPanelAI1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI1Layout.createSequentialGroup()
                        .addGroup(jPanelAI1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jToggleButtonAI1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI1Name, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI1Units, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jButtonAI1Color, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                );
                jPanelAI1Layout.setVerticalGroup(
                    jPanelAI1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI1Layout.createSequentialGroup()
                        .addComponent(jToggleButtonAI1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI1Name)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI1Units)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonAI1Color)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                );

                jToggleButtonAI2.setText("AI 2");
                jToggleButtonAI2.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jToggleButtonAI2ActionPerformed(evt);
                    }
                });

                jLabelAI2Name.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI2Name.setText("name");

                jLabelAI2Units.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI2Units.setText("units");

                jButtonAI2Color.setText("Color");

                javax.swing.GroupLayout jPanelAI2Layout = new javax.swing.GroupLayout(jPanelAI2);
                jPanelAI2.setLayout(jPanelAI2Layout);
                jPanelAI2Layout.setHorizontalGroup(
                    jPanelAI2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI2Layout.createSequentialGroup()
                        .addGroup(jPanelAI2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jToggleButtonAI2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI2Name, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI2Units, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jButtonAI2Color, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                );
                jPanelAI2Layout.setVerticalGroup(
                    jPanelAI2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI2Layout.createSequentialGroup()
                        .addComponent(jToggleButtonAI2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI2Name)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI2Units)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonAI2Color)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                );

                jToggleButtonAI3.setText("AI 3");
                jToggleButtonAI3.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jToggleButtonAI3ActionPerformed(evt);
                    }
                });

                jLabelAI3Name.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI3Name.setText("name");

                jLabelAI3Units.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI3Units.setText("units");

                jButtonAI3Color.setText("Color");

                javax.swing.GroupLayout jPanelAI3Layout = new javax.swing.GroupLayout(jPanelAI3);
                jPanelAI3.setLayout(jPanelAI3Layout);
                jPanelAI3Layout.setHorizontalGroup(
                    jPanelAI3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI3Layout.createSequentialGroup()
                        .addGroup(jPanelAI3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jToggleButtonAI3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI3Name, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI3Units, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jButtonAI3Color, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                );
                jPanelAI3Layout.setVerticalGroup(
                    jPanelAI3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI3Layout.createSequentialGroup()
                        .addComponent(jToggleButtonAI3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI3Name)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI3Units)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonAI3Color)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                );

                jToggleButtonAI4.setText("AI 4");
                jToggleButtonAI4.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jToggleButtonAI4ActionPerformed(evt);
                    }
                });

                jLabelAI4Name.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI4Name.setText("name");

                jLabelAI4Units.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI4Units.setText("units");

                jButtonAI4Color.setText("Color");

                javax.swing.GroupLayout jPanelAI4Layout = new javax.swing.GroupLayout(jPanelAI4);
                jPanelAI4.setLayout(jPanelAI4Layout);
                jPanelAI4Layout.setHorizontalGroup(
                    jPanelAI4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI4Layout.createSequentialGroup()
                        .addGroup(jPanelAI4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jToggleButtonAI4, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI4Name, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI4Units, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jButtonAI4Color, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                );
                jPanelAI4Layout.setVerticalGroup(
                    jPanelAI4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI4Layout.createSequentialGroup()
                        .addComponent(jToggleButtonAI4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI4Name)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI4Units)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonAI4Color)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                );

                jToggleButtonAI5.setText("AI 5");
                jToggleButtonAI5.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jToggleButtonAI5ActionPerformed(evt);
                    }
                });

                jLabelAI5Name.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI5Name.setText("name");

                jLabelAI5Units.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI5Units.setText("units");

                jButtonAI5Color.setText("Color");

                javax.swing.GroupLayout jPanelAI5Layout = new javax.swing.GroupLayout(jPanelAI5);
                jPanelAI5.setLayout(jPanelAI5Layout);
                jPanelAI5Layout.setHorizontalGroup(
                    jPanelAI5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI5Layout.createSequentialGroup()
                        .addGroup(jPanelAI5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jToggleButtonAI5, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI5Name, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI5Units, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jButtonAI5Color, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                );
                jPanelAI5Layout.setVerticalGroup(
                    jPanelAI5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI5Layout.createSequentialGroup()
                        .addComponent(jToggleButtonAI5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI5Name)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI5Units)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonAI5Color)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                );

                jToggleButtonAI6.setText("AI 6");
                jToggleButtonAI6.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jToggleButtonAI6ActionPerformed(evt);
                    }
                });

                jLabelAI6Name.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI6Name.setText("name");

                jLabelAI6Units.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI6Units.setText("units");

                jButtonAI6Color.setText("Color");

                javax.swing.GroupLayout jPanelAI6Layout = new javax.swing.GroupLayout(jPanelAI6);
                jPanelAI6.setLayout(jPanelAI6Layout);
                jPanelAI6Layout.setHorizontalGroup(
                    jPanelAI6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI6Layout.createSequentialGroup()
                        .addGroup(jPanelAI6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jToggleButtonAI6, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI6Name, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI6Units, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jButtonAI6Color, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                );
                jPanelAI6Layout.setVerticalGroup(
                    jPanelAI6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI6Layout.createSequentialGroup()
                        .addComponent(jToggleButtonAI6)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI6Name)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI6Units)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonAI6Color)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                );

                jToggleButtonAI7.setText("AI 7");
                jToggleButtonAI7.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jToggleButtonAI7ActionPerformed(evt);
                    }
                });

                jLabelAI7Name.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI7Name.setText("name");

                jLabelAI7Units.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
                jLabelAI7Units.setText("units");

                jButtonAI7Color.setText("Color");

                javax.swing.GroupLayout jPanelAI7Layout = new javax.swing.GroupLayout(jPanelAI7);
                jPanelAI7.setLayout(jPanelAI7Layout);
                jPanelAI7Layout.setHorizontalGroup(
                    jPanelAI7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI7Layout.createSequentialGroup()
                        .addGroup(jPanelAI7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jToggleButtonAI7, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI7Name, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jLabelAI7Units, javax.swing.GroupLayout.DEFAULT_SIZE, 59, Short.MAX_VALUE)
                            .addComponent(jButtonAI7Color, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                );
                jPanelAI7Layout.setVerticalGroup(
                    jPanelAI7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAI7Layout.createSequentialGroup()
                        .addComponent(jToggleButtonAI7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI7Name)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabelAI7Units)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonAI7Color)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                );

                jCheckBoxApplyTriggerSyncScaling.setSelected(true);
                jCheckBoxApplyTriggerSyncScaling.setText("Apply TriggerSync Scaling?");
                jCheckBoxApplyTriggerSyncScaling.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jCheckBoxApplyTriggerSyncScalingActionPerformed(evt);
                    }
                });

                jButtonAnalogDataCreateFunction.setText("Create Function...");
                jButtonAnalogDataCreateFunction.setMaximumSize(new java.awt.Dimension(97, 23));
                jButtonAnalogDataCreateFunction.setMinimumSize(new java.awt.Dimension(97, 23));
                jButtonAnalogDataCreateFunction.setPreferredSize(new java.awt.Dimension(97, 19));
                jButtonAnalogDataCreateFunction.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonAnalogDataCreateFunctionActionPerformed(evt);
                    }
                });

                jButtonAnalogDataEditFunction.setText("Edit Function...");
                jButtonAnalogDataEditFunction.setPreferredSize(new java.awt.Dimension(149, 19));
                jButtonAnalogDataEditFunction.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonAnalogDataEditFunctionActionPerformed(evt);
                    }
                });

                jButtonAnalogDataRemoveFunction.setText("Remove Function(s)");
                jButtonAnalogDataRemoveFunction.setPreferredSize(new java.awt.Dimension(149, 19));
                jButtonAnalogDataRemoveFunction.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonAnalogDataRemoveFunctionActionPerformed(evt);
                    }
                });

                jButtonAnalogDataClearFunctions.setText("Clear All Functions");
                jButtonAnalogDataClearFunctions.setPreferredSize(new java.awt.Dimension(149, 19));
                jButtonAnalogDataClearFunctions.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonAnalogDataClearFunctionsActionPerformed(evt);
                    }
                });

                jLabelAnalogDataSelection.setText("Analog Data Functions");

                listAnalogDataFunctionList.setMultipleMode(true);
                listAnalogDataFunctionList.addMouseListener(new java.awt.event.MouseAdapter() {
                    public void mouseReleased(java.awt.event.MouseEvent evt) {
                        listAnalogDataFunctionListMouseReleased(evt);
                    }
                });
                listAnalogDataFunctionList.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        listAnalogDataFunctionListActionPerformed(evt);
                    }
                });

                jLabelAnalogDataFunctionColor.setText("Function Color");

                jButtonAnalogDataSelectFunctionColor.setText("Select Color...");
                jButtonAnalogDataSelectFunctionColor.addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent evt) {
                        jButtonAnalogDataSelectFunctionColorActionPerformed(evt);
                    }
                });

                jPanelAnalogDataFunctionColor.setBackground(new java.awt.Color(255, 0, 51));
                jPanelAnalogDataFunctionColor.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
                jPanelAnalogDataFunctionColor.setPreferredSize(new java.awt.Dimension(29, 23));

                javax.swing.GroupLayout jPanelAnalogDataFunctionColorLayout = new javax.swing.GroupLayout(jPanelAnalogDataFunctionColor);
                jPanelAnalogDataFunctionColor.setLayout(jPanelAnalogDataFunctionColorLayout);
                jPanelAnalogDataFunctionColorLayout.setHorizontalGroup(
                    jPanelAnalogDataFunctionColorLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGap(0, 33, Short.MAX_VALUE)
                );
                jPanelAnalogDataFunctionColorLayout.setVerticalGroup(
                    jPanelAnalogDataFunctionColorLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGap(0, 21, Short.MAX_VALUE)
                );

                javax.swing.GroupLayout jPanelAIFunctionsLayout = new javax.swing.GroupLayout(jPanelAIFunctions);
                jPanelAIFunctions.setLayout(jPanelAIFunctionsLayout);
                jPanelAIFunctionsLayout.setHorizontalGroup(
                    jPanelAIFunctionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAIFunctionsLayout.createSequentialGroup()
                        .addGroup(jPanelAIFunctionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jButtonAnalogDataCreateFunction, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                            .addComponent(jButtonAnalogDataEditFunction, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                            .addComponent(jButtonAnalogDataClearFunctions, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                            .addComponent(jButtonAnalogDataRemoveFunction, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelAIFunctionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanelAIFunctionsLayout.createSequentialGroup()
                                .addComponent(listAnalogDataFunctionList, javax.swing.GroupLayout.PREFERRED_SIZE, 223, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(10, 10, 10)
                                .addGroup(jPanelAIFunctionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(jPanelAIFunctionsLayout.createSequentialGroup()
                                        .addComponent(jButtonAnalogDataSelectFunctionColor, javax.swing.GroupLayout.DEFAULT_SIZE, 127, Short.MAX_VALUE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jPanelAnalogDataFunctionColor, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(jPanelAIFunctionsLayout.createSequentialGroup()
                                        .addComponent(jLabelAnalogDataFunctionColor, javax.swing.GroupLayout.PREFERRED_SIZE, 86, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 82, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(45, 45, 45))
                            .addGroup(jPanelAIFunctionsLayout.createSequentialGroup()
                                .addComponent(jLabelAnalogDataSelection, javax.swing.GroupLayout.PREFERRED_SIZE, 129, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap(317, Short.MAX_VALUE))))
                );
                jPanelAIFunctionsLayout.setVerticalGroup(
                    jPanelAIFunctionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelAIFunctionsLayout.createSequentialGroup()
                        .addGroup(jPanelAIFunctionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanelAIFunctionsLayout.createSequentialGroup()
                                .addContainerGap()
                                .addComponent(jLabelAnalogDataFunctionColor)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanelAIFunctionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jButtonAnalogDataSelectFunctionColor)
                                    .addComponent(jPanelAnalogDataFunctionColor, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(jPanelAIFunctionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addGroup(jPanelAIFunctionsLayout.createSequentialGroup()
                                    .addContainerGap()
                                    .addComponent(jLabelAnalogDataSelection)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(listAnalogDataFunctionList, javax.swing.GroupLayout.DEFAULT_SIZE, 114, Short.MAX_VALUE))
                                .addGroup(jPanelAIFunctionsLayout.createSequentialGroup()
                                    .addGap(55, 55, 55)
                                    .addComponent(jButtonAnalogDataCreateFunction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButtonAnalogDataEditFunction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButtonAnalogDataRemoveFunction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jButtonAnalogDataClearFunctions, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addContainerGap())
                );

                javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
                jPanel6.setLayout(jPanel6Layout);
                jPanel6Layout.setHorizontalGroup(
                    jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel6Layout.createSequentialGroup()
                                .addComponent(jPanelAI0, javax.swing.GroupLayout.PREFERRED_SIZE, 65, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jPanelAI1, javax.swing.GroupLayout.PREFERRED_SIZE, 65, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jPanelAI2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jPanelAI3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jPanelAI4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jPanelAI5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jPanelAI6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jPanelAI7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jCheckBoxApplyTriggerSyncScaling)
                            .addComponent(jPanelAIFunctions, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                );
                jPanel6Layout.setVerticalGroup(
                    jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(jPanelAI7, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanelAI6, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanelAI5, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanelAI4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanelAI3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanelAI0, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanelAI1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanelAI2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelAIFunctions, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(18, 18, 18)
                        .addComponent(jCheckBoxApplyTriggerSyncScaling)
                        .addContainerGap())
                );

                javax.swing.GroupLayout jPanelAnalogDataTabLayout = new javax.swing.GroupLayout(jPanelAnalogDataTab);
                jPanelAnalogDataTab.setLayout(jPanelAnalogDataTabLayout);
                jPanelAnalogDataTabLayout.setHorizontalGroup(
                    jPanelAnalogDataTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAnalogDataTabLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(320, Short.MAX_VALUE))
                );
                jPanelAnalogDataTabLayout.setVerticalGroup(
                    jPanelAnalogDataTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAnalogDataTabLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jPanel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addContainerGap())
                );

                jTabbedPaneControls.addTab("Analog Data", jPanelAnalogDataTab);

                javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
                getContentPane().setLayout(layout);
                layout.setHorizontalGroup(
                    layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(19, 19, 19)
                        .addComponent(jTabbedPaneControls, javax.swing.GroupLayout.PREFERRED_SIZE, 939, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(45, Short.MAX_VALUE))
                );
                layout.setVerticalGroup(
                    layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jTabbedPaneControls, javax.swing.GroupLayout.PREFERRED_SIZE, 379, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(28, Short.MAX_VALUE))
                );

                pack();

                //*************************
                // End of GUI code
                //*************************
                
                // Prepare the vector that keeps the information about the profiles for this sequence.
                lsProfiles = new Vector<ProfileSettings>();
                lsProfiles.clear();
                
                // Prepare the vector that keeps the information for the analog data for this sequence.
                lsAnalogData = new Vector<AnalogDataSettings>();
                
                // Prepare teh vector that keeps track of the funtion declarations
                lsFunctions = new Vector<LSFunctionSettings>();
                
                // Prepare teh vector that keeps track of the funtion declarations for analog data
                lsAnalogDataFunctions = new Vector<LSAnalogDataFunctionSettings>();
                
                jCheckBoxThresholdProfile.setEnabled(false);
                jToggleButtonThresholdEdit.setEnabled(false);
                jScrollBarThresholdMin.setEnabled(false);
                jLabelThresholdMin.setEnabled(false);
                jLabelThresholdMinValue.setEnabled(false);
                jButtonThresholdMinReset.setEnabled(false);
                jScrollBarThresholdMax.setEnabled(false);
                jLabelThresholdMax.setEnabled(false);
                jLabelThresholdMaxValue.setEnabled(false);
                jButtonThresholdMaxReset.setEnabled(false);
                
                jCheckBoxApplyTriggerSyncScaling.setEnabled(false);
                
                jToggleButtonAI0.setSelected(false);
                jToggleButtonAI0.setEnabled(false);
                jLabelAI0Name.setEnabled(false);
                jLabelAI0Units.setEnabled(false);
                jButtonAI0Color.setEnabled(false);
            
                jToggleButtonAI1.setSelected(false);
                jToggleButtonAI1.setEnabled(false);
                jLabelAI1Name.setEnabled(false);
                jLabelAI1Units.setEnabled(false);
                jButtonAI1Color.setEnabled(false);
                
                jToggleButtonAI2.setSelected(false);
                jToggleButtonAI2.setEnabled(false);
                jLabelAI2Name.setEnabled(false);
                jLabelAI2Units.setEnabled(false);
                jButtonAI2Color.setEnabled(false);
            
                jToggleButtonAI3.setSelected(false);
                jToggleButtonAI3.setEnabled(false);
                jLabelAI3Name.setEnabled(false);
                jLabelAI3Units.setEnabled(false);
                jButtonAI3Color.setEnabled(false);
                
                jToggleButtonAI4.setSelected(false);
                jToggleButtonAI4.setEnabled(false);
                jLabelAI4Name.setEnabled(false);
                jLabelAI4Units.setEnabled(false);
                jButtonAI4Color.setEnabled(false);
            
                jToggleButtonAI5.setSelected(false);
                jToggleButtonAI5.setEnabled(false);
                jLabelAI5Name.setEnabled(false);
                jLabelAI5Units.setEnabled(false);
                jButtonAI5Color.setEnabled(false);
                
                jToggleButtonAI6.setSelected(false);
                jToggleButtonAI6.setEnabled(false);
                jLabelAI6Name.setEnabled(false);
                jLabelAI6Units.setEnabled(false);
                jButtonAI6Color.setEnabled(false);
            
                jToggleButtonAI7.setSelected(false);
                jToggleButtonAI7.setEnabled(false);
                jLabelAI7Name.setEnabled(false);
                jLabelAI7Units.setEnabled(false);
                jButtonAI7Color.setEnabled(false);
                
                jButtonAnalogDataCreateFunction.setEnabled(false);
                jButtonAnalogDataEditFunction.setEnabled(false);
                jButtonAnalogDataRemoveFunction.setEnabled(false);
                jButtonAnalogDataClearFunctions.setEnabled(false);
                jLabelAnalogDataSelection.setEnabled(false);
                listAnalogDataFunctionList.setEnabled(false);
                jLabelAnalogDataFunctionColor.setEnabled(false);
                jButtonAnalogDataSelectFunctionColor.setEnabled(false);
                jPanelAnalogDataFunctionColor.setEnabled(false);
                
            }                
                
            // These are the directory and filename associated with this "sequence".
            // These are used for the automatic writing/reading of a file with the profile data.
            private String lsDirectory;
            private String lsFileName;
            private String lsDataFile;
            private String lsSettingsFile;
            
            // These are the Plot windows associated with each of the possible linescan windows.
            // These are shown when the operator chooses the "Save" button
            private Plot lsPlotWindow = null;
            private Plot lsPlotSingleChannelWindow1 = null;
            private Plot lsPlotSingleChannelWindow2 = null;
            private Plot lsPlotSingleChannelWindow3 = null;
            private Plot lsPlotSingleChannelWindow4 = null;
            
            // These are the ImagePlus image windows needed for the "dynamic" plot updates.
            private ImagePlus lsImagePlusPlotWindow = null;
            private ImagePlus lsImagePlusPlotSingleChannelWindow1 = null;
            private ImagePlus lsImagePlusPlotSingleChannelWindow2 = null;
            private ImagePlus lsImagePlusPlotSingleChannelWindow3 = null;
            private ImagePlus lsImagePlusPlotSingleChannelWindow4 = null;
    
            // These are the strings for the various channel names
            private int lsNumChans;
            private String lsCh1Label;
            private String lsCh2Label;
            private String lsCh3Label;
            private String lsCh4Label;
            
            // These windows display the linescan data
            private ImageWindow lsWindow = null;
            private ImageWindow lsSingleChannelWindow1 = null;
            private ImageWindow lsSingleChannelWindow2 = null;
            private ImageWindow lsSingleChannelWindow3 = null;
            private ImageWindow lsSingleChannelWindow4 = null;
            
            // These windows display the linescan reference images
            private ImageWindow lsWindowCompRef = null;
            private ImageWindow lsSingleChannelWindow1Ref = null;
            private ImageWindow lsSingleChannelWindow2Ref = null;
            private ImageWindow lsSingleChannelWindow3Ref = null;
            private ImageWindow lsSingleChannelWindow4Ref = null;
            
            // These are other pertinent values
            private double lsDwellTime;
            private double lsScanlinePeriod;
            private int lsNumLines;
            private int lsPixelsPerLine;
            private int lsSequenceNumber;
            
            private int lsType = 0; // 0 = line, 1 = freehand, 2 = spiral, 3 = lissajous
            private double lsStartPixelX;
            private double lsStopPixelX;
            private double lsPixelY;
            private double lsLength;
            private Vector<Double> lsFreehandPixelX;
            private Vector<Double> lsFreehandPixelY;
            
            private boolean lsProfilesInSeparateWindows = true;
            
            double lsXMin = 0.0;
            double lsXMax = 1.0;
            double lsYMin = 0.0;
            double lsYMax = 0.0;
            double lsYMin1 = 0.0;
            double lsYMax1 = 0.0;
            double lsYMin2 = 0.0;
            double lsYMax2 = 0.0;
            double lsYMin3 = 0.0;
            double lsYMax3 = 0.0;
            double lsYMin4 = 0.0;
            double lsYMax4 = 0.0;
                
            class ProfileSettings {
                int channel;
                Color color;
                int width;
                int position;
                double[] time = new double[lsNumLines];
                double[] intensity = new double[lsNumLines];
                int[] intensitySampleCount = new int[lsNumLines];
                Plot plotWindow = null;
                ImagePlus imagePlusPlotWindow = null;
                boolean threshold = false;
                double thresholdMin = 0.0;
                double thresholdMax = 4095.0;
                Boolean prairieViewProfile = false;
                int prairieViewIndex = 0;
            }
            
            Vector<ProfileSettings> lsProfiles;
                    
            public class LSFunctionSettings {
                String functionName = "";
                String functionExpression = "";
                Color color = Color.RED;
                double[] time = new double[lsNumLines];
                double[] intensity = new double[lsNumLines];
                double intensityMin = 1000000000.0;
                double intensityMax = -1000000000.0;
                Plot plotWindow = null;
                ImagePlus imagePlusPlotWindow = null;
                FunctionProcessing functionProcessing = new FunctionProcessing();
            }
        
            Vector<LSFunctionSettings> lsFunctions;
        
            public class LSAnalogDataFunctionSettings {
                String functionName = "";
                String functionExpression = "";
                Color color = Color.RED;
                double[] time = new double[(lsAnalogDataSamplingRate / 1000) * lsAnalogDataAcqTime];
                double[] intensity = new double[(lsAnalogDataSamplingRate / 1000) * lsAnalogDataAcqTime];
                double intensityMin = 1000000000.0;
                double intensityMax = -1000000000.0;
                Plot plotWindow = null;
                ImagePlus imagePlusPlotWindow = null;
                FunctionProcessing functionProcessing = new FunctionProcessing();
            }
        
            Vector<LSAnalogDataFunctionSettings> lsAnalogDataFunctions;
            
            public class LSProfileProcessing {
                int profile = 0;
                boolean display = false;
            }
            
            private boolean lsAnalogDataPresent = false;
            private int lsAnalogDataSamplingRate = 1;
            private int lsAnalogDataAcqTime = 1;
            private int lsAnalogDataNumberChannels = 0;
            private boolean lsAnalogDataFromTriggerSync = false;
            
            class AnalogDataSettings {
                int channel = 0;
                boolean status = false;
                String name = "N/A";
                String units = "N/A";
                Color color = Color.RED;
                double TriggerSyncScaleFactor = 1000.0;
                Vector<Double> time;
                Vector<Double> data;
                double dataMin = 100000000.0;
                double dataMax = -100000000.0;
                double dataMinScaled = 100000000.0;
                double dataMaxScaled = -100000000.0;
                Plot plotWindow = null;
                ImagePlus imagePlusPlotWindow = null;
                String type = "N/A";
                double multiplier = 1.0;
                double divisor = 1.0;
            }
            
            Vector<AnalogDataSettings> lsAnalogData;
            
            
            public void SetDirectoryAndFileName (String dir, String fileName) {
                lsDirectory = dir;
                lsFileName = fileName;
            }
            
            public void SetVoltageRecordingDataFiles(String dataFile, String settingsFile) {
                lsDataFile = dataFile;
                lsSettingsFile = settingsFile;
                
                File dataF = new File(lsDirectory + lsDataFile);
                File settingsF = new File(lsDirectory + lsSettingsFile);
                
                // Check to see if both files exist.
                if (dataF.exists() && settingsF.exists()) {
                    lsAnalogDataPresent = true;
                    lsAnalogDataFromTriggerSync = false;
                    
                    // If both files exist, first read the "settings" file to determine
                    // how many channels of analog data were collected, what particular channels
                    // were acquired, the color of each channel of data, and so on.
                    try {
                        lsAnalogDataNumberChannels = 0;
                        
                        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
                        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
                        Document doc = docBuilder.parse(new File(lsDirectory + lsSettingsFile));

                        if (doc.getDocumentElement().getNodeName().equals("VRecSessionEntry")) {
                            Node VRecSessionEntry = doc.getElementsByTagName("VRecSessionEntry").item(0);
                            
                            NodeList VRecSessionEntryNodes = VRecSessionEntry.getChildNodes();
                            for(int i = 0; i < VRecSessionEntryNodes.getLength(); i++) {
                                Node level1 = VRecSessionEntryNodes.item(i);
                                //IJ.showMessage("node = " + sequence.getNodeName());
                                if (level1.getNodeName().equals("Experiment")) {
                                    NodeList ExperimentNodes = level1.getChildNodes();
                                    for(int j = 0; j < ExperimentNodes.getLength(); j++) {
                                        Node level2 = ExperimentNodes.item(j);
                                        //IJ.showMessage("node = " + ExperimentNodes.item(j));
                                        if (level2.getNodeName().equals("SignalList")) {
                                            //IJ.showMessage("signalList");
                                            // Read the laser names
                                            NodeList SignalListNodes =  level2.getChildNodes();
                                            for(int m = 0; m < SignalListNodes.getLength(); m++) {
                                                Node level3 = SignalListNodes.item(m);
                                                if (level3.getNodeName().equals("VRecSignal")) {
                                                    String signalType = "";
                                                    AnalogDataSettings analogSettings = new AnalogDataSettings();
                                                    analogSettings.time = new Vector<Double>();
                                                    analogSettings.data = new Vector<Double>();
                                                    NodeList VRecSignalNodes = level3.getChildNodes();
                                                    for (int n = 0; n < VRecSignalNodes.getLength(); n++) {
                                                        //IJ.showMessage("item = " + VRecSignalNodes.item(n));
                                                        String itemName = VRecSignalNodes.item(n).getNodeName();
                                                        if (itemName.equals("Type")) {
                                                            signalType = VRecSignalNodes.item(n).getFirstChild().getNodeValue();
                                                            analogSettings.type = signalType;
                                                        }
                                                        if (itemName.equals("Enabled")) {
                                                            analogSettings.status = Boolean.parseBoolean(VRecSignalNodes.item(n).getFirstChild().getNodeValue());
                                                        }
                                                        if (itemName.equals("Name")) {
                                                            analogSettings.name = VRecSignalNodes.item(n).getFirstChild().getNodeValue();
                                                            if (analogSettings.name == null)
                                                                analogSettings.name = "N/A";
                                                        }
                                                        if (itemName.equals("ColorAsARGB")) {
                                                            analogSettings.color = Color.decode(VRecSignalNodes.item(n).getFirstChild().getNodeValue());
                                                            if (analogSettings.color == null)
                                                                analogSettings.color = Color.RED;
                                                        }
                                                        if (itemName.equals("Channel")) {
                                                            analogSettings.channel = Integer.parseInt(VRecSignalNodes.item(n).getFirstChild().getNodeValue());
                                                        }
                                                        if (VRecSignalNodes.item(n).getNodeName().equals("Unit")) {
                                                            NodeList UnitNodes = VRecSignalNodes.item(n).getChildNodes();
                                                            for (int p = 0; p < UnitNodes.getLength(); p++) {
                                                                String unitKey = UnitNodes.item(p).getNodeName();
                                                                if (unitKey.equals("UnitName")) {
                                                                    analogSettings.units = UnitNodes.item(p).getFirstChild().getNodeValue();
                                                                    if (analogSettings.units == null)
                                                                        analogSettings.units = "N/A";
                                                                }
                                                                if (unitKey.equals("Multiplier")) {
                                                                    analogSettings.multiplier = Double.parseDouble(UnitNodes.item(p).getFirstChild().getNodeValue());
                                                                }
                                                                if (unitKey.equals("Divisor")) {
                                                                    analogSettings.divisor = Double.parseDouble(UnitNodes.item(p).getFirstChild().getNodeValue());
                                                                }
                                                            }
                                                        }
                                                    }
                                                    // Only add this to the list if it is of the correct "type"
                                                    if (signalType.equals("Physical")) {
                                                        lsAnalogData.add(analogSettings);
                                                        if (analogSettings.status)
                                                            lsAnalogDataNumberChannels++;
                                                    }
//                                                    String laserName = laser.getAttributes().getNamedItem("name").getNodeValue();
//                                                    String index = laser.getAttributes().getNamedItem("index").getNodeValue();
//                                                    data.LaserNames[Integer.parseInt(index)] = laserName;
                                                }
                                            }
                                        }
                                        else if (level2.getNodeName().equals("Rate")) {
                                            lsAnalogDataSamplingRate = Integer.parseInt(ExperimentNodes.item(j).getFirstChild().getNodeValue());
                                        }
                                        else if (level2.getNodeName().equals("AcquisitionTime")) {
                                            lsAnalogDataAcqTime = Integer.parseInt(ExperimentNodes.item(j).getFirstChild().getNodeValue());
                                        }
                                    }
                                }
                                else if (level1.getNodeName().equals("LostData")) {
                                    
                                }
                            }
                        }
                    } catch (Throwable t) {
                        try {
                                FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                                PrintStream logStream = new PrintStream(logFile);
                                t.printStackTrace(logStream);
                                logStream.flush();
                                logStream.close();
                                logFile.flush();
                                logFile.close();
                                IJ.showMessage("Prairie Reader", "Error Parsing: " + lsDirectory + lsDataFile + "\n" + "Error: " + "\n" + t.toString());
                        } catch (IOException exception) {}
                    }

                    if (lsAnalogDataNumberChannels > 0) {
                        jButtonAnalogDataCreateFunction.setEnabled(true);
                        jButtonAnalogDataEditFunction.setEnabled(true);
                        jButtonAnalogDataRemoveFunction.setEnabled(true);
                        jButtonAnalogDataClearFunctions.setEnabled(true);
                        jLabelAnalogDataSelection.setEnabled(true);
                        listAnalogDataFunctionList.setEnabled(true);
                        jLabelAnalogDataFunctionColor.setEnabled(true);
                        jButtonAnalogDataSelectFunctionColor.setEnabled(true);
                        jPanelAnalogDataFunctionColor.setEnabled(true);
                    }
                    
                    // All of the analog data settings and data have been read.
                    // Set up the controls on the "Analog Data" tab.
                    jCheckBoxApplyTriggerSyncScaling.setSelected(false);
                    jCheckBoxApplyTriggerSyncScaling.setEnabled(false);
                    for (int aiIndex = 0; aiIndex < lsAnalogData.size(); aiIndex++) {
                        if (lsAnalogData.elementAt(aiIndex).type.equals("Physical")) {
                            switch (lsAnalogData.elementAt(aiIndex).channel) {
                                case 0:
                                    jLabelAI0Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                    jLabelAI0Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                    jButtonAI0Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                    if (lsAnalogData.elementAt(aiIndex).status) {
                                        jToggleButtonAI0.setSelected(true);
                                        jToggleButtonAI0.setEnabled(true);
                                        jLabelAI0Name.setEnabled(true);
                                        jLabelAI0Units.setEnabled(true);
                                        jButtonAI0Color.setEnabled(true);
                                    }
                                    break;
                                case 1:
                                    jLabelAI1Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                    jLabelAI1Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                    jButtonAI1Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                    if (lsAnalogData.elementAt(aiIndex).status) {
                                        jToggleButtonAI1.setSelected(true);
                                        jToggleButtonAI1.setEnabled(true);
                                        jLabelAI1Name.setEnabled(true);
                                        jLabelAI1Units.setEnabled(true);
                                        jButtonAI1Color.setEnabled(true);
                                    }
                                    break;
                                case 2:
                                    jLabelAI2Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                    jLabelAI2Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                    jButtonAI2Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                    if (lsAnalogData.elementAt(aiIndex).status) {
                                        jToggleButtonAI2.setSelected(true);
                                        jToggleButtonAI2.setEnabled(true);
                                        jLabelAI2Name.setEnabled(true);
                                        jLabelAI2Units.setEnabled(true);
                                        jButtonAI2Color.setEnabled(true);
                                    }
                                    break;
                                case 3:
                                    jLabelAI3Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                    jLabelAI3Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                    jButtonAI3Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                    if (lsAnalogData.elementAt(aiIndex).status) {
                                        jToggleButtonAI3.setSelected(true);
                                        jToggleButtonAI3.setEnabled(true);
                                        jLabelAI3Name.setEnabled(true);
                                        jLabelAI3Units.setEnabled(true);
                                        jButtonAI3Color.setEnabled(true);
                                    }
                                    break;
                                case 4:
                                    jLabelAI4Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                    jLabelAI4Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                    jButtonAI4Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                    if (lsAnalogData.elementAt(aiIndex).status) {
                                        jToggleButtonAI4.setSelected(true);
                                        jToggleButtonAI4.setEnabled(true);
                                        jLabelAI4Name.setEnabled(true);
                                        jLabelAI4Units.setEnabled(true);
                                        jButtonAI4Color.setEnabled(true);
                                    }
                                    break;
                                case 5:
                                    jLabelAI5Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                    jLabelAI5Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                    jButtonAI5Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                    if (lsAnalogData.elementAt(aiIndex).status) {
                                        jToggleButtonAI5.setSelected(true);
                                        jToggleButtonAI5.setEnabled(true);
                                        jLabelAI5Name.setEnabled(true);
                                        jLabelAI5Units.setEnabled(true);
                                        jButtonAI5Color.setEnabled(true);
                                    }
                                    break;
                                case 6:
                                    jLabelAI6Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                    jLabelAI6Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                    jButtonAI6Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                    if (lsAnalogData.elementAt(aiIndex).status) {
                                        jToggleButtonAI6.setSelected(true);
                                        jToggleButtonAI6.setEnabled(true);
                                        jLabelAI6Name.setEnabled(true);
                                        jLabelAI6Units.setEnabled(true);
                                        jButtonAI6Color.setEnabled(true);
                                    }
                                    break;
                                case 7:
                                    jLabelAI7Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                    jLabelAI7Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                    jButtonAI7Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                    if (lsAnalogData.elementAt(aiIndex).status) {
                                        jToggleButtonAI7.setSelected(true);
                                        jToggleButtonAI7.setEnabled(true);
                                        jLabelAI7Name.setEnabled(true);
                                        jLabelAI7Units.setEnabled(true);
                                        jButtonAI7Color.setEnabled(true);
                                    }
                                    break;
                            }
                        }
                    }
                    
                    // Now read the Voltage Recording data file
                    
                    // First try to determine the separator used for the CSV option.  The possibilities
                    // are; comma, tab, and semi-colon.
                    String delimiter = ",";
                    // Try to read it as a CSV file
                    try {
                        BufferedReader dataReader = new BufferedReader(new FileReader(dataF));
                        String dataLine = "";
                        double dataTime;
                        // Read the first line that contains the column headers to get it out of the way
                        // of the data
                        dataLine = dataReader.readLine();
                        while ((dataLine = dataReader.readLine()) != null) {
                            String[] dataArray = dataLine.split(delimiter);
                            dataTime = Double.parseDouble(dataArray[0]);
                            int elementIndex = 1;
                            for (int i = 0; i < 8; i++) {
                                double multiplier = lsAnalogData.elementAt(i).multiplier;
                                double divisor = lsAnalogData.elementAt(i).divisor;
                                if (lsAnalogData.elementAt(i).status) {
                                    lsAnalogData.elementAt(i).time.add(dataTime);
                                    double dataSample = Double.parseDouble(dataArray[elementIndex]) * multiplier / divisor;
                                    lsAnalogData.elementAt(i).data.add(dataSample);
                                    if (dataSample < lsAnalogData.elementAt(i).dataMin)
                                        lsAnalogData.elementAt(i).dataMin = dataSample;
                                    if (dataSample > lsAnalogData.elementAt(i).dataMax)
                                        lsAnalogData.elementAt(i).dataMax = dataSample;
                                    elementIndex++;
                                }
                            }
                        }
                        dataReader.close();
                    }
                    catch (java.io.IOException exception) {
                        //IJ.showMessage("error reading linescan data file IOException");
                    }
                    catch (java.lang.NumberFormatException exception) {
                        //IJ.showMessage("error reading linescan data file NumberFormatException");
                    }
                    
                    // Prepare the plot and image windows for the analog data
                    UpdateAnalogDisplay();
                }                
            }
            
            public void SetTriggerSyncDataFiles (String dataFile, String settingsFile) {
                lsDataFile = dataFile;
                lsSettingsFile = settingsFile;
                String igorDataFile = lsDataFile.replace(".dat", ".itx");
                
                File dataF = new File(lsDirectory + lsDataFile);
                File settingsF = new File(lsDirectory + lsSettingsFile);
                File igorF = new File(lsDirectory + igorDataFile);
                
                // Check to see if both files exist.  It could be a combination of a .dat and .prm file
                // or a combination of a .itx and .prm file
                if (((dataF.exists()) && (settingsF.exists())) || ((igorF.exists()) && (settingsF.exists()))) {
                    lsAnalogDataPresent = true;
                    lsAnalogDataFromTriggerSync = true;
                    
                    // If both files exist, first read the "settings" file to determine
                    // how many channels of analog data were collected, what particular channels
                    // were acquired, the color of each channel of data, and so on.
                    try {
                        lsAnalogDataNumberChannels = 0;
                        Wini ini = new Wini(settingsF);
                        for (int aiIndex = 0; aiIndex < 8; aiIndex++) {
                            AnalogDataSettings analogSettings = new AnalogDataSettings();
                            analogSettings.time = new Vector<Double>();
                            analogSettings.data = new Vector<Double>();
                            analogSettings.channel = aiIndex;
                            String tmpStr = ini.get("Channel Names", "Ch " + aiIndex + " Name");
                            tmpStr = tmpStr.replaceAll("\"", "");
                            if (tmpStr.length() == 0)
                                tmpStr = "N/A";
                            analogSettings.name = tmpStr;
                            tmpStr = ini.get("Channel Units", "Ch " + aiIndex + " Units");
                            tmpStr = tmpStr.replaceAll("\"", "");
                            if (tmpStr.length() == 0)
                                tmpStr = "N/A";
                            analogSettings.units = tmpStr;
                            analogSettings.status = ini.get("Channel Status", "Ch " + aiIndex + " Status", boolean.class);
                            analogSettings.color = Color.decode(ini.get("Channel Color", "Ch " + aiIndex + " Color"));
                            if (aiIndex == 0)
                                analogSettings.TriggerSyncScaleFactor = ini.get("Sensitivity", "Manual Sensitivity", double.class);
                            else
                                analogSettings.TriggerSyncScaleFactor = ini.get("Sensitivity", "Sensitivity " + aiIndex, double.class);
                            lsAnalogData.add(analogSettings);
                            if (analogSettings.status)
                                lsAnalogDataNumberChannels++;
                        }
                        lsAnalogDataSamplingRate = ini.get("Acq Params", "Acquisition Rate", int.class);
                        lsAnalogDataAcqTime = ini.get("Acq Params", "Acquisition Time", int.class);
                    }
                    catch (java.io.IOException exc) {
                        try {
                            FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                            PrintStream logStream = new PrintStream(logFile);
                            exc.printStackTrace(logStream);
                            logStream.flush();
                            logStream.close();
                            logFile.flush();
                            logFile.close();
                        } catch (IOException exception) {}
                    }
                    
                    // All of the analog data settings and data have been read.
                    // Set up the controls on the "Analog Data" tab.
                    for (int aiIndex = 0; aiIndex < 8; aiIndex++) {
                        switch (aiIndex) {
                            case 0:
                                jLabelAI0Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                jLabelAI0Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                jButtonAI0Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                if (lsAnalogData.elementAt(aiIndex).status) {
                                    jToggleButtonAI0.setSelected(true);
                                    jToggleButtonAI0.setEnabled(true);
                                    jLabelAI0Name.setEnabled(true);
                                    jLabelAI0Units.setEnabled(true);
                                    jButtonAI0Color.setEnabled(true);
                                    jCheckBoxApplyTriggerSyncScaling.setEnabled(true);
                                }
                                break;
                            case 1:
                                jLabelAI1Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                jLabelAI1Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                jButtonAI1Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                if (lsAnalogData.elementAt(aiIndex).status) {
                                    jToggleButtonAI1.setSelected(true);
                                    jToggleButtonAI1.setEnabled(true);
                                    jLabelAI1Name.setEnabled(true);
                                    jLabelAI1Units.setEnabled(true);
                                    jButtonAI1Color.setEnabled(true);
                                    jCheckBoxApplyTriggerSyncScaling.setEnabled(true);
                                }
                                break;
                            case 2:
                                jLabelAI2Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                jLabelAI2Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                jButtonAI2Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                if (lsAnalogData.elementAt(aiIndex).status) {
                                    jToggleButtonAI2.setSelected(true);
                                    jToggleButtonAI2.setEnabled(true);
                                    jLabelAI2Name.setEnabled(true);
                                    jLabelAI2Units.setEnabled(true);
                                    jButtonAI2Color.setEnabled(true);
                                    jCheckBoxApplyTriggerSyncScaling.setEnabled(true);
                                }
                                break;
                            case 3:
                                jLabelAI3Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                jLabelAI3Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                jButtonAI3Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                if (lsAnalogData.elementAt(aiIndex).status) {
                                    jToggleButtonAI3.setSelected(true);
                                    jToggleButtonAI3.setEnabled(true);
                                    jLabelAI3Name.setEnabled(true);
                                    jLabelAI3Units.setEnabled(true);
                                    jButtonAI3Color.setEnabled(true);
                                    jCheckBoxApplyTriggerSyncScaling.setEnabled(true);
                                }
                                break;
                            case 4:
                                jLabelAI4Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                jLabelAI4Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                jButtonAI4Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                if (lsAnalogData.elementAt(aiIndex).status) {
                                    jToggleButtonAI4.setSelected(true);
                                    jToggleButtonAI4.setEnabled(true);
                                    jLabelAI4Name.setEnabled(true);
                                    jLabelAI4Units.setEnabled(true);
                                    jButtonAI4Color.setEnabled(true);
                                    jCheckBoxApplyTriggerSyncScaling.setEnabled(true);
                                }
                                break;
                            case 5:
                                jLabelAI5Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                jLabelAI5Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                jButtonAI5Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                if (lsAnalogData.elementAt(aiIndex).status) {
                                    jToggleButtonAI5.setSelected(true);
                                    jToggleButtonAI5.setEnabled(true);
                                    jLabelAI5Name.setEnabled(true);
                                    jLabelAI5Units.setEnabled(true);
                                    jButtonAI5Color.setEnabled(true);
                                    jCheckBoxApplyTriggerSyncScaling.setEnabled(true);
                                }
                                break;
                            case 6:
                                jLabelAI6Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                jLabelAI6Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                jButtonAI6Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                if (lsAnalogData.elementAt(aiIndex).status) {
                                    jToggleButtonAI6.setSelected(true);
                                    jToggleButtonAI6.setEnabled(true);
                                    jLabelAI6Name.setEnabled(true);
                                    jLabelAI6Units.setEnabled(true);
                                    jButtonAI6Color.setEnabled(true);
                                    jCheckBoxApplyTriggerSyncScaling.setEnabled(true);
                                }
                                break;
                            case 7:
                                jLabelAI7Name.setText(lsAnalogData.elementAt(aiIndex).name);
                                jLabelAI7Units.setText(lsAnalogData.elementAt(aiIndex).units);
                                jButtonAI7Color.setBackground(lsAnalogData.elementAt(aiIndex).color);
                                if (lsAnalogData.elementAt(aiIndex).status) {
                                    jToggleButtonAI7.setSelected(true);
                                    jToggleButtonAI7.setEnabled(true);
                                    jLabelAI7Name.setEnabled(true);
                                    jLabelAI7Units.setEnabled(true);
                                    jButtonAI7Color.setEnabled(true);
                                    jCheckBoxApplyTriggerSyncScaling.setEnabled(true);
                                }
                                break;
                        }
                    }
                    
                    // Now read the TriggerSync data file
                    
                    // First try to determine the separator used for the CSV option.  The possibilities
                    // are; comma, tab, and semi-colon.
                    boolean isIgorFormat = false;
                    if (igorF.exists()) {
                        try {
                        BufferedReader dataReader = new BufferedReader(new FileReader(igorF));
                            String dataLine = dataReader.readLine();
                            if (dataLine.contains("IGOR"))
                                isIgorFormat = true;
                            dataReader.close();
                        }
                        catch (java.io.IOException exception) {
                        }
                    }
                    String delimiter = ",";
                    if (!isIgorFormat) {
                        try {
                            BufferedReader dataReader = new BufferedReader(new FileReader(dataF));
                            String dataLine = dataReader.readLine();
                            if (dataLine.contains(","))
                                delimiter = ",";
                            else if (dataLine.contains("\t"))
                                delimiter = "\t";
                            else if (dataLine.contains(";"))
                                delimiter = ";";
                            else
                                delimiter = ",";
                            dataReader.close();
                        }
                        catch (java.io.IOException exception) {
                           //IJ.showMessage("error reading linescan data file IOException");
                        }
                    }
                    boolean successfulDataRead = false;
                    if (isIgorFormat) {
                        // The first line should be "IGOR"
                        
                        try {
                            String igorFileStr = lsDataFile;
                            igorFileStr = igorFileStr.replace(".dat", ".itx");
                            File igorFile = new File(lsDirectory + igorFileStr);
                            BufferedReader dataReader = new BufferedReader(new FileReader(igorFile));
                            String fileType = dataReader.readLine();
                            if (fileType.contains("IGOR")) {
                                // Continue to read lines until the "BEGIN" string has been read
                                boolean beginFound = false;
                                String headerLine = "";
                                while (!beginFound) {
                                    headerLine = dataReader.readLine();
                                    if (headerLine.contains("BEGIN"))
                                        beginFound = true;
                                }
                                String dataLine = "";
                                if (beginFound) {
                                   double dataTime = 0.0;
                                   double timeDelta = 1.0 / lsAnalogDataSamplingRate;
                                   int j = 0;
                                   boolean endFound = false;
                                   while (((dataLine = dataReader.readLine()) != null) && (!endFound)) {
                                        if (dataLine.contains("END"))
                                            endFound = true;
                                        else {
                                            int elementIndex = 0;
                                            String[] dataArray = dataLine.split(" ");
                                            for (int i = 0; i < 8; i++) {
                                                if (lsAnalogData.elementAt(i).status) {
                                                    // Multiply the time by 1000 to scale it to milliseconds from seconds.
                                                    lsAnalogData.elementAt(i).time.add(timeDelta * j * 1000.0);
                                                    double dataSample = Double.parseDouble(dataArray[elementIndex]);
                                                    lsAnalogData.elementAt(i).data.add(dataSample);
                                                    if (dataSample < lsAnalogData.elementAt(i).dataMin)
                                                        lsAnalogData.elementAt(i).dataMin = dataSample;
                                                    if (dataSample > lsAnalogData.elementAt(i).dataMax)
                                                        lsAnalogData.elementAt(i).dataMax = dataSample;
                                                    elementIndex++;
                                                }
                                            }
                                        }
                                        j++;
                                    }
                                    dataReader.close();
                                    successfulDataRead = true;
                                }
                             }
                        }
                        catch (java.io.IOException exception) {
                            
                        }
                    }
                    if (!successfulDataRead) {
                        // Try to read it as a CSV file and if it fails, assume it is binary?
                        try {
                            BufferedReader dataReader = new BufferedReader(new FileReader(dataF));
                            String dataLine = "";
                            double dataTime;
                            while ((dataLine = dataReader.readLine()) != null) {
                                String[] dataArray = dataLine.split(delimiter);
                                // Multiply the time by 1000 to scale it to milliseconds from seconds.
                                dataTime = Double.parseDouble(dataArray[0]) * 1000.0;
                                int elementIndex = 1;
                                for (int i = 0; i < 8; i++) {
                                    if (lsAnalogData.elementAt(i).status) {
                                        lsAnalogData.elementAt(i).time.add(dataTime);
                                        double dataSample = Double.parseDouble(dataArray[elementIndex]);
                                        lsAnalogData.elementAt(i).data.add(dataSample);
                                        if (dataSample < lsAnalogData.elementAt(i).dataMin)
                                            lsAnalogData.elementAt(i).dataMin = dataSample;
                                        if (dataSample > lsAnalogData.elementAt(i).dataMax)
                                            lsAnalogData.elementAt(i).dataMax = dataSample;
                                        elementIndex++;
                                    }
                                }
                            }
                            dataReader.close();
                            successfulDataRead = true;
                        }
                        catch (java.io.IOException exception) {
                            // Hopefully an error only indicates that this is a binary (TriggerSync native
                            // format) file and not a CSV file.  So try reading that format instead.
                            successfulDataRead = false;
                            //IJ.showMessage("error reading linescan data file IOException");
                        }
                        catch (java.lang.NumberFormatException exception) {
                            // Hopefully an error only indicates that this is a binary (TriggerSync native
                            // format) file and not a CSV file.  So try reading that format instead.
                            successfulDataRead = false;
                            //IJ.showMessage("error reading linescan data file NumberFormatException");
                        }
                    }
                    if (!successfulDataRead) {
                        try {
                            RandomAccessFile in = new RandomAccessFile(lsDirectory + lsDataFile, "r");
                            byte char1 = in.readByte();
                            byte char2 = in.readByte();
                            byte char3 = in.readByte();
                            byte char4 = in.readByte();
                            if ((char1 == 'D') && (char2 == 'T') && (char3 == 'L') && (char4 == 'G')) {
                                // Since the file starts with 'DTLG' this is probably the TriggerSync
                                // binary file format.
                                in.seek(619);
                                byte numChannels = in.readByte();
                                int numDataPointsPerChannel = in.readInt();
                                float ePhysData = 0.0f;
                                // Read all of the data for the specified number of channels
                                for (int i = 0; i < numChannels; i++) {
                                    // Determine which element of the lsAnalogData vector corresponds
                                    // to the channel to be read (first, second, third, and etc.)
                                    int chan = -1;
                                    int activeChannelIndex = 0;
                                    int k = 0;
                                    boolean notFound = true;
                                    while (k < 8 || notFound) {
                                        if (lsAnalogData.elementAt(k).status) {
                                            chan++;
                                            if (chan == i) {
                                                notFound = false;
                                                activeChannelIndex = k;
                                            }
                                        }
                                        k++;
                                    }
                                    double timeDelta = 1.0 / lsAnalogDataSamplingRate;
                                    for (int j = 0; j < numDataPointsPerChannel; j++) {
                                        ePhysData = in.readFloat();
                                        double data = ePhysData;
                                        lsAnalogData.elementAt(activeChannelIndex).time.add(timeDelta * j * 1000.0);
                                        lsAnalogData.elementAt(activeChannelIndex).data.add(data);
                                        if (data < lsAnalogData.elementAt(activeChannelIndex).dataMin)
                                            lsAnalogData.elementAt(activeChannelIndex).dataMin = data;
                                        if (data > lsAnalogData.elementAt(activeChannelIndex).dataMax)
                                            lsAnalogData.elementAt(activeChannelIndex).dataMax = data;
                                    }
                                }
                                in.close();
                                successfulDataRead = true;
                            }
                        }
                        catch (java.io.FileNotFoundException exception) {
                            //IJ.showMessage("error reading binary file FileNotFoundException");
                        }
                        catch (java.io.IOException exception) {
                            //IJ.showMessage("error reading binary file IOException");
                        }
                    }
                    
                    // Prepare the plot and image windows for the analog data
                    UpdateAnalogDisplay();
                }
            }
            
            public void UpdateProfileDisplayOption (boolean choice) {
                lsProfilesInSeparateWindows = choice;
                UpdateProfiles();
            }
            
            public void UpdateAnalogDisplay() {
                
                if (!lsAnalogDataPresent)
                    return;
                
                for (int i = 0; i < 8; i++) {
                    if ((lsAnalogData.elementAt(i).status) && (lsAnalogData.elementAt(i).data.size() > 0)) {
                        lsAnalogData.elementAt(i).plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " " + lsAnalogData.elementAt(i).name, "Time (ms)", lsAnalogData.elementAt(i).units);
                        int timeVectorLength = lsAnalogData.elementAt(i).time.size();
                        double xMax = lsAnalogData.elementAt(i).time.elementAt(timeVectorLength - 1);
                        double scaleFactor = 1.0;
                        if (jCheckBoxApplyTriggerSyncScaling.isSelected())
                            scaleFactor = ((1.0 / lsAnalogData.elementAt(i).TriggerSyncScaleFactor) * 1000.0);
                        lsAnalogData.elementAt(i).plotWindow.setLimits(0.0, xMax, lsAnalogData.elementAt(i).dataMin * scaleFactor, lsAnalogData.elementAt(i).dataMax * scaleFactor);
                        // Create the appropriate arrays to use for the plot display
                        double[] plotTime = new double[timeVectorLength];
                        double[] plotData = new double[timeVectorLength];
                        for (int j = 0; j < timeVectorLength; j++) {
                            plotTime[j] = lsAnalogData.elementAt(i).time.elementAt(j);
                            plotData[j] = lsAnalogData.elementAt(i).data.elementAt(j) * scaleFactor;
                        }
                        // Add the plot data to the plot
                        lsAnalogData.elementAt(i).plotWindow.setColor(lsAnalogData.elementAt(i).color);
                        lsAnalogData.elementAt(i).plotWindow.addPoints(plotTime, plotData, PlotWindow.LINE);
                        lsAnalogData.elementAt(i).plotWindow.draw();
                        if (lsAnalogData.elementAt(i).imagePlusPlotWindow == null)
                            lsAnalogData.elementAt(i).imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " " + lsAnalogData.elementAt(i).name, lsAnalogData.elementAt(i).plotWindow.getProcessor());
                        else
                            lsAnalogData.elementAt(i).imagePlusPlotWindow.setProcessor(null, lsAnalogData.elementAt(i).plotWindow.getProcessor());
                    }
                }
                
                // loop through the analog channels and if the channel is present and it's associated
                // 'Display' toggle button is enabled, display the analog data in its own window.
                for (int chanIndex = 0; chanIndex < 8; chanIndex++) {
                    if ((lsAnalogData.elementAt(chanIndex).status) && (lsAnalogData.elementAt(chanIndex).data.size() > 0)) {
                        // Show or hide the plot window depending upon the status of the 'Display'
                        // toggle button which allows the operator to choose to show/hide the analog
                        // data display for this particular channel.
                        boolean showWindow = false;
                        switch (chanIndex) {
                            case 0:
                                if (jToggleButtonAI0.isSelected())
                                    showWindow = true;
                                break;
                            case 1:
                                if (jToggleButtonAI1.isSelected())
                                        showWindow = true;
                                break;
                            case 2:
                                if (jToggleButtonAI2.isSelected())
                                    showWindow = true;
                                break;
                            case 3:
                                if (jToggleButtonAI3.isSelected())
                                        showWindow = true;
                                break;
                            case 4:
                                if (jToggleButtonAI4.isSelected())
                                    showWindow = true;
                                break;
                            case 5:
                                if (jToggleButtonAI5.isSelected())
                                        showWindow = true;
                                break;
                            case 6:
                                if (jToggleButtonAI6.isSelected())
                                    showWindow = true;
                                break;
                            case 7:
                                if (jToggleButtonAI7.isSelected())
                                        showWindow = true;
                                break;
                        }
                        if (showWindow) {
                            lsAnalogData.elementAt(chanIndex).imagePlusPlotWindow.show();
                        }
                        else {
                            lsAnalogData.elementAt(chanIndex).imagePlusPlotWindow.hide();
                        }
                    }
                }
            }
            
            public void SetDwellTime (double dwellTime) {
                lsDwellTime = Math.abs(dwellTime) / 1000.0;
            }
            
            public void SetScanlinePeriod (double scanlinePeriod) {
                lsScanlinePeriod = Math.abs(scanlinePeriod);
            }
            
            public void SetNumberOfLines (int numLines) {
                lsNumLines = Math.abs(numLines);
            }
            
            public void SetPixelsPerLine (int pixelsPerLine) {
                lsPixelsPerLine = Math.abs(pixelsPerLine);
                // Define the limits for the "position" scrollbar
                jScrollBarProfilePosition.setMaximum(lsPixelsPerLine + 9);
                jScrollBarProfilePosition.setMinimum(0);
            }
            
            public void SetSequenceNumber (int seqNum) {
                lsSequenceNumber = Math.abs(seqNum);
            }
            
            public void SetLinescanTraceInformation (int type, double startPixelX, double stopPixelX, double pixelY, Vector<Double> freehandPixelX, Vector<Double> freehandPixelY) {
                lsType = type;
                lsStartPixelX = startPixelX;
                lsStopPixelX = stopPixelX;
                lsPixelY = pixelY;
                lsFreehandPixelX = freehandPixelX;
                lsFreehandPixelY = freehandPixelY;
            }
            
            public void PreparePlotWindows() {
                // Apparently the display range for the plot window needs to be set programmatically
                // since it doesn't appear to have an 'automatic scaling' capability.
                // Therefore, I'll have to compute the xMax value as the maximum time value, and the
                // yMin and yMax values based upon the intensity data for each linescan channel image.
                // For the graph that displays the plots from all possible image channels, the yMin and
                // yMax values will be based on all images.
                
                lsXMax = lsScanlinePeriod * (lsNumLines + 1);
                
                if (lsNumChans == 1) {
                    lsYMin = lsWindow.getImagePlus().getProcessor().getMin();
                    lsYMax = lsWindow.getImagePlus().getProcessor().getMax();
                }
                else {
                    lsYMin1 = lsSingleChannelWindow1.getImagePlus().getProcessor().getMin();
                    lsYMax1 = lsSingleChannelWindow1.getImagePlus().getProcessor().getMax();
                    lsYMin = lsYMin1;
                    lsYMax = lsYMax1;
                    lsYMin2 = lsSingleChannelWindow2.getImagePlus().getProcessor().getMin();
                    lsYMax2 = lsSingleChannelWindow2.getImagePlus().getProcessor().getMax();
                    if (lsYMin2 < lsYMin) lsYMin = lsYMin2;
                    if (lsYMax2 > lsYMax) lsYMax = lsYMax2;
                    if (lsNumChans > 2) {
                        lsYMin3 = lsSingleChannelWindow3.getImagePlus().getProcessor().getMin();
                        lsYMax3 = lsSingleChannelWindow3.getImagePlus().getProcessor().getMax();
                        if (lsYMin3 < lsYMin) lsYMin = lsYMin3;
                        if (lsYMax3 > lsYMax) lsYMax = lsYMax3;
                        if (lsNumChans > 3) {
                            lsYMin4 = lsSingleChannelWindow4.getImagePlus().getProcessor().getMin();
                            lsYMax4 = lsSingleChannelWindow4.getImagePlus().getProcessor().getMax();
                            if (lsYMin4 < lsYMin) lsYMin = lsYMin4;
                            if (lsYMax4 > lsYMax) lsYMax = lsYMax4;
                        }
                    }
                }
                lsPlotWindow = new Plot("Prairie Sequence " + lsSequenceNumber, "Time (ms)", "Intensity");
                lsPlotWindow.setLimits(lsXMin, lsXMax, lsYMin, lsYMax);
                if (lsNumChans > 1) {
                    lsPlotSingleChannelWindow1 = new Plot("I1 " + lsCh1Label + " Prairie Sequence " + lsSequenceNumber, "Time (ms)", "Intensity");
                    lsPlotSingleChannelWindow1.setLimits(lsXMin, lsXMax, lsYMin1, lsYMax1);
                    lsPlotSingleChannelWindow2 = new Plot("I2 " + lsCh2Label + " Prairie Sequence " + lsSequenceNumber, "Time (ms)", "Intensity");
                    lsPlotSingleChannelWindow2.setLimits(lsXMin, lsXMax, lsYMin2, lsYMax2);
                    if (lsNumChans > 2) {
                        lsPlotSingleChannelWindow3 = new Plot("I3 " + lsCh3Label + " Prairie Sequence " + lsSequenceNumber, "Time (ms)", "Intensity");
                        lsPlotSingleChannelWindow3.setLimits(lsXMin, lsXMax, lsYMin3, lsYMax3);
                        if (lsNumChans > 3) {
                            lsPlotSingleChannelWindow4 = new Plot("I4 " + lsCh4Label + " Prairie Sequence " + lsSequenceNumber, "Time (ms)", "Intensity");
                            lsPlotSingleChannelWindow4.setLimits(lsXMin, lsXMax, lsYMin4, lsYMax4);
                        }
                    }
                        
                }
            }
            
            public void DrawLinescanTrace() {
                Color lsColor = Color.CYAN;
                Overlay lsImageOverlay = new Overlay();
                Overlay lsImageOverlay1 = new Overlay();
                Overlay lsImageOverlay2 = new Overlay();
                Overlay lsImageOverlay3 = new Overlay();
                Overlay lsImageOverlay4 = new Overlay();
                
                // First, draw the complete trace in the base color
                
                if (lsType == LinescanTypeLine) {
                    // Draw the overlay for the "Line" linescan
                    //Line lsLine = new Line(currentSequence.LinescanStartPixelX, currentSequence.LinescanPixelY, currentSequence.LinescanStopPixelX, currentSequence.LinescanPixelY);
                    // Since the image has been rotated 90 degrees to the left, the line must be rotated as well.
                    Line lsLine = new Line(lsPixelY, lsWindowCompRef.getImagePlus().getHeight() - lsStartPixelX, lsPixelY, lsWindowCompRef.getImagePlus().getHeight() - lsStopPixelX);
                    lsLine.setColor(lsColor);
                    lsImageOverlay.add(lsLine);
                    lsImageOverlay1.add(lsLine);
                    lsImageOverlay2.add(lsLine);
                    lsImageOverlay3.add(lsLine);
                    lsImageOverlay4.add(lsLine);
                }
                else {
                    // Draw the overly for the other patterns (Circle, Spiral, Lissajous, Freehand)
                    for (int pointIndex = 0; pointIndex < lsFreehandPixelX.size() - 1; pointIndex++) {
                        //Line lsLine = new Line(currentSequence.LinescanFreehandPixelX.elementAt(pointIndex), currentSequence.LinescanFreehandPixelY.elementAt(pointIndex), currentSequence.LinescanFreehandPixelX.elementAt(pointIndex + 1), currentSequence.LinescanFreehandPixelY.elementAt(pointIndex + 1));
                        // Since the image has been rotated 90 degrees to the left, the line must be rotated as well.
                        Line lsLine = new Line(lsFreehandPixelY.elementAt(pointIndex), lsWindowCompRef.getImagePlus().getHeight() - lsFreehandPixelX.elementAt(pointIndex), lsFreehandPixelY.elementAt(pointIndex + 1), lsWindowCompRef.getImagePlus().getHeight() - lsFreehandPixelX.elementAt(pointIndex + 1));
                        lsLine.setColor(lsColor);
                        lsImageOverlay.add(lsLine);
                        lsImageOverlay1.add(lsLine);
                        lsImageOverlay2.add(lsLine);
                        lsImageOverlay3.add(lsLine);
                        lsImageOverlay4.add(lsLine);
                    }
                }

                // Second, redraw segments based upon the profile specifications
                
                for (int i = 0; i < lsProfiles.size(); i++) {
                    int startPosIndex;
                    int stopPosIndex;
                    if (lsProfiles.elementAt(i).width == 1) {
                        startPosIndex = lsProfiles.elementAt(i).position;
                        stopPosIndex = lsProfiles.elementAt(i).position;
                    }
                    else {
                        startPosIndex = lsProfiles.elementAt(i).position - (lsProfiles.elementAt(i).width / 2);
                        stopPosIndex = lsProfiles.elementAt(i).position + (lsProfiles.elementAt(i).width / 2);
                    }
                    
                   if (lsType == LinescanTypeLine) {
                        // Draw the overlay for the "Line" linescan
                        // Since the image has been rotated 90 degrees to the left, the line must be rotated as well.
                        Line lsLine = new Line(lsPixelY, lsWindowCompRef.getImagePlus().getHeight() - lsStopPixelX + startPosIndex, lsPixelY, lsWindowCompRef.getImagePlus().getHeight() - lsStopPixelX + stopPosIndex);
                        lsLine.setFillColor(lsProfiles.elementAt(i).color);
                        lsLine.setStrokeColor(lsProfiles.elementAt(i).color);
                        lsImageOverlay.add(lsLine);
                        switch (lsProfiles.elementAt(i).channel) {
                            case 0:
                                lsImageOverlay1.add(lsLine);
                                break;
                            case 1:
                                lsImageOverlay2.add(lsLine);
                                break;
                            case 2:
                                lsImageOverlay3.add(lsLine);
                                break;
                            case 3:
                                lsImageOverlay4.add(lsLine);
                                break;
                        }
                    }
                    else {
                       try {
                            // Draw the overly for the other patterns (Circle, Spiral, Lissajous, Freehand)
                            for (int pointIndex = (lsFreehandPixelX.size() - startPosIndex); pointIndex >= (lsFreehandPixelX.size() - stopPosIndex); pointIndex--) {
                                // Since the image has been rotated 90 degrees to the left, the line must be rotated as well.
                                Line lsLine = new Line(lsFreehandPixelY.elementAt(pointIndex), lsWindowCompRef.getImagePlus().getHeight() - lsFreehandPixelX.elementAt(pointIndex), lsFreehandPixelY.elementAt(pointIndex + 1), lsWindowCompRef.getImagePlus().getHeight() - lsFreehandPixelX.elementAt(pointIndex + 1));
                                lsLine.setFillColor(lsProfiles.elementAt(i).color);
                                lsLine.setStrokeColor(lsProfiles.elementAt(i).color);
                                lsImageOverlay.add(lsLine);
                                switch (lsProfiles.elementAt(i).channel) {
                                case 0:
                                    lsImageOverlay1.add(lsLine);
                                    break;
                                case 1:
                                    lsImageOverlay2.add(lsLine);
                                    break;
                                case 2:
                                    lsImageOverlay3.add(lsLine);
                                    break;
                                case 3:
                                    lsImageOverlay4.add(lsLine);
                                    break;
                                }
                            }
                       }
                            catch(java.lang.ArrayIndexOutOfBoundsException exc) {
                                // don't necessarily do anything yet.
                        }
                    }
                }
                
                // Third, update the necessary image windows
                
                lsWindowCompRef.getImagePlus().setOverlay(lsImageOverlay);
                lsWindowCompRef.getImagePlus().draw();
                
                if (lsNumChans > 1) {
                    lsSingleChannelWindow1Ref.getImagePlus().setOverlay(lsImageOverlay1);
                    lsSingleChannelWindow1Ref.getImagePlus().draw();
                    lsSingleChannelWindow2Ref.getImagePlus().setOverlay(lsImageOverlay2);
                    lsSingleChannelWindow2Ref.getImagePlus().draw();
                    if (lsNumChans > 2) {
                        lsSingleChannelWindow3Ref.getImagePlus().setOverlay(lsImageOverlay3);
                        lsSingleChannelWindow3Ref.getImagePlus().draw();
                    }
                   if (lsNumChans > 3) {
                        lsSingleChannelWindow4Ref.getImagePlus().setOverlay(lsImageOverlay4);
                        lsSingleChannelWindow4Ref.getImagePlus().draw();
                    }
                }
            }
            
            public void SetChannelNames(int numChans, String ch1, String ch2, String ch3, String ch4) {
                // Retain the number of channels and channel labels in case they need to be used in other
                // places in the class.
                lsNumChans = numChans;
                lsCh1Label = ch1;
                lsCh2Label = ch2;
                lsCh3Label = ch3;
                lsCh4Label = ch4;
                jComboBoxChannelSelection.removeAllItems();
                if (numChans == 1) {
                    jComboBoxChannelSelection.addItem(ch1);
                }
                else if (numChans == 2) {
                    jComboBoxChannelSelection.addItem(ch1);
                    jComboBoxChannelSelection.addItem(ch2);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch2);
                }
                else if (numChans == 3) {
                    jComboBoxChannelSelection.addItem(ch1);
                    jComboBoxChannelSelection.addItem(ch2);
                    jComboBoxChannelSelection.addItem(ch3);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch2);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch3);
                    jComboBoxChannelSelection.addItem(ch2 + " & " + ch3);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch2 + " & " + ch3);
                }
                else if (numChans == 4) {
                    jComboBoxChannelSelection.addItem(ch1);
                    jComboBoxChannelSelection.addItem(ch2);
                    jComboBoxChannelSelection.addItem(ch3);
                    jComboBoxChannelSelection.addItem(ch4);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch2);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch3);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch4);
                    jComboBoxChannelSelection.addItem(ch2 + " & " + ch3);
                    jComboBoxChannelSelection.addItem(ch2 + " & " + ch4);
                    jComboBoxChannelSelection.addItem(ch3 + " & " + ch4);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch2 + " & " + ch3);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch2 + " & " + ch4);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch3 + " & " + ch4);
                    jComboBoxChannelSelection.addItem(ch2 + " & " + ch3 + " & " + ch4);
                    jComboBoxChannelSelection.addItem(ch1 + " & " + ch2 + " & " + ch3 + " & " + ch4);
                }
            }
            
           public void SetLinescanWindows(ImageWindow compRef, ImageWindow ch1Ref, ImageWindow ch2Ref, ImageWindow ch3Ref, ImageWindow ch4Ref, ImageWindow lsComp, ImageWindow ch1, ImageWindow ch2, ImageWindow ch3, ImageWindow ch4) {
               
               lsWindowCompRef = compRef;
               lsSingleChannelWindow1Ref = ch1Ref;
               lsSingleChannelWindow2Ref = ch2Ref;
               lsSingleChannelWindow3Ref = ch3Ref;
               lsSingleChannelWindow4Ref = ch4Ref;
               
               lsWindow = lsComp;
               lsSingleChannelWindow1 = ch1;
               lsSingleChannelWindow2 = ch2;
               lsSingleChannelWindow3 = ch3;
               lsSingleChannelWindow4 = ch4;
           }
           
           public void UpdateProfiles() {
               // Retain the currently selected profiles.
               int[] originalProfiles = listProfileList.getSelectedIndexes();
               
               // Retain the currently selected functions.
               int[] originalFunctions = listProfileFunctionList.getSelectedIndexes();
               
               // Retain the currently selected analog data functions.
               int[] originalAnalogDataFunctions = listAnalogDataFunctionList.getSelectedIndexes();
               
               // Delete any current profiles from the list of profiles
               listProfileList.removeAll();
               
               // Delete any current functions from the list of functions
               listProfileFunctionList.removeAll();
               
               // Delete any current functions from the list of analog data functions
               listAnalogDataFunctionList.removeAll();
               
               if (lsProfiles.size() == 0) {
                    // Clear the graphics overlay so that no old profiles are still visible
                    Overlay lsImageOverlay = new Overlay();
                    Overlay lsImageOverlay1 = new Overlay();
                    Overlay lsImageOverlay2 = new Overlay();
                    Overlay lsImageOverlay3 = new Overlay();
                    Overlay lsImageOverlay4 = new Overlay();

                    // Add the overlays to the appropriate windows.
                    lsWindow.getImagePlus().setOverlay(lsImageOverlay);
                    lsWindow.getImagePlus().draw();
                    if (lsNumChans > 1) {
                       lsSingleChannelWindow1.getImagePlus().setOverlay(lsImageOverlay1);
                       lsSingleChannelWindow1.getImagePlus().draw();
                       lsSingleChannelWindow2.getImagePlus().setOverlay(lsImageOverlay2);
                       lsSingleChannelWindow2.getImagePlus().draw();
                       if (lsNumChans > 2) {
                           lsSingleChannelWindow3.getImagePlus().setOverlay(lsImageOverlay3);
                           lsSingleChannelWindow3.getImagePlus().draw();
                       }
                       if (lsNumChans > 3) {
                           lsSingleChannelWindow4.getImagePlus().setOverlay(lsImageOverlay4);
                           lsSingleChannelWindow4.getImagePlus().draw();
                       }
                    }
                    WriteProfileSettings();
                    //return;
               }
               
               // Next, loop through any profiles and add them to the "list" control
               for(int index = 0; index < lsProfiles.size(); index++) {
                   String profileLabel;
                   String prairieViewLabel = "";
                   if (lsProfiles.elementAt(index).prairieViewProfile) {
                       prairieViewLabel = " (Prairie View) ";
                   }
                   String thresholdLabel = "";
                   String thresholdRange = "";
                   if (lsProfiles.elementAt(index).threshold) {
                       thresholdLabel = "Threshold ";
                       thresholdRange = " (" + (int)lsProfiles.elementAt(index).thresholdMin + " - " + (int)lsProfiles.elementAt(index).thresholdMax + ")";
                   }
                   switch (lsProfiles.elementAt(index).channel) {
                       case 0:
                           profileLabel = thresholdLabel + "Profile " + (index + 1) + ": " + lsCh1Label + prairieViewLabel + thresholdRange;
                           lsProfiles.elementAt(index).imagePlusPlotWindow.setTitle("Prairie Sequence " + lsSequenceNumber + " Profile " + (index + 1) + ": " + lsCh1Label);
                           break;
                       case 1:
                           profileLabel = thresholdLabel + "Profile " + (index + 1) + ": " + lsCh2Label + prairieViewLabel + thresholdRange;
                           lsProfiles.elementAt(index).imagePlusPlotWindow.setTitle("Prairie Sequence " + lsSequenceNumber + " Profile " + (index + 1) + ": " + lsCh2Label);
                           break;
                       case 2:
                           profileLabel = thresholdLabel + "Profile " + (index + 1) + ": " + lsCh3Label + prairieViewLabel + thresholdRange;
                           lsProfiles.elementAt(index).imagePlusPlotWindow.setTitle("Prairie Sequence " + lsSequenceNumber + " Profile " + (index + 1) + ": " + lsCh3Label);
                           break;
                       case 3:
                           profileLabel = thresholdLabel + "Profile " + (index + 1) + ": " + lsCh4Label + prairieViewLabel + thresholdRange;
                           lsProfiles.elementAt(index).imagePlusPlotWindow.setTitle("Prairie Sequence " + lsSequenceNumber + " Profile " + (index + 1) + ": " + lsCh4Label);
                           break;
                       default:
                           profileLabel = "Unknown channel";
                   }
                   listProfileList.add(profileLabel);
                   listProfileList.repaint();
               }
               
               for (int index = 0; index < originalProfiles.length; index++) {
                   if (originalProfiles[index] < lsProfiles.size())
                       listProfileList.select(originalProfiles[index]);
               }
               
               // Loop through any profile functions and add them to the list.
               for (int index = 0; index < lsFunctions.size(); index++) {
                   listProfileFunctionList.add(lsFunctions.elementAt(index).functionName);
                   listProfileFunctionList.repaint();
               }
               
               for (int index = 0; index < originalFunctions.length; index++) {
                   if (originalFunctions[index] < lsFunctions.size())
                       listProfileFunctionList.select(originalFunctions[index]);
               }
               
               // Loop through any analog data functions and add them to the list.
               for (int index = 0; index < lsAnalogDataFunctions.size(); index++) {
                   listAnalogDataFunctionList.add(lsAnalogDataFunctions.elementAt(index).functionName);
                   listAnalogDataFunctionList.repaint();
               }
               
               for (int index = 0; index < originalAnalogDataFunctions.length; index++) {
                   if (originalAnalogDataFunctions[index] < lsAnalogDataFunctions.size())
                       listAnalogDataFunctionList.select(originalAnalogDataFunctions[index]);
               }
               
               // Creating this list so that if a profile that is not currently selected
               // (and therefore not being generated) is being used in a selected function,
               // then the necessary prfofile data will be generated.
               
               int functionIndexes[] = listProfileFunctionList.getSelectedIndexes();
               Vector<Integer> functionProfiles = new Vector<Integer>();
               
               int indexes[] = listProfileList.getSelectedIndexes();
               
               for (int functionIndex = 0; functionIndex < functionIndexes.length; functionIndex++) {
                   // Parse the function string.
                   lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing = ParseExpression(lsFunctions.elementAt(functionIndexes[functionIndex]).functionExpression);
                   
                   // Loop through the "functionProcessing" elements and look for the use of any
                   // profile numbers.
                   for (int i = 0; i < lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.size(); i++) {
                       if ((lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.elementAt(i) == 1) || (lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.elementAt(i) == 2) || (lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.elementAt(i) == 4)) {
                           // Check the profile number for validity
                           int profileNumber = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.profileNumber.elementAt(i) - 1;
                           if ((profileNumber >= 0) && (profileNumber < lsProfiles.size())) {
                               // A valid profile number is found, if it's not already in the list,
                               // add it to the list
                               boolean profileExists = false;
                               for (int j = 0; j < functionProfiles.size(); j++) {
                                   if (profileNumber == functionProfiles.elementAt(j))
                                       profileExists = true;
                               }
                               // Before adding the profile number to the list make sure
                               // that this profile isn't already scheduled for display by being
                               // selected in the profile list.
                               for (int j = 0; j < indexes.length; j++) {
                                   if (profileNumber == indexes[j])
                                       profileExists = true;
                               }
                               if (!profileExists) {
                                    functionProfiles.add(profileNumber);
                               }
                           }
                       }
                   }
               }
               
               // Next, display "profiles" on the linescan images.
               
               // Need a separate "overlay" for each of the linescan windows.
               Overlay lsImageOverlay = new Overlay();
               Overlay lsImageOverlay1 = new Overlay();
               Overlay lsImageOverlay2 = new Overlay();
               Overlay lsImageOverlay3 = new Overlay();
               Overlay lsImageOverlay4 = new Overlay();
               
               for (int index = 0; index < lsProfiles.size(); index++) {
//                   if (lsProfiles.elementAt(index).width == 1) {
//                       // All profiles will be displayed in the "composite" image.
//                       Line lsOverlayLine = new Line(0, lsProfiles.elementAt(index).position, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position);
//                       lsOverlayLine.setFillColor(lsProfiles.elementAt(index).color);
//                       lsOverlayLine.setStrokeColor(lsProfiles.elementAt(index).color);
//                       lsImageOverlay.add(lsOverlayLine);
//                       if (lsNumChans > 1) {
//                           if (lsProfiles.elementAt(index).channel == 0) {
//                               Line lsOverlayLine1 = new Line(0, lsProfiles.elementAt(index).position, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position);
//                               lsOverlayLine1.setFillColor(lsProfiles.elementAt(index).color);
//                               lsOverlayLine1.setStrokeColor(lsProfiles.elementAt(index).color);
//                               lsImageOverlay1.add(lsOverlayLine1);
//                           }
//                           else if (lsProfiles.elementAt(index).channel == 1) {
//                               Line lsOverlayLine2 = new Line(0, lsProfiles.elementAt(index).position, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position);
//                               lsOverlayLine2.setFillColor(lsProfiles.elementAt(index).color);
//                               lsOverlayLine2.setStrokeColor(lsProfiles.elementAt(index).color);
//                               lsImageOverlay2.add(lsOverlayLine2);
//                           }
//                           else if (lsProfiles.elementAt(index).channel == 2) {
//                               Line lsOverlayLine3 = new Line(0, lsProfiles.elementAt(index).position, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position);
//                               lsOverlayLine3.setFillColor(lsProfiles.elementAt(index).color);
//                               lsOverlayLine3.setStrokeColor(lsProfiles.elementAt(index).color);
//                               lsImageOverlay3.add(lsOverlayLine3);
//                           }
//                           else if (lsProfiles.elementAt(index).channel == 3) {
//                               Line lsOverlayLine4 = new Line(0, lsProfiles.elementAt(index).position, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position);
//                               lsOverlayLine4.setFillColor(lsProfiles.elementAt(index).color);
//                               lsOverlayLine4.setStrokeColor(lsProfiles.elementAt(index).color);
//                               lsImageOverlay4.add(lsOverlayLine4);
//                           }
//                       }
//                   }
//                   else {
                       if (lsProfiles.elementAt(index).threshold) {
                           // The 'threshold' option has been seleted so each
                           // pixel in the profile needs to be evaluated.  If
                           // the intensity of the pixel is less than the 
                           // threshold minimum or greater than the threshold
                           // maximum, the overlay location for that pixel
                           // should be drawn in the overlay color.
                           
                           // First, zero out the array that keeps count of the number of pixels
                           // in each line that fall within the threshold limits.
                           
                           for (int intLine = 0; intLine < lsNumLines; intLine++)
                               lsProfiles.elementAt(index).intensitySampleCount[intLine] = 0;
                           
                           int offset = lsProfiles.elementAt(index).position - (lsProfiles.elementAt(index).width / 2);
                           if (lsNumChans == 1) {
                               for (int intX = 0; intX < lsNumLines; intX++) {
                                   for (int intY = 0; intY < lsProfiles.elementAt(index).width; intY++) {
                                       int pixelIntensity = lsWindow.getImagePlus().getProcessor().getPixel(intX, (offset + intY));
                                       if ((pixelIntensity >= lsProfiles.elementAt(index).thresholdMin) && (pixelIntensity <= lsProfiles.elementAt(index).thresholdMax))
                                           lsProfiles.elementAt(index).intensitySampleCount[intX]++;
                                       else {
                                           // Add this pixel to the overlay
                                           Line lsOverlayLineA = new Line(intX, (offset + intY), intX, (offset + intY));
                                           lsOverlayLineA.setFillColor(lsProfiles.elementAt(index).color);
                                           lsOverlayLineA.setStrokeColor(lsProfiles.elementAt(index).color);
                                           lsImageOverlay.add(lsOverlayLineA);
                                       }
                                   }
                               }
                           }
                           else {
                               if (lsProfiles.elementAt(index).channel == 0) {
                                   for (int intX = 0; intX < lsNumLines; intX++) {
                                       for (int intY = 0; intY < lsProfiles.elementAt(index).width; intY++) {
                                           int pixelIntensity = lsSingleChannelWindow1.getImagePlus().getProcessor().getPixel(intX, (offset + intY));
                                           if ((pixelIntensity >= lsProfiles.elementAt(index).thresholdMin) && (pixelIntensity <= lsProfiles.elementAt(index).thresholdMax))
                                               lsProfiles.elementAt(index).intensitySampleCount[intX]++;
                                           else {
                                               // Add this pixel to the overlay
                                               Line lsOverlayLineA = new Line(intX, (offset + intY), intX, (offset + intY));
                                               lsOverlayLineA.setFillColor(lsProfiles.elementAt(index).color);
                                               lsOverlayLineA.setStrokeColor(lsProfiles.elementAt(index).color);
                                               lsImageOverlay.add(lsOverlayLineA);
                                               Line lsOverlayLine1A = new Line(intX, (offset + intY), intX, (offset + intY));
                                               lsOverlayLine1A.setFillColor(lsProfiles.elementAt(index).color);
                                               lsOverlayLine1A.setStrokeColor(lsProfiles.elementAt(index).color);
                                               lsImageOverlay1.add(lsOverlayLine1A);
                                           }
                                       }
                                   }
                               }
                               if (lsProfiles.elementAt(index).channel == 1) {
                                   for (int intX = 0; intX < lsNumLines; intX++) {
                                       for (int intY = 0; intY < lsProfiles.elementAt(index).width; intY++) {
                                           int pixelIntensity = lsSingleChannelWindow2.getImagePlus().getProcessor().getPixel(intX, (offset + intY));
                                           if ((pixelIntensity >= lsProfiles.elementAt(index).thresholdMin) && (pixelIntensity <= lsProfiles.elementAt(index).thresholdMax))
                                               lsProfiles.elementAt(index).intensitySampleCount[intX]++;
                                           else {
                                               // Add this pixel to the overlay
                                               Line lsOverlayLineA = new Line(intX, (offset + intY), intX, (offset + intY));
                                               lsOverlayLineA.setFillColor(lsProfiles.elementAt(index).color);
                                               lsOverlayLineA.setStrokeColor(lsProfiles.elementAt(index).color);
                                               lsImageOverlay.add(lsOverlayLineA);
                                               Line lsOverlayLine2A = new Line(intX, (offset + intY), intX, (offset + intY));
                                               lsOverlayLine2A.setFillColor(lsProfiles.elementAt(index).color);
                                               lsOverlayLine2A.setStrokeColor(lsProfiles.elementAt(index).color);
                                               lsImageOverlay2.add(lsOverlayLine2A);
                                           }
                                       }
                                   }
                               }
                               if (lsProfiles.elementAt(index).channel == 2) {
                                   for (int intX = 0; intX < lsNumLines; intX++) {
                                       for (int intY = 0; intY < lsProfiles.elementAt(index).width; intY++) {
                                           int pixelIntensity = lsSingleChannelWindow3.getImagePlus().getProcessor().getPixel(intX, (offset + intY));
                                           if ((pixelIntensity >= lsProfiles.elementAt(index).thresholdMin) && (pixelIntensity <= lsProfiles.elementAt(index).thresholdMax))
                                               lsProfiles.elementAt(index).intensitySampleCount[intX]++;
                                           else {
                                               // Add this pixel to the overlay
                                               Line lsOverlayLineA = new Line(intX, (offset + intY), intX, (offset + intY));
                                               lsOverlayLineA.setFillColor(lsProfiles.elementAt(index).color);
                                               lsOverlayLineA.setStrokeColor(lsProfiles.elementAt(index).color);
                                               lsImageOverlay.add(lsOverlayLineA);
                                               Line lsOverlayLine3A = new Line(intX, (offset + intY), intX, (offset + intY));
                                               lsOverlayLine3A.setFillColor(lsProfiles.elementAt(index).color);
                                               lsOverlayLine3A.setStrokeColor(lsProfiles.elementAt(index).color);
                                               lsImageOverlay3.add(lsOverlayLine3A);
                                           }
                                       }
                                   }
                               }
                               if (lsProfiles.elementAt(index).channel == 3) {
                                   for (int intX = 0; intX < lsNumLines; intX++) {
                                       for (int intY = 0; intY < lsProfiles.elementAt(index).width; intY++) {
                                           int pixelIntensity = lsSingleChannelWindow4.getImagePlus().getProcessor().getPixel(intX, (offset + intY));
                                           if ((pixelIntensity >= lsProfiles.elementAt(index).thresholdMin) && (pixelIntensity <= lsProfiles.elementAt(index).thresholdMax))
                                               lsProfiles.elementAt(index).intensitySampleCount[intX]++;
                                           else {
                                               // Add this pixel to the overlay
                                               Line lsOverlayLineA = new Line(intX, (offset + intY), intX, (offset + intY));
                                               lsOverlayLineA.setFillColor(lsProfiles.elementAt(index).color);
                                               lsOverlayLineA.setStrokeColor(lsProfiles.elementAt(index).color);
                                               lsImageOverlay.add(lsOverlayLineA);
                                               Line lsOverlayLine4A = new Line(intX, (offset + intY), intX, (offset + intY));
                                               lsOverlayLine4A.setFillColor(lsProfiles.elementAt(index).color);
                                               lsOverlayLine4A.setStrokeColor(lsProfiles.elementAt(index).color);
                                               lsImageOverlay4.add(lsOverlayLine4A);
                                           }
                                       }
                                   }
                               }
                           }
                       }
                       
                       // All profiles will be displayed in the "composite" image.
                       int offset = (lsProfiles.elementAt(index).width + 2) / 2;
                       Line lsOverlayLineA = new Line(0, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset);
                       lsOverlayLineA.setFillColor(lsProfiles.elementAt(index).color);
                       lsOverlayLineA.setStrokeColor(lsProfiles.elementAt(index).color);
                       Line lsOverlayLineB = new Line(0, lsProfiles.elementAt(index).position - offset, 0, lsProfiles.elementAt(index).position + offset);
                       lsOverlayLineB.setFillColor(lsProfiles.elementAt(index).color);
                       lsOverlayLineB.setStrokeColor(lsProfiles.elementAt(index).color);
                       Line lsOverlayLineC = new Line(0, lsProfiles.elementAt(index).position + offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                       lsOverlayLineC.setFillColor(lsProfiles.elementAt(index).color);
                       lsOverlayLineC.setStrokeColor(lsProfiles.elementAt(index).color);
                       Line lsOverlayLineD = new Line(lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                       lsOverlayLineD.setFillColor(lsProfiles.elementAt(index).color);
                       lsOverlayLineD.setStrokeColor(lsProfiles.elementAt(index).color);
                       lsImageOverlay.add(lsOverlayLineA);
                       lsImageOverlay.add(lsOverlayLineB);
                       lsImageOverlay.add(lsOverlayLineC);
                       lsImageOverlay.add(lsOverlayLineD);
                       if (lsNumChans > 1) {
                           if (lsProfiles.elementAt(index).channel == 0) {
                               Line lsOverlayLine1A = new Line(0, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset);
                               lsOverlayLine1A.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine1A.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine1B = new Line(0, lsProfiles.elementAt(index).position - offset, 0, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine1B.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine1B.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine1C = new Line(0, lsProfiles.elementAt(index).position + offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine1C.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine1C.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine1D = new Line(lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine1D.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine1D.setStrokeColor(lsProfiles.elementAt(index).color);
                               lsImageOverlay1.add(lsOverlayLine1A);
                               lsImageOverlay1.add(lsOverlayLine1B);
                               lsImageOverlay1.add(lsOverlayLine1C);
                               lsImageOverlay1.add(lsOverlayLine1D);
                           }
                           if (lsProfiles.elementAt(index).channel == 1) {
                               Line lsOverlayLine2A = new Line(0, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset);
                               lsOverlayLine2A.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine2A.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine2B = new Line(0, lsProfiles.elementAt(index).position - offset, 0, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine2B.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine2B.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine2C = new Line(0, lsProfiles.elementAt(index).position + offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine2C.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine2C.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine2D = new Line(lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine2D.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine2D.setStrokeColor(lsProfiles.elementAt(index).color);
                               lsImageOverlay2.add(lsOverlayLine2A);
                               lsImageOverlay2.add(lsOverlayLine2B);
                               lsImageOverlay2.add(lsOverlayLine2C);
                               lsImageOverlay2.add(lsOverlayLine2D);
                           }
                           if (lsProfiles.elementAt(index).channel == 2) {
                               Line lsOverlayLine3A = new Line(0, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset);
                               lsOverlayLine3A.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine3A.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine3B = new Line(0, lsProfiles.elementAt(index).position - offset, 0, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine3B.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine3B.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine3C = new Line(0, lsProfiles.elementAt(index).position + offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine3C.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine3C.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine3D = new Line(lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine3D.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine3D.setStrokeColor(lsProfiles.elementAt(index).color);
                               lsImageOverlay3.add(lsOverlayLine3A);
                               lsImageOverlay3.add(lsOverlayLine3B);
                               lsImageOverlay3.add(lsOverlayLine3C);
                               lsImageOverlay3.add(lsOverlayLine3D);
                           }
                           if (lsProfiles.elementAt(index).channel == 3) {
                               Line lsOverlayLine4A = new Line(0, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset);
                               lsOverlayLine4A.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine4A.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine4B = new Line(0, lsProfiles.elementAt(index).position - offset, 0, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine4B.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine4B.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine4C = new Line(0, lsProfiles.elementAt(index).position + offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine4C.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine4C.setStrokeColor(lsProfiles.elementAt(index).color);
                               Line lsOverlayLine4D = new Line(lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position - offset, lsWindow.getImagePlus().getWidth() - 1, lsProfiles.elementAt(index).position + offset);
                               lsOverlayLine4D.setFillColor(lsProfiles.elementAt(index).color);
                               lsOverlayLine4D.setStrokeColor(lsProfiles.elementAt(index).color);
                               lsImageOverlay4.add(lsOverlayLine4A);
                               lsImageOverlay4.add(lsOverlayLine4B);
                               lsImageOverlay4.add(lsOverlayLine4C);
                               lsImageOverlay4.add(lsOverlayLine4D);
                           }
//                       }
                   }
               }
               
               // Add the overlays to the appropriate windows.
               lsWindow.getImagePlus().setOverlay(lsImageOverlay);
               lsWindow.getImagePlus().draw();
               
               if (lsNumChans > 1) {
                   lsSingleChannelWindow1.getImagePlus().setOverlay(lsImageOverlay1);
                   lsSingleChannelWindow1.getImagePlus().draw();
                   lsSingleChannelWindow2.getImagePlus().setOverlay(lsImageOverlay2);
                   lsSingleChannelWindow2.getImagePlus().draw();
                   if (lsNumChans > 2) {
                       lsSingleChannelWindow3.getImagePlus().setOverlay(lsImageOverlay3);
                       lsSingleChannelWindow3.getImagePlus().draw();
                   }
                   if (lsNumChans > 3) {
                       lsSingleChannelWindow4.getImagePlus().setOverlay(lsImageOverlay4);
                       lsSingleChannelWindow4.getImagePlus().draw();
                   }
               }
               
               // Next, update the linescan trace display
               DrawLinescanTrace();
               
               // Generate the Profile data and display it.
               
               // Need to create new plot windows in order to 'erase' any previous data plots
               PreparePlotWindows();
               
               boolean computeAverage = true;
               if (jComboBoxIntensityMethod.getSelectedIndex() == 0)
                   computeAverage = true;
               else
                   computeAverage = false;
               
               int numPlots = 0;
               int numPlotsCh1 = 0;
               int numPlotsCh2 = 0;
               int numPlotsCh3 = 0;
               int numPlotsCh4 = 0;
               indexes = listProfileList.getSelectedIndexes();
               
               Vector<LSProfileProcessing> profilesToProcess = new Vector<LSProfileProcessing>();
               for (int i = 0; i < indexes.length; i++) {
                   LSProfileProcessing profProc = new LSProfileProcessing();
                   profProc.profile = indexes[i];
                   profProc.display = true;
                   profilesToProcess.add(profProc);
               }
               for (int i = 0; i < functionProfiles.size(); i++) {
                   LSProfileProcessing profProc = new LSProfileProcessing();
                   profProc.profile = functionProfiles.elementAt(i).intValue();
                   profProc.display = false;
                   profilesToProcess.add(profProc);
               }
               
               for (int profileIndex = 0; profileIndex < profilesToProcess.size(); profileIndex++) {
               //for (int profileIndex = 0; profileIndex < indexes.length; profileIndex++) {
                   int profileNum = profilesToProcess.elementAt(profileIndex).profile;
                   boolean displayProfile = profilesToProcess.elementAt(profileIndex).display;
                   
                   if (displayProfile)
                       numPlots++;
                   
                   double[] plotTime = new double[lsNumLines];
                   double[] plotData = new double[lsNumLines];
                   int[] intensityData = new int[lsNumLines];
                   for (int i = 0; i < lsNumLines; i++)
                       intensityData[i] = 0;
                   // Generate the time data for the plot
                   // The first time value needs to be offset from "0" by the "retrace time" and
                   // the number of pixels multiplied by the dwell time to the profile position.
                   double retraceTime = lsScanlinePeriod - (lsDwellTime * lsPixelsPerLine);
                   if (lsType == LinescanTypeLine)
                        plotTime[0] = (lsDwellTime * (lsStartPixelX + lsProfiles.elementAt(profileNum).position)) + retraceTime;
                   else
                        plotTime[0] = (lsDwellTime * lsProfiles.elementAt(profileNum).position) + retraceTime;
                   lsProfiles.elementAt(profileNum).time[0] = plotTime[0];
                   for (int i = 1; i < lsNumLines; i++) {
                       plotTime[i] = plotTime[i - 1] + lsScanlinePeriod;
                       lsProfiles.elementAt(profileNum).time[i] = plotTime[i];
                   }

                   // The generation of the plot data is dependent upon the channel associated with the profile
                   // as well as how many channels were part of the linescan acquisition.
                   if (lsNumChans == 1) {
                       if (lsProfiles.elementAt(profileNum).width == 1) {
                            ImagePlus ip = new ImagePlus();
                            ip = lsWindow.getImagePlus();
                            ip.getProcessor().getRow(0, lsProfiles.elementAt(profileNum).position, intensityData, lsNumLines);
                       }
                       else {
                           // Retrieve each row that makes up the total width of the profile and 
                           // add them together.
                           int[] tempData = new int[lsNumLines];
                           int currentPosition = lsProfiles.elementAt(profileNum).position - ((lsProfiles.elementAt(profileNum).width - 1) / 2);
                           ImagePlus ip = new ImagePlus();
                           ip = lsWindow.getImagePlus();
                           for (int i = 0; i < lsProfiles.elementAt(profileNum).width; i++){
                                ip.getProcessor().getRow(0, currentPosition, tempData, lsNumLines);
                                currentPosition++;
                                for (int j = 0; j < tempData.length; j++) {
                                    if (lsProfiles.elementAt(profileNum).threshold) {
                                        // Data is to be checked for the 'threshold' limits.
                                        if ((tempData[j] >= lsProfiles.elementAt(profileNum).thresholdMin) && (tempData[j] <= lsProfiles.elementAt(profileNum).thresholdMax))
                                            intensityData[j] += tempData[j];
                                    }
                                    else
                                        intensityData[j] += tempData[j];
                                }
                           }

                           // Loop through the data one additional time and divide by the profile width
                           // to get the desired "average" value.
                           if (computeAverage) {
                                for (int i = 0; i < lsNumLines; i++) {
                                    if (lsProfiles.elementAt(profileNum).threshold) {
                                        if (lsProfiles.elementAt(profileNum).intensitySampleCount[i] < 1)
                                            intensityData[i] = 0;
                                        else
                                            intensityData[i] = intensityData[i] /= lsProfiles.elementAt(profileNum).intensitySampleCount[i];
                                    }
                                    else
                                        intensityData[i] /= lsProfiles.elementAt(profileNum).width;
                                }
                           }
                       }
                       
                       for (int i = 0; i < lsNumLines; i++) {
                          lsProfiles.elementAt(profileNum).intensity[i] = ((double)intensityData[i]);
                       }
                   
                       // Update the plot display data for the profile specific plot window.
                       double yMin = 0.0;
                       double yMax = 1.0;
                       String chanName = "";
                       if (lsNumChans == 1) {
                            yMin = lsYMin;
                            if (computeAverage)
                                yMax = lsYMax;
                            else
                                yMax = lsYMax * lsProfiles.elementAt(profileNum).width;
//                            switch (lsProfiles.elementAt(profileNum).channel) {
//                                case 0:
//                                    yMin = lsYMin1;
//                                    if (computeAverage)                                    
//                                        yMax = lsYMax1;
//                                    else
//                                        yMax = lsYMax1 * lsProfiles.elementAt(profileNum).width;
//                                    chanName = lsCh1Label;
//                                    break;
//                                case 1:
//                                    yMin = lsYMin2;
//                                    if (computeAverage)                                    
//                                        yMax = lsYMax2;
//                                    else
//                                        yMax = lsYMax2 * lsProfiles.elementAt(profileNum).width;
//                                    chanName = lsCh2Label;
//                                    break;
//                                case 2:
//                                    yMin = lsYMin3;
//                                    if (computeAverage)                                    
//                                        yMax = lsYMax3;
//                                    else
//                                        yMax = lsYMax3 * lsProfiles.elementAt(profileNum).width;
//                                    chanName = lsCh3Label;
//                                    break;
//                                case 3:
//                                    yMin = lsYMin4;
//                                    if (computeAverage)                                    
//                                        yMax = lsYMax4;
//                                    else
//                                        yMax = lsYMax4 * lsProfiles.elementAt(profileNum).width;
//                                    chanName = lsCh4Label;
//                                    break;
//                            }
//                       }
//                       else {
//                            switch (lsProfiles.elementAt(profileNum).channel) {
//                                case 0:
//                                    yMin = lsYMin1;
//                                    if (computeAverage)                                    
//                                        yMax = lsYMax1;
//                                    else
//                                        yMax = lsYMax1 * lsProfiles.elementAt(profileNum).width;
//                                    chanName = lsCh1Label;
//                                    break;
//                                case 1:
//                                    yMin = lsYMin2;
//                                    if (computeAverage)                                    
//                                        yMax = lsYMax2;
//                                    else
//                                        yMax = lsYMax2 * lsProfiles.elementAt(profileNum).width;
//                                    chanName = lsCh2Label;
//                                    break;
//                                case 2:
//                                    yMin = lsYMin3;
//                                    if (computeAverage)                                    
//                                        yMax = lsYMax3;
//                                    else
//                                        yMax = lsYMax3 * lsProfiles.elementAt(profileNum).width;
//                                    chanName = lsCh3Label;
//                                    break;
//                                case 3:
//                                    yMin = lsYMin4;
//                                    if (computeAverage)                                    
//                                        yMax = lsYMax4;
//                                    else
//                                        yMax = lsYMax4 * lsProfiles.elementAt(profileNum).width;
//                                    chanName = lsCh4Label;
//                                    break;
//                            }
                       }
                       if (displayProfile) {
                           lsProfiles.elementAt(profileNum).plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (profileNum + 1) + ":" + chanName, "Time (ms)", "Intensity");
                           lsProfiles.elementAt(profileNum).plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
                           lsProfiles.elementAt(profileNum).plotWindow.setColor(lsProfiles.elementAt(profileNum).color);
                           lsProfiles.elementAt(profileNum).plotWindow.addPoints(lsProfiles.elementAt(profileNum).time, lsProfiles.elementAt(profileNum).intensity, PlotWindow.LINE);
                           lsProfiles.elementAt(profileNum).plotWindow.draw();
                           lsProfiles.elementAt(profileNum).imagePlusPlotWindow.setProcessor(null, lsProfiles.elementAt(profileNum).plotWindow.getProcessor());
                       }
                   }
                   else {
                       if (lsProfiles.elementAt(profileNum).channel == 0) {
                           numPlotsCh1++;
                           if (lsProfiles.elementAt(profileNum).width == 1) {
                               ImagePlus ip = new ImagePlus();
                               ip = lsSingleChannelWindow1.getImagePlus();
                               ip.getProcessor().getRow(0, lsProfiles.elementAt(profileNum).position, intensityData, lsNumLines);
                           }
                           else {
                               // Retrieve each row that makes up the total width of the profile and 
                               // add them together.
                               int[] tempData = new int[lsNumLines];
                               int currentPosition = lsProfiles.elementAt(profileNum).position - ((lsProfiles.elementAt(profileNum).width - 1) / 2);
                               ImagePlus ip = new ImagePlus();
                               ip = lsSingleChannelWindow1.getImagePlus();
                               for (int i = 0; i < lsProfiles.elementAt(profileNum).width; i++){
                                    ip.getProcessor().getRow(0, currentPosition, tempData, lsNumLines);
                                    currentPosition++;
                                    for (int j = 0; j < tempData.length; j++) {
                                        if (lsProfiles.elementAt(profileNum).threshold) {
                                            // Data is to be checked for the 'threshold' limits.
                                            if ((tempData[j] >= lsProfiles.elementAt(profileNum).thresholdMin) && (tempData[j] <= lsProfiles.elementAt(profileNum).thresholdMax))
                                                intensityData[j] += tempData[j];
                                        }
                                        else
                                            intensityData[j] += tempData[j];
                                    }
                               }

                               // Loop through the data one additional time and divide by the profile width
                               // to get the desired "average" value.
                               if (computeAverage) {
                                    for (int i = 0; i < lsNumLines; i++) {
                                        if (lsProfiles.elementAt(profileNum).threshold) {
                                            if (lsProfiles.elementAt(profileNum).intensitySampleCount[i] < 1)
                                                intensityData[i] = 0;
                                            else
                                                intensityData[i] = intensityData[i] /= lsProfiles.elementAt(profileNum).intensitySampleCount[i];
                                        }
                                        else
                                            intensityData[i] /= lsProfiles.elementAt(profileNum).width;
                                    }
                               }
                           }  
                       }
                       else if (lsProfiles.elementAt(profileNum).channel == 1) {
                           numPlotsCh2++;
                           if (lsProfiles.elementAt(profileNum).width == 1) {
                               ImagePlus ip = new ImagePlus();
                               ip = lsSingleChannelWindow2.getImagePlus();
                               ip.getProcessor().getRow(0, lsProfiles.elementAt(profileNum).position, intensityData, lsNumLines);
                           }
                           else {
                               // Retrieve each row that makes up the total width of the profile and 
                               // add them together.
                               int[] tempData = new int[lsNumLines];
                               int currentPosition = lsProfiles.elementAt(profileNum).position - ((lsProfiles.elementAt(profileNum).width - 1) / 2);
                               ImagePlus ip = new ImagePlus();
                               ip = lsSingleChannelWindow2.getImagePlus();
                               for (int i = 0; i < lsProfiles.elementAt(profileNum).width; i++){
                                    ip.getProcessor().getRow(0, currentPosition, tempData, lsNumLines);
                                    currentPosition++;
                                    for (int j = 0; j < tempData.length; j++) {
                                        if (lsProfiles.elementAt(profileNum).threshold) {
                                            // Data is to be checked for the 'threshold' limits.
                                            if ((tempData[j] >= lsProfiles.elementAt(profileNum).thresholdMin) && (tempData[j] <= lsProfiles.elementAt(profileNum).thresholdMax))
                                                intensityData[j] += tempData[j];
                                        }
                                        else
                                            intensityData[j] += tempData[j];
                                    }
                               }

                               // Loop through the data one additional time and divide by the profile width
                               // to get the desired "average" value.
                               if (computeAverage) {
                                    for (int i = 0; i < lsNumLines; i++) {
                                        if (lsProfiles.elementAt(profileNum).threshold) {
                                            if (lsProfiles.elementAt(profileNum).intensitySampleCount[i] < 1)
                                                intensityData[i] = 0;
                                            else
                                                intensityData[i] = intensityData[i] /= lsProfiles.elementAt(profileNum).intensitySampleCount[i];
                                        }
                                        else
                                            intensityData[i] /= lsProfiles.elementAt(profileNum).width;
                                    }
                               }
                           }  
                       }
                       else if (lsProfiles.elementAt(profileNum).channel == 2) {
                           numPlotsCh3++;
                           if (lsProfiles.elementAt(profileNum).width == 1) {
                               ImagePlus ip = new ImagePlus();
                               ip = lsSingleChannelWindow3.getImagePlus();
                               ip.getProcessor().getRow(0, lsProfiles.elementAt(profileNum).position, intensityData, lsNumLines);
                           }
                           else {
                               // Retrieve each row that makes up the total width of the profile and 
                               // add them together.
                               int[] tempData = new int[lsNumLines];
                               int currentPosition = lsProfiles.elementAt(profileNum).position - ((lsProfiles.elementAt(profileNum).width - 1) / 2);
                               ImagePlus ip = new ImagePlus();
                               ip = lsSingleChannelWindow3.getImagePlus();
                               for (int i = 0; i < lsProfiles.elementAt(profileNum).width; i++){
                                    ip.getProcessor().getRow(0, currentPosition, tempData, lsNumLines);
                                    currentPosition++;
                                    for (int j = 0; j < tempData.length; j++) {
                                        if (lsProfiles.elementAt(profileNum).threshold) {
                                            // Data is to be checked for the 'threshold' limits.
                                            if ((tempData[j] >= lsProfiles.elementAt(profileNum).thresholdMin) && (tempData[j] <= lsProfiles.elementAt(profileNum).thresholdMax))
                                                intensityData[j] += tempData[j];
                                        }
                                        else
                                            intensityData[j] += tempData[j];
                                    }
                               }

                               // Loop through the data one additional time and divide by the profile width
                               // to get the desired "average" value.
                                if (computeAverage) {
                                    for (int i = 0; i < lsNumLines; i++) {
                                        if (lsProfiles.elementAt(profileNum).threshold) {
                                            if (lsProfiles.elementAt(profileNum).intensitySampleCount[i] < 1)
                                                intensityData[i] = 0;
                                            else
                                                intensityData[i] = intensityData[i] /= lsProfiles.elementAt(profileNum).intensitySampleCount[i];
                                        }
                                        else
                                            intensityData[i] /= lsProfiles.elementAt(profileNum).width;
                                    }
                               }
                           }  
                       }
                       else if (lsProfiles.elementAt(profileNum).channel == 3) {
                           numPlotsCh4++;
                           if (lsProfiles.elementAt(profileNum).width == 1) {
                               ImagePlus ip = new ImagePlus();
                               ip = lsSingleChannelWindow4.getImagePlus();
                               ip.getProcessor().getRow(0, lsProfiles.elementAt(profileNum).position, intensityData, lsNumLines);
                           }
                           else {
                               // Retrieve each row that makes up the total width of the profile and 
                               // add them together.
                               int[] tempData = new int[lsNumLines];
                               int currentPosition = lsProfiles.elementAt(profileNum).position - ((lsProfiles.elementAt(profileNum).width - 1) / 2);
                               ImagePlus ip = new ImagePlus();
                               ip = lsSingleChannelWindow4.getImagePlus();
                               for (int i = 0; i < lsProfiles.elementAt(profileNum).width; i++){
                                    ip.getProcessor().getRow(0, currentPosition, tempData, lsNumLines);
                                    currentPosition++;
                                    for (int j = 0; j < tempData.length; j++) {
                                        if (lsProfiles.elementAt(profileNum).threshold) {
                                            // Data is to be checked for the 'threshold' limits.
                                            if ((tempData[j] >= lsProfiles.elementAt(profileNum).thresholdMin) && (tempData[j] <= lsProfiles.elementAt(profileNum).thresholdMax))
                                                intensityData[j] += tempData[j];
                                        }
                                        else
                                            intensityData[j] += tempData[j];
                                    }
                               }

                               // Loop through the data one additional time and divide by the profile width
                               // to get the desired "average" value.
                               if (computeAverage) {
                                    for (int i = 0; i < lsNumLines; i++) {
                                        if (lsProfiles.elementAt(profileNum).threshold) {
                                            if (lsProfiles.elementAt(profileNum).intensitySampleCount[i] < 1)
                                                intensityData[i] = 0;
                                            else
                                                intensityData[i] = intensityData[i] /= lsProfiles.elementAt(profileNum).intensitySampleCount[i];
                                        }
                                        else
                                            intensityData[i] /= lsProfiles.elementAt(profileNum).width;
                                    }
                               }
                           }  
                       }
                       
                       for (int i = 0; i < lsNumLines; i++) {
                          lsProfiles.elementAt(profileNum).intensity[i] = ((double)intensityData[i]);
                       }
                       
                       // Update the plot display data for the profile specific plot window.
                       //if (displayProfile) {
                       double yMin = 0.0;
                       double yMax = 1.0;
                       String chanName = "";
                       if (lsNumChans == 1) {
                            yMin = lsYMin;
                            yMax = lsYMax;
                            switch (lsProfiles.elementAt(profileNum).channel) {
                                case 0:
                                    yMin = lsYMin1;
                                    if (computeAverage)
                                        yMax = lsYMax1;
                                    else
                                        yMax = lsYMax1 * lsProfiles.elementAt(profileNum).width;
                                    chanName = lsCh1Label;
                                    break;
                                case 1:
                                    yMin = lsYMin2;
                                    if (computeAverage)
                                        yMax = lsYMax2;
                                    else
                                        yMax = lsYMax2 * lsProfiles.elementAt(profileNum).width;
                                    chanName = lsCh2Label;
                                    break;
                                case 2:
                                    yMin = lsYMin3;
                                    if (computeAverage)
                                        yMax = lsYMax3;
                                    else
                                        yMax = lsYMax3 * lsProfiles.elementAt(profileNum).width;
                                    chanName = lsCh3Label;
                                    break;
                                case 3:
                                    yMin = lsYMin4;
                                    if (computeAverage)
                                        yMax = lsYMax4;
                                    else
                                        yMax = lsYMax4 * lsProfiles.elementAt(profileNum).width;
                                    chanName = lsCh4Label;
                                    break;
                            }
                        }
                        else {
                            switch (lsProfiles.elementAt(profileNum).channel) {
                                case 0:
                                    yMin = lsYMin1;
                                    if (computeAverage)
                                        yMax = lsYMax1;
                                    else
                                        yMax = lsYMax1 * lsProfiles.elementAt(profileNum).width;
                                    chanName = lsCh1Label;
                                    break;
                                case 1:
                                    yMin = lsYMin2;
                                    if (computeAverage)
                                        yMax = lsYMax2;
                                    else
                                        yMax = lsYMax2 * lsProfiles.elementAt(profileNum).width;
                                    chanName = lsCh2Label;
                                    break;
                                case 2:
                                    yMin = lsYMin3;
                                    if (computeAverage)
                                        yMax = lsYMax3;
                                    else
                                        yMax = lsYMax3 * lsProfiles.elementAt(profileNum).width;
                                    chanName = lsCh3Label;
                                    break;
                                case 3:
                                    yMin = lsYMin4;
                                    if (computeAverage)
                                        yMax = lsYMax4;
                                    else
                                        yMax = lsYMax4 * lsProfiles.elementAt(profileNum).width;
                                    chanName = lsCh4Label;
                                    break;
                            }
                       }
                       if (displayProfile) {
                           lsProfiles.elementAt(profileNum).plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (profileNum + 1) + ":" + chanName, "Time (ms)", "Intensity");
                           lsProfiles.elementAt(profileNum).plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
                           lsProfiles.elementAt(profileNum).plotWindow.setColor(lsProfiles.elementAt(profileNum).color);
                           lsProfiles.elementAt(profileNum).plotWindow.addPoints(lsProfiles.elementAt(profileNum).time, lsProfiles.elementAt(profileNum).intensity, PlotWindow.LINE);
                           lsProfiles.elementAt(profileNum).plotWindow.draw();
                           lsProfiles.elementAt(profileNum).imagePlusPlotWindow.setProcessor(null, lsProfiles.elementAt(profileNum).plotWindow.getProcessor());
                       }
                   }

                   // Copy the intensityData array into the plotData array.
                   for (int i = 0; i < lsNumLines; i++) {
                       plotData[i] = intensityData[i];
                   }
                   
                   if (displayProfile) {
                       if (!lsProfilesInSeparateWindows) {
                           // Display the profiles with one window per channel

                           if (lsPlotWindow != null) {
                               lsPlotWindow.setColor(lsProfiles.elementAt(profileNum).color);
                               lsPlotWindow.addPoints(plotTime, plotData, PlotWindow.LINE);
                               lsPlotWindow.draw();
                           }

                           if ((numPlotsCh1 > 0) && (lsPlotSingleChannelWindow1 != null)) {
                               lsPlotSingleChannelWindow1.setColor(lsProfiles.elementAt(profileNum).color);
                               lsPlotSingleChannelWindow1.addPoints(plotTime, plotData, PlotWindow.LINE);
                               lsPlotSingleChannelWindow1.draw();
                           }

                           if ((numPlotsCh2 > 0) && (lsPlotSingleChannelWindow2 != null)) {
                               lsPlotSingleChannelWindow2.setColor(lsProfiles.elementAt(profileNum).color);
                               lsPlotSingleChannelWindow2.addPoints(plotTime, plotData, PlotWindow.LINE);
                               lsPlotSingleChannelWindow2.draw();
                           }

                           if ((numPlotsCh3 > 0) && (lsPlotSingleChannelWindow3 != null)) {
                               lsPlotSingleChannelWindow3.setColor(lsProfiles.elementAt(profileNum).color);
                               lsPlotSingleChannelWindow3.addPoints(plotTime, plotData, PlotWindow.LINE);
                               lsPlotSingleChannelWindow3.draw();
                           }

                           if ((numPlotsCh4 > 0) && (lsPlotSingleChannelWindow4 != null)) {
                               lsPlotSingleChannelWindow4.setColor(lsProfiles.elementAt(profileNum).color);
                               lsPlotSingleChannelWindow4.addPoints(plotTime, plotData, PlotWindow.LINE);
                               lsPlotSingleChannelWindow4.draw();
                           }
                       }
                       else
                       {
                           // Display the profiles with one window per profile
                           // Nothing to do here at this time.
                       }
                   }
               }
               
               if (lsProfilesInSeparateWindows) {
                   for (int i = 0; i < lsProfiles.size(); i++) {
                       boolean profileSelected = false;
                       for (int profileIndex = 0; profileIndex < indexes.length; profileIndex++) {
                           if (i == indexes[profileIndex])
                               profileSelected = true;
                       }
                       if (profileSelected)
                           lsProfiles.elementAt(i).imagePlusPlotWindow.show();
                       else
                           lsProfiles.elementAt(i).imagePlusPlotWindow.hide();
                   }
               }
               else {
                   for (int i = 0; i < lsProfiles.size(); i++)
                       lsProfiles.elementAt(i).imagePlusPlotWindow.hide();
               }
               
               if (!lsProfilesInSeparateWindows) {
                   if (numPlots > 0) {
                        if (lsImagePlusPlotWindow == null) {
                            lsImagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber, lsPlotWindow.getProcessor());
                            lsImagePlusPlotWindow.show();
                        }
                        else {
                            lsImagePlusPlotWindow.setProcessor(null, lsPlotWindow.getProcessor());
                            lsImagePlusPlotWindow.show();
                        }
                   }
                   else {
                        if (lsImagePlusPlotWindow != null)
                            lsImagePlusPlotWindow.hide();
                   }

                   if (numPlotsCh1 > 0) {
                        if (lsImagePlusPlotSingleChannelWindow1 == null) {
                            lsImagePlusPlotSingleChannelWindow1 = new ImagePlus(WindowI1 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[0] + " Prairie Sequence " + lsSequenceNumber, lsPlotSingleChannelWindow1.getProcessor());
                            lsImagePlusPlotSingleChannelWindow1.show();
                        }
                        else {
                            lsImagePlusPlotSingleChannelWindow1.setProcessor(null, lsPlotSingleChannelWindow1.getProcessor());
                            lsImagePlusPlotSingleChannelWindow1.show();
                        }
                   }
                   else {
                        if (lsImagePlusPlotSingleChannelWindow1 != null)
                            lsImagePlusPlotSingleChannelWindow1.hide();
                   }

                   if (numPlotsCh2 > 0) {
                        if (lsImagePlusPlotSingleChannelWindow2 == null) {
                            lsImagePlusPlotSingleChannelWindow2 = new ImagePlus(WindowI2 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[1] + " Prairie Sequence " + lsSequenceNumber, lsPlotSingleChannelWindow2.getProcessor());
                            lsImagePlusPlotSingleChannelWindow2.show();
                        }
                        else {
                            lsImagePlusPlotSingleChannelWindow2.setProcessor(null, lsPlotSingleChannelWindow2.getProcessor());
                            lsImagePlusPlotSingleChannelWindow2.show();
                        }
                   }
                   else {
                        if (lsImagePlusPlotSingleChannelWindow2 != null)
                            lsImagePlusPlotSingleChannelWindow2.hide();
                   }

                   if (numPlotsCh3 > 0) {
                        if (lsImagePlusPlotSingleChannelWindow3 == null) {
                            lsImagePlusPlotSingleChannelWindow3 = new ImagePlus(WindowI3 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[2] + " Prairie Sequence " + lsSequenceNumber, lsPlotSingleChannelWindow3.getProcessor());
                            lsImagePlusPlotSingleChannelWindow3.show();
                        }
                        else {
                            lsImagePlusPlotSingleChannelWindow3.setProcessor(null, lsPlotSingleChannelWindow3.getProcessor());
                            lsImagePlusPlotSingleChannelWindow3.show();
                        }
                   }
                   else {
                        if (lsImagePlusPlotSingleChannelWindow3 != null)
                            lsImagePlusPlotSingleChannelWindow3.hide();
                   }

                   if (numPlotsCh4 > 0) {
                        if (lsImagePlusPlotSingleChannelWindow4 == null) {
                            lsImagePlusPlotSingleChannelWindow4 = new ImagePlus(WindowI4 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[3] + " Prairie Sequence " + lsSequenceNumber, lsPlotSingleChannelWindow4.getProcessor());
                            lsImagePlusPlotSingleChannelWindow4.show();
                        }
                        else {
                            lsImagePlusPlotSingleChannelWindow4.setProcessor(null, lsPlotSingleChannelWindow4.getProcessor());
                            lsImagePlusPlotSingleChannelWindow4.show();
                        }
                   }
                   else {
                        if (lsImagePlusPlotSingleChannelWindow4 != null)
                            lsImagePlusPlotSingleChannelWindow4.hide();
                   }
               }
               else {
                    if (lsImagePlusPlotWindow != null)
                        lsImagePlusPlotWindow.hide();
                    if (lsImagePlusPlotSingleChannelWindow1 != null)
                        lsImagePlusPlotSingleChannelWindow1.hide();
                    if (lsImagePlusPlotSingleChannelWindow2 != null)
                        lsImagePlusPlotSingleChannelWindow2.hide();
                    if (lsImagePlusPlotSingleChannelWindow3 != null)
                        lsImagePlusPlotSingleChannelWindow3.hide();
                    if (lsImagePlusPlotSingleChannelWindow4 != null)
                        lsImagePlusPlotSingleChannelWindow4.hide();
               }
               
               // Automatically save the profile definitions so that they can be loaded again
               // if the operator decides to review this data.
               WriteProfileSettings();
               
               // create a script engine manager
               ScriptEngineManager factory = new ScriptEngineManager();
               // create a JavaScript engine
               ScriptEngine engine = factory.getEngineByName("JavaScript");

               // Perform the function calculations and display for the
               // profile functions.
                
               functionIndexes = listProfileFunctionList.getSelectedIndexes();
               
               for (int functionIndex = 0; functionIndex < functionIndexes.length; functionIndex++) {
                   double[] plotTime = new double[lsNumLines];
                   double[] plotData = new double[lsNumLines];
                       
                   // Can't really fine tune the timing here like the profiles since we might be
                   // comparing signals between two different profiles and so on.
                   double retraceTime = lsScanlinePeriod - (lsDwellTime * lsPixelsPerLine);
                   if (lsType == LinescanTypeLine)
                        plotTime[0] = (lsDwellTime * lsStartPixelX) + retraceTime;
                   else
                        plotTime[0] = retraceTime;
                   lsFunctions.elementAt(functionIndexes[functionIndex]).time[0] = plotTime[0];
                   for (int i = 1; i < lsNumLines; i++) {
                       plotTime[i] = plotTime[i - 1] + lsScanlinePeriod;
                       lsFunctions.elementAt(functionIndexes[functionIndex]).time[i] = plotTime[i];
                   }
                   
                   // Parse the function string.
                   lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing = ParseExpression(lsFunctions.elementAt(functionIndexes[functionIndex]).functionExpression);
                   
                   // Loop through the "functionProcessing" elements and make sure that any defined
                   // profile numbers exist in the current list of profiles.  If not, mark the function
                   // as invalid and set all values to 0.
                   for (int i = 0; i < lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.size(); i++) {
                       if ((lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.elementAt(i) == 1) || (lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.elementAt(i) == 4)) {
                           // Check the profile number for validity
                           int profileNumber = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.profileNumber.elementAt(i) - 1;
                           if ((profileNumber < 0) || (profileNumber >= lsProfiles.size())) {
                               lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.validString = false;
                           }
                       }
                       if (!lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.validString) {
                           for (int j = 0; j < lsNumLines; j++)
                               plotData[j] = 0.0;
                       }
                   }
                   
                   // Process the function and generate the plot data
                   if (lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.validString) {
                       // Loop through the various components and create the final string for
                       // the JavaScript analysis.
                       int profileNum = 0;
                       int offset = 0;
                       int frameNumber = 0;
                       boolean useOffset = false;
                       boolean useFrameNumber = false;
                       String functionString = "";
                       
                       for (int lineCount = 0; lineCount < lsNumLines; lineCount++) {
                           functionString = "";
                           for (int i = 0; i < lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.size(); i++) {
                               switch (lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.elementAt(i)) {
                                   case 0: // String element
                                       functionString += lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.element.elementAt(i);
                                       break;
                                   case 1: // Profile number element
                                       profileNum = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.profileNumber.elementAt(i) - 1;
                                       offset = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.offset.elementAt(i);
                                       frameNumber = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.frameNumber.elementAt(i) - 1;
                                       useOffset = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useOffset.elementAt(i);
                                       useFrameNumber = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useFrameNumber.elementAt(i);
                                       if (useOffset) {
                                           // Current linescan intentisty value shifted by the "offset" value
                                           // Make sure that the applied "offset" still results in a valid line number.
                                           int lineIndex = lineCount + offset;
                                           if (lineIndex < 0) lineIndex = 0;
                                           if (lineIndex >= lsNumLines) lineIndex = lsNumLines - 1;
                                           functionString += lsProfiles.elementAt(profileNum).intensity[lineIndex];
                                       }
                                       else if (useFrameNumber) {
                                           // Absolute linescan intensity from line specified by "frameNumber"
                                           // Make sure that the specified line number is valid.
                                           int lineIndex = frameNumber;
                                           if (lineIndex < 0) lineIndex = 0;
                                           if (lineIndex >= lsNumLines) lineIndex = lsNumLines - 1;
                                           functionString += lsProfiles.elementAt(profileNum).intensity[lineIndex];
                                       }
                                       else {
                                           // Current linescan intentisty value
                                           functionString += lsProfiles.elementAt(profileNum).intensity[lineCount];
                                       }
                                       break;
                                   case 2: // Timestamp element
                                       profileNum = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.profileNumber.elementAt(i) - 1;
                                       offset = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.offset.elementAt(i);
                                       frameNumber = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.frameNumber.elementAt(i) - 1;
                                       useOffset = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useOffset.elementAt(i);
                                       useFrameNumber = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useFrameNumber.elementAt(i);
                                       if (useOffset) {
                                           // Current linescan timestamp value shifted by the "offset" value
                                           // Make sure that the applied "offset" still results in a valid line number.
                                           int lineIndex = lineCount + offset;
                                           if (lineIndex < 0) lineIndex = 0;
                                           if (lineIndex >= lsNumLines) lineIndex = lsNumLines - 1;
                                           functionString += lsProfiles.elementAt(profileNum).time[lineIndex];
                                       }
                                       else if (useFrameNumber) {
                                           // Absolute linescan timestamp from line specified by "frameNumber"
                                           // Make sure that the specified line number is valid.
                                           int lineIndex = frameNumber;
                                           if (lineIndex < 0) lineIndex = 0;
                                           if (lineIndex >= lsNumLines) lineIndex = lsNumLines - 1;
                                           functionString += lsProfiles.elementAt(profileNum).time[lineIndex];
                                       }
                                       else {
                                           // Current linescan timestamp value
                                           functionString += lsProfiles.elementAt(profileNum).time[lineCount];
                                       }
                                       break;
                                   case 3: // Frame number
                                       functionString += lineCount;
                                       break;
                                   case 4: // "Average" value from entire profile or part of a profile
                                       profileNum = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.profileNumber.elementAt(i) - 1;
                                       offset = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.offset.elementAt(i) - 1;
                                       frameNumber = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.frameNumber.elementAt(i) - 1;
                                       useOffset = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useOffset.elementAt(i);
                                       useFrameNumber = lsFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useFrameNumber.elementAt(i);
                                       if (useFrameNumber) {
                                          // Average value to be computed from a segment of the profile
                                           double profileSum = 0;
                                           // Make sure the specified limits to use for the averaging fall within the 
                                           // range of the data.
                                           if (frameNumber < 0)
                                               frameNumber = 0;
                                           if (frameNumber > lsProfiles.elementAt(profileNum).intensity.length)
                                               frameNumber = lsProfiles.elementAt(profileNum).intensity.length;
                                           if (offset < 0)
                                               offset = 0;
                                           if (offset > lsProfiles.elementAt(profileNum).intensity.length)
                                               offset = lsProfiles.elementAt(profileNum).intensity.length;
                                           for (int j = frameNumber; j < offset; j++)
                                               profileSum += lsProfiles.elementAt(profileNum).intensity[j];
                                           functionString += (profileSum / (offset - frameNumber + 1));
                                       }
                                       else {
                                           // Average value to be computed from the entire profile
                                           double profileSum = 0;
                                           for (int j = 0; j < lsProfiles.elementAt(profileNum).intensity.length; j++)
                                               profileSum += lsProfiles.elementAt(profileNum).intensity[j];
                                           functionString += (profileSum / lsProfiles.elementAt(profileNum).intensity.length);
                                       }
                                       break;
                               }
                           }
                           //IJ.showMessage("function = " + functionString);
                           try {
                               lsFunctions.elementAt(functionIndexes[functionIndex]).intensity[lineCount] = (Double) engine.eval(functionString);
                               if (lsFunctions.elementAt(functionIndexes[functionIndex]).intensity[lineCount] > lsFunctions.elementAt(functionIndexes[functionIndex]).intensityMax)
                                   lsFunctions.elementAt(functionIndexes[functionIndex]).intensityMax = lsFunctions.elementAt(functionIndexes[functionIndex]).intensity[lineCount];
                               if (lsFunctions.elementAt(functionIndexes[functionIndex]).intensity[lineCount] < lsFunctions.elementAt(functionIndexes[functionIndex]).intensityMin)
                                   lsFunctions.elementAt(functionIndexes[functionIndex]).intensityMin = lsFunctions.elementAt(functionIndexes[functionIndex]).intensity[lineCount];
                               plotData[lineCount] = lsFunctions.elementAt(functionIndexes[functionIndex]).intensity[lineCount];
                           } catch (javax.script.ScriptException exc) {
                               IJ.showMessage("JavaScript error: \n\nFunction: " + lsFunctions.elementAt(functionIndexes[functionIndex]).functionName + " with a definition = " + lsFunctions.elementAt(functionIndexes[functionIndex]).functionExpression + "\nhas generated an error and cannot be processed!\n\nPlease edit the function to correct any problems." + exc.getMessage());
                               lineCount = lsNumLines;
                           }
                       }
                       
                       // All of the data for the function has been generated, now display the plot data
                       lsFunctions.elementAt(functionIndexes[functionIndex]).plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Function:" + lsFunctions.elementAt(functionIndexes[functionIndex]).functionName + ": " + lsFunctions.elementAt(functionIndexes[functionIndex]).functionExpression, "Time (ms)", "Intensity");
                       lsFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.setLimits(0.0, lsFunctions.elementAt(functionIndexes[functionIndex]).time[lsNumLines - 1], lsFunctions.elementAt(functionIndexes[functionIndex]).intensityMin, lsFunctions.elementAt(functionIndexes[functionIndex]).intensityMax);
                       lsFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.setColor(lsFunctions.elementAt(functionIndexes[functionIndex]).color);
                       lsFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.addPoints(lsFunctions.elementAt(functionIndexes[functionIndex]).time, lsFunctions.elementAt(functionIndexes[functionIndex]).intensity, PlotWindow.LINE);
                       lsFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.draw();
                       lsFunctions.elementAt(functionIndexes[functionIndex]).imagePlusPlotWindow.setProcessor(null, lsFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.getProcessor());
                       //lsFunctions.elementAt(functionIndexes[functionIndex]).imagePlusPlotWindow.show();
                   }
                }
               
                for (int i = 0; i < lsFunctions.size(); i++) {
                   boolean functionSelected = false;
                   for (int functionIndex = 0; functionIndex < functionIndexes.length; functionIndex++) {
                       if (i == functionIndexes[functionIndex])
                           functionSelected = true;
                   }
                   if (functionSelected)
                       lsFunctions.elementAt(i).imagePlusPlotWindow.show();
                   else
                       lsFunctions.elementAt(i).imagePlusPlotWindow.hide();
               }
               
               // Determine the number of data entries for an analog data collection.
               int timeSamples = 0;
               double timeDelta = 1.0;
               for (int i = 0; i < 8; i++) {
                   if (lsAnalogData.size() > 0) {
                       if (lsAnalogData.elementAt(i).status) {
                           timeSamples = lsAnalogData.elementAt(i).time.size();
                           timeDelta = lsAnalogData.elementAt(i).time.elementAt(1) - lsAnalogData.elementAt(i).time.elementAt(0);
                           i = 8;
                       }
                   }
               }
                                   
               // Perform the function calculations and display for the
               // analog data functions.
                
               functionIndexes = listAnalogDataFunctionList.getSelectedIndexes();
               
               for (int functionIndex = 0; functionIndex < functionIndexes.length; functionIndex++) {
                   double[] plotTime = new double[timeSamples];
                   double[] plotData = new double[timeSamples];
                       
                   for (int i = 0; i < timeSamples; i++) {
                       plotTime[i] = i * timeDelta;
                       lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).time[i] = plotTime[i];
                   }
                   
                   // Parse the function string.
                   lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing = ParseExpression(lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionExpression);
                   
                   // Loop through the "functionProcessing" elements and make sure that any defined
                   // analog input numbers exist in the current list of analog inputs.  If not, mark the function
                   // as invalid and set all values to 0.
                   for (int i = 0; i < lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.size(); i++) {
                       if ((lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.elementAt(i) == 1) || (lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.elementAt(i) == 4)) {
                           // Check the profile number for validity
                           int analogInputNumber = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.profileNumber.elementAt(i) - 1;
                           if (!lsAnalogData.elementAt(analogInputNumber).status) {
                               lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.validString = false;
                           }
                       }
                       if (!lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.validString) {
                           for (int j = 0; j < timeSamples; j++)
                               plotData[j] = 0.0;
                       }
                   }
                   
                   // Process the function and generate the plot data
                   if (lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.validString) {
                       // Loop through the various components and create the final string for
                       // the JavaScript analysis.
                       int analogInputNum = 0;
                       int offset = 0;
                       int frameNumber = 0;
                       boolean useOffset = false;
                       boolean useFrameNumber = false;
                       String functionString = "";
                       
                       for (int sampleCount = 0; sampleCount < timeSamples; sampleCount++) {
                           functionString = "";
                           for (int i = 0; i < lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.size(); i++) {
                               switch (lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.elementType.elementAt(i)) {
                                   case 0: // String element
                                       functionString += lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.element.elementAt(i);
                                       break;
                                   case 1: // Profile number element
                                       analogInputNum = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.profileNumber.elementAt(i) - 1;
                                       offset = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.offset.elementAt(i);
                                       frameNumber = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.frameNumber.elementAt(i) - 1;
                                       useOffset = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useOffset.elementAt(i);
                                       useFrameNumber = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useFrameNumber.elementAt(i);
                                       if (useOffset) {
                                           // Current linescan intentisty value shifted by the "offset" value
                                           // Make sure that the applied "offset" still results in a valid line number.
                                           int lineIndex = sampleCount + offset;
                                           if (lineIndex < 0) lineIndex = 0;
                                           if (lineIndex >= timeSamples) lineIndex = timeSamples - 1;
                                           functionString += lsAnalogData.elementAt(analogInputNum).data.elementAt(lineIndex);
                                       }
                                       else if (useFrameNumber) {
                                           // Absolute linescan intensity from line specified by "frameNumber"
                                           // Make sure that the specified line number is valid.
                                           int lineIndex = frameNumber;
                                           if (lineIndex < 0) lineIndex = 0;
                                           if (lineIndex >= timeSamples) lineIndex = timeSamples - 1;
                                           functionString += lsAnalogData.elementAt(analogInputNum).data.elementAt(lineIndex);
                                       }
                                       else {
                                           // Current linescan intentisty value
                                           functionString += lsAnalogData.elementAt(analogInputNum).data.elementAt(sampleCount);
                                       }
                                       break;
                                   case 2: // Timestamp element
                                       analogInputNum = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.profileNumber.elementAt(i) - 1;
                                       offset = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.offset.elementAt(i);
                                       frameNumber = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.frameNumber.elementAt(i) - 1;
                                       useOffset = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useOffset.elementAt(i);
                                       useFrameNumber = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useFrameNumber.elementAt(i);
                                       if (useOffset) {
                                           // Current linescan timestamp value shifted by the "offset" value
                                           // Make sure that the applied "offset" still results in a valid line number.
                                           int lineIndex = sampleCount + offset;
                                           if (lineIndex < 0) lineIndex = 0;
                                           if (lineIndex >= timeSamples) lineIndex = timeSamples - 1;
                                           functionString += lsAnalogData.elementAt(analogInputNum).time.elementAt(lineIndex);
                                       }
                                       else if (useFrameNumber) {
                                           // Absolute linescan timestamp from line specified by "frameNumber"
                                           // Make sure that the specified line number is valid.
                                           int lineIndex = frameNumber;
                                           if (lineIndex < 0) lineIndex = 0;
                                           if (lineIndex >= timeSamples) lineIndex = timeSamples - 1;
                                           functionString += lsAnalogData.elementAt(analogInputNum).time.elementAt(lineIndex);
                                       }
                                       else {
                                           // Current linescan timestamp value
                                           functionString += lsAnalogData.elementAt(analogInputNum).time.elementAt(sampleCount);
                                       }
                                       break;
                                   case 3: // Frame number
                                       functionString += sampleCount;
                                       break;
                                   case 4: // "Average" value from entire profile or part of a profile
                                       analogInputNum = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.profileNumber.elementAt(i) - 1;
                                       offset = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.offset.elementAt(i) - 1;
                                       frameNumber = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.frameNumber.elementAt(i) - 1;
                                       useOffset = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useOffset.elementAt(i);
                                       useFrameNumber = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionProcessing.useFrameNumber.elementAt(i);
                                       if (useFrameNumber) {
                                          // Average value to be computed from a segment of the profile
                                           double profileSum = 0;
                                           // Make sure the specified limits to use for the averaging fall within the 
                                           // range of the data.
                                           if (frameNumber < 0)
                                               frameNumber = 0;
                                           if (frameNumber > lsAnalogData.elementAt(analogInputNum).data.size())
                                               frameNumber = lsAnalogData.elementAt(analogInputNum).data.size();
                                           if (offset < 0)
                                               offset = 0;
                                           if (offset > lsAnalogData.elementAt(analogInputNum).data.size())
                                               offset = lsAnalogData.elementAt(analogInputNum).data.size();
                                           for (int j = frameNumber; j < offset; j++)
                                               profileSum += lsAnalogData.elementAt(analogInputNum).data.elementAt(j);
                                           functionString += (profileSum / (offset - frameNumber + 1));
                                       }
                                       else {
                                           // Average value to be computed from the entire profile
                                           double profileSum = 0;
                                           for (int j = 0; j < lsAnalogData.elementAt(analogInputNum).data.size(); j++)
                                               profileSum += lsAnalogData.elementAt(analogInputNum).data.elementAt(j);
                                           functionString += (profileSum / lsAnalogData.elementAt(analogInputNum).data.size());
                                       }
                                       break;
                               }
                           }
                           //IJ.showMessage("function = " + functionString);
                           try {
                               lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensity[sampleCount] = (Double) engine.eval(functionString);
                               if (lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensity[sampleCount] > lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensityMax)
                                   lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensityMax = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensity[sampleCount];
                               if (lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensity[sampleCount] < lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensityMin)
                                   lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensityMin = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensity[sampleCount];
                               plotData[sampleCount] = lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensity[sampleCount];
                           } catch (javax.script.ScriptException exc) {
                               IJ.showMessage("JavaScript error: \n\nFunction: " + lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionName + " with a definition = " + lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionExpression + "\nhas generated an error and cannot be processed!\n\nPlease edit the function to correct any problems." + exc.getMessage());
                               sampleCount = timeSamples;
                           }
                       }
                       
                       // All of the data for the function has been generated, now display the plot data
                       lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Function:" + lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionName + ": " + lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).functionExpression, "Time (ms)", "Volts");
                       lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.setLimits(0.0, lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).time[timeSamples - 1], lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensityMin, lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensityMax);
                       lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.setColor(lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).color);
                       lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.addPoints(lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).time, lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).intensity, PlotWindow.LINE);
                       lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.draw();
                       lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).imagePlusPlotWindow.setProcessor(null, lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).plotWindow.getProcessor());
                       //lsAnalogDataFunctions.elementAt(functionIndexes[functionIndex]).imagePlusPlotWindow.show();
                   }
                }
               
                for (int i = 0; i < lsAnalogDataFunctions.size(); i++) {
                   boolean functionSelected = false;
                   for (int functionIndex = 0; functionIndex < functionIndexes.length; functionIndex++) {
                       if (i == functionIndexes[functionIndex])
                           functionSelected = true;
                   }
                   if (functionSelected)
                       lsAnalogDataFunctions.elementAt(i).imagePlusPlotWindow.show();
                   else
                       lsAnalogDataFunctions.elementAt(i).imagePlusPlotWindow.hide();
               }
               
               // Automatically save the function definitions so that they can be loaded again
               // if the operator decides to review this data.
               WriteProfileFunctions();
           }
           
           private void WriteProfileSettings () {
               // This method is used to write/save the profiles for the current sequence to an xml file.
               String xmlFileName;
               String tmp1;
               int lastUnderScore = lsFileName.lastIndexOf("_");
               tmp1 = lsFileName.substring(0, lastUnderScore + 1);
               xmlFileName = tmp1 + "Sequence" + lsSequenceNumber + "_Profiles.xml";
               File profileDefFile = new File(lsDirectory + xmlFileName);
               if ((lsProfiles.size() == 0) && (profileDefFile.exists())) {
                   // No profiles exists (so all have been deleted) so delete the profiles file
                   // for this sequence.
                   profileDefFile.delete();
               }
               //IJ.showMessage("write file = " + lsDirectory + "   " + xmlFileName);
               try {
                    DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
                    DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
 
                    // root elements
                    Document doc = docBuilder.newDocument();
                    Element rootElement = doc.createElement("Profiles");
                    doc.appendChild(rootElement);
     
                    for (int i = 0; i < lsProfiles.size(); i++) {
                        // staff elements
                        Element profile = doc.createElement("Profile");
                        rootElement.appendChild(profile);
                        
                        //profile.setAttribute("index", String.valueOf(i));
                        profile.setAttribute("channel", String.valueOf(lsProfiles.elementAt(i).channel));
                        profile.setAttribute("color", String.valueOf(String.valueOf(lsProfiles.elementAt(i).color.getRGB())));
                        profile.setAttribute("width", String.valueOf(lsProfiles.elementAt(i).width));
                        profile.setAttribute("position", String.valueOf(lsProfiles.elementAt(i).position));
                        profile.setAttribute("threshold", String.valueOf(lsProfiles.elementAt(i).threshold));
                        profile.setAttribute("thresholdMin", String.valueOf(lsProfiles.elementAt(i).thresholdMin));
                        profile.setAttribute("thresholdMax", String.valueOf(lsProfiles.elementAt(i).thresholdMax));
                        profile.setAttribute("prairieViewProfile", String.valueOf(lsProfiles.elementAt(i).prairieViewProfile));
                        profile.setAttribute("prairieViewIndex", String.valueOf(lsProfiles.elementAt(i).prairieViewIndex));
                        
                        // write the content into xml file
                        TransformerFactory transformerFactory = TransformerFactory.newInstance();
                        Transformer transformer = transformerFactory.newTransformer();
                        DOMSource source = new DOMSource(doc);
                        StreamResult result = new StreamResult(new File(lsDirectory + xmlFileName));

                        // Output to console for testing
                        // StreamResult result = new StreamResult(System.out);

                        transformer.transform(source, result);
                    }
               } catch (ParserConfigurationException pce) {
                    pce.printStackTrace();
               } catch (TransformerException tfe) {
                    tfe.printStackTrace();
               }
           }
           
           private void ReadProfileSettings () {
               // This method is used to read the profiles for the current sequence from an xml file.
               String xmlFileName;
               String tmp1;
               int lastUnderScore = lsFileName.lastIndexOf("_");
               tmp1 = lsFileName.substring(0, lastUnderScore + 1);
               xmlFileName = tmp1 + "Sequence" + lsSequenceNumber + "_Profiles.xml";
               File profileFile = new File(lsDirectory + xmlFileName);
               if (profileFile.exists()) {
                   // Profiles file was found, so read it.
                  
                   try {
                        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
                        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
                        Document doc = docBuilder.parse(new File(lsDirectory + xmlFileName));
                        
                        if (doc.getDocumentElement().getNodeName().equals("Profiles")) {
                            Node profiles = doc.getElementsByTagName("Profiles").item(0);
                            NodeList profileDefinitions = profiles.getChildNodes();
                            for(int i = 0; i < profileDefinitions.getLength(); i++) {
                                ProfileSettings newProfile = new ProfileSettings();
                                Node profile = profileDefinitions.item(i);
                                double yMin = 0.0;
                                double yMax = 1.0;
                                String chanName = "";
                                if (profile.getNodeName().equals("Profile")) {
                                    newProfile.channel = Integer.parseInt(profile.getAttributes().getNamedItem("channel").getNodeValue());
                                    newProfile.color = new Color(Integer.parseInt(profile.getAttributes().getNamedItem("color").getNodeValue()));
                                    newProfile.width = Integer.parseInt(profile.getAttributes().getNamedItem("width").getNodeValue());
                                    newProfile.position = Integer.parseInt(profile.getAttributes().getNamedItem("position").getNodeValue());
                                    if (profile.getAttributes().getNamedItem("threshold") != null) {
                                        newProfile.threshold = Boolean.parseBoolean(profile.getAttributes().getNamedItem("threshold").getNodeValue());
                                        newProfile.thresholdMin = Double.parseDouble(profile.getAttributes().getNamedItem("thresholdMin").getNodeValue());
                                        newProfile.thresholdMax = Double.parseDouble(profile.getAttributes().getNamedItem("thresholdMax").getNodeValue());
                                    }
                                    if (profile.getAttributes().getNamedItem("prairieViewProfile") != null) {
                                        newProfile.prairieViewProfile = Boolean.parseBoolean(profile.getAttributes().getNamedItem("prairieViewProfile").getNodeValue());
                                        newProfile.prairieViewIndex = Integer.parseInt(profile.getAttributes().getNamedItem("prairieViewIndex").getNodeValue());
                                    }
                                    if (lsNumChans == 1) {
                                        yMin = lsYMin;
                                        yMax = lsYMax;
                                        switch (newProfile.channel) {
                                            case 0:
                                                yMin = lsYMin1;
                                                yMax = lsYMax1;
                                                chanName = lsCh1Label;
                                                break;
                                            case 1:
                                                yMin = lsYMin2;
                                                yMax = lsYMax2;
                                                chanName = lsCh2Label;
                                                break;
                                            case 2:
                                                yMin = lsYMin3;
                                                yMax = lsYMax3;
                                                chanName = lsCh3Label;
                                                break;
                                            case 3:
                                                yMin = lsYMin4;
                                                yMax = lsYMax4;
                                                chanName = lsCh4Label;
                                                break;
                                        }
                                     }
                                     else {
                                        switch (newProfile.channel) {
                                            case 0:
                                                yMin = lsYMin1;
                                                yMax = lsYMax1;
                                                chanName = lsCh1Label;
                                                break;
                                            case 1:
                                                yMin = lsYMin2;
                                                yMax = lsYMax2;
                                                chanName = lsCh2Label;
                                                break;
                                            case 2:
                                                yMin = lsYMin3;
                                                yMax = lsYMax3;
                                                chanName = lsCh3Label;
                                                break;
                                            case 3:
                                                yMin = lsYMin4;
                                                yMax = lsYMax4;
                                                chanName = lsCh4Label;
                                                break;
                                        }
                                    }
                                    newProfile.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (i + 1) + ":" + chanName, "Time (ms)", "Intensity");
                                    newProfile.plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
                                    newProfile.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (i + 1) + ":" + chanName, newProfile.plotWindow.getProcessor());
                                }
                                if (!newProfile.prairieViewProfile)
                                    lsProfiles.add(newProfile);
                                else {
                                    // Update the existing Prairie View created profile definitions with the
                                    // values just read from the file.
                                    lsProfiles.elementAt(newProfile.prairieViewIndex).position = newProfile.position;
                                    lsProfiles.elementAt(newProfile.prairieViewIndex).width = newProfile.width;
                                    lsProfiles.elementAt(newProfile.prairieViewIndex).color = newProfile.color;
                                    lsProfiles.elementAt(newProfile.prairieViewIndex).threshold = newProfile.threshold;
                                    lsProfiles.elementAt(newProfile.prairieViewIndex).thresholdMin = newProfile.thresholdMin;
                                    lsProfiles.elementAt(newProfile.prairieViewIndex).thresholdMax = newProfile.thresholdMax;
                                }
                             }
                        }
                   } catch (Throwable t) {
			try {
                            FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                            PrintStream logStream = new PrintStream(logFile);
                            t.printStackTrace(logStream);
                            logStream.flush();
                            logStream.close();
                            logFile.flush();
                            logFile.close();
                            IJ.showMessage("Prairie Reader", "Error Parsing: " + lsDirectory + xmlFileName + "\n" + "Error: " + "\n" + t.toString());
			} catch (IOException exception) {}
                   }
                   
                   if (lsProfiles.size() > 0)
                        UpdateProfiles();
               }
            }
           
           private void ReadProfileFunctions() {
               // This method is used to read the functoins for the current sequence from an xml file.
               String xmlFileName;
               String tmp1;
               int lastUnderScore = lsFileName.lastIndexOf("_");
               tmp1 = lsFileName.substring(0, lastUnderScore + 1);
               xmlFileName = tmp1 + "Sequence" + lsSequenceNumber + "_Functions.xml";
               File functionsFile = new File(lsDirectory + xmlFileName);
               if (functionsFile.exists()) {
               // Functions file was found, so read it.
                    try {
                        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
                        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
                        Document doc = docBuilder.parse(new File(lsDirectory + xmlFileName));

                        if (doc.getDocumentElement().getNodeName().equals("Functions")) {
                            Node functions = doc.getElementsByTagName("Functions").item(0);
                            NodeList functionDefinitions = functions.getChildNodes();
                            for(int i = 0; i < functionDefinitions.getLength(); i++) {
                                Node mathFunction = functionDefinitions.item(i);
                                if (mathFunction.getNodeName().equals("Function")) {
                                    LSFunctionSettings newFunction = new LSFunctionSettings();
                                    newFunction.functionName = mathFunction.getAttributes().getNamedItem("name").getNodeValue();
                                    newFunction.functionExpression = mathFunction.getAttributes().getNamedItem("function").getNodeValue();
                                    newFunction.color = new Color(Integer.parseInt(mathFunction.getAttributes().getNamedItem("color").getNodeValue()));
                                    newFunction.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Function " + newFunction.functionName, "Time (ms)", "Intensity");
                                    //newFunction.plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
                                    newFunction.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Function " + newFunction.functionName, newFunction.plotWindow.getProcessor());
                                    lsFunctions.add(newFunction);
                                }
                                else if (mathFunction.getNodeName().equals("AnalogDataFunction")) {
                                    LSAnalogDataFunctionSettings newFunction = new LSAnalogDataFunctionSettings();
                                    newFunction.functionName = mathFunction.getAttributes().getNamedItem("name").getNodeValue();
                                    newFunction.functionExpression = mathFunction.getAttributes().getNamedItem("function").getNodeValue();
                                    newFunction.color = new Color(Integer.parseInt(mathFunction.getAttributes().getNamedItem("color").getNodeValue()));
                                    newFunction.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Function " + newFunction.functionName, "Time (ms)", "Intensity");
                                    //newFunction.plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
                                    newFunction.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Function " + newFunction.functionName, newFunction.plotWindow.getProcessor());
                                    lsAnalogDataFunctions.add(newFunction);
                                }
                            }
                        }
                    } catch (Throwable t) {
                        try {
                            FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                            PrintStream logStream = new PrintStream(logFile);
                            t.printStackTrace(logStream);
                            logStream.flush();
                            logStream.close();
                            logFile.flush();
                            logFile.close();
                            IJ.showMessage("Prairie Reader", "Error Parsing: " + lsDirectory + xmlFileName + "\n" + "Error: " + "\n" + t.toString());
                        } catch (IOException exception) {}
                   }
               }
           }

            private void WriteProfileFunctions() {
               // This method is used to write/save the function definitions to an xml file.
               String xmlFileName;
               String tmp1;
               int lastUnderScore = lsFileName.lastIndexOf("_");
               tmp1 = lsFileName.substring(0, lastUnderScore + 1);
               xmlFileName = tmp1 + "Sequence" + lsSequenceNumber + "_Functions.xml";
               File functionDefFile = new File(lsDirectory + xmlFileName);
               if (((lsFunctions.size() == 0) || (lsAnalogDataFunctions.size() == 0)) && (functionDefFile.exists())) {
                   // No profiles exists (so all have been deleted) so delete the functions file
                   // for this sequence.
                   functionDefFile.delete();
               }
               try {
                    DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
                    DocumentBuilder docBuilder = docFactory.newDocumentBuilder();

                    // root elements
                    Document doc = docBuilder.newDocument();
                    Element rootElement = doc.createElement("Functions");
                    doc.appendChild(rootElement);

                    // write the profile functions
                    for (int i = 0; i < lsFunctions.size(); i++) {
                        // staff elements
                        Element profile = doc.createElement("Function");
                        rootElement.appendChild(profile);

                        profile.setAttribute("name", String.valueOf(lsFunctions.elementAt(i).functionName));
                        profile.setAttribute("function", String.valueOf(String.valueOf(lsFunctions.elementAt(i).functionExpression)));
                        profile.setAttribute("color", String.valueOf(String.valueOf(lsFunctions.elementAt(i).color.getRGB())));

                        // write the content into xml file
                        TransformerFactory transformerFactory = TransformerFactory.newInstance();
                        Transformer transformer = transformerFactory.newTransformer();
                        DOMSource source = new DOMSource(doc);
                        StreamResult result = new StreamResult(new File(lsDirectory + xmlFileName));

                        // Output to console for testing
                        // StreamResult result = new StreamResult(System.out);

                        transformer.transform(source, result);
                    }
                    
                    // write the analog data functions
                    for (int i = 0; i < lsAnalogDataFunctions.size(); i++) {
                        // staff elements
                        Element profile = doc.createElement("AnalogDataFunction");
                        rootElement.appendChild(profile);

                        profile.setAttribute("name", String.valueOf(lsAnalogDataFunctions.elementAt(i).functionName));
                        profile.setAttribute("function", String.valueOf(String.valueOf(lsAnalogDataFunctions.elementAt(i).functionExpression)));
                        profile.setAttribute("color", String.valueOf(String.valueOf(lsAnalogDataFunctions.elementAt(i).color.getRGB())));

                        // write the content into xml file
                        TransformerFactory transformerFactory = TransformerFactory.newInstance();
                        Transformer transformer = transformerFactory.newTransformer();
                        DOMSource source = new DOMSource(doc);
                        StreamResult result = new StreamResult(new File(lsDirectory + xmlFileName));

                        // Output to console for testing
                        // StreamResult result = new StreamResult(System.out);

                        transformer.transform(source, result);
                    }
               } catch (ParserConfigurationException pce) {
                    pce.printStackTrace();
               } catch (TransformerException tfe) {
                    tfe.printStackTrace();
               }
            }

            public void CopySelectedProfiles() {
                int indexes[] = listProfileList.getSelectedIndexes();
                if (indexes.length == 0) {
                    IJ.showMessage("At least one profile must be selected!");
                    return;
                }
                // This method is used to write/save the selected profiles for the current sequence to an xml file.
                // This file can then be read by other instances of this class as a way to "copy" profile definitions
                // from one linescan sequence to another.
                String xmlFileName = "C:\\ProgramData\\Bruker Fluorescence Microscopy\\PrairieReader_Profiles.xml";
				if (!(new File("C:\\ProgramData\\Bruker Fluorescence Microscopy").exists()))
					xmlFileName = "C:\\Program Files\\PrairieReader_Profiles.xml";
                try {
                    DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
                    DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
 
                    // root elements
                    Document doc = docBuilder.newDocument();
                    Element rootElement = doc.createElement("Profiles");
                    doc.appendChild(rootElement);
     
                    for (int i = 0; i < indexes.length; i++) {
                        // staff elements
                        Element profile = doc.createElement("Profile");
                        rootElement.appendChild(profile);
                        
                        //profile.setAttribute("index", String.valueOf(i));
                        profile.setAttribute("channel", String.valueOf(lsProfiles.elementAt(indexes[i]).channel));
                        profile.setAttribute("color", String.valueOf(String.valueOf(lsProfiles.elementAt(indexes[i]).color.getRGB())));
                        profile.setAttribute("width", String.valueOf(lsProfiles.elementAt(indexes[i]).width));
                        profile.setAttribute("position", String.valueOf(lsProfiles.elementAt(indexes[i]).position));
                        profile.setAttribute("threshold", String.valueOf(lsProfiles.elementAt(indexes[i]).threshold));
                        profile.setAttribute("thresholdMin", String.valueOf(lsProfiles.elementAt(indexes[i]).thresholdMin));
                        profile.setAttribute("thresholdMax", String.valueOf(lsProfiles.elementAt(indexes[i]).thresholdMax));
                       
                        // write the content into xml file
                        TransformerFactory transformerFactory = TransformerFactory.newInstance();
                        Transformer transformer = transformerFactory.newTransformer();
                        DOMSource source = new DOMSource(doc);
                        StreamResult result = new StreamResult(new File(xmlFileName));

                        // Output to console for testing
                        // StreamResult result = new StreamResult(System.out);

                        transformer.transform(source, result);
                    }
                } catch (ParserConfigurationException pce) {
                    pce.printStackTrace();
                } catch (TransformerException tfe) {
                    tfe.printStackTrace();
                }
                return;
            }
           
            public void PasteProfiles() {
                // This method is used to read the profiles that were saved via the "copy" button.
                // If the specified channel does not exist in the current sequence, then the profile
                // will be ignored.  If the profile position and width place it outside of the current
                // sequence, then the profile will be ignored.
                String xmlFileName = "C:\\ProgramData\\Bruker Fluorescence Microscopy\\PrairieReader_Profiles.xml";
				if (!(new File("C:\\ProgramData\\Bruker Fluorescence Microscopy").exists()))
					xmlFileName = "C:\\Program Files\\PrairieReader_Profiles.xml";
                File profileFile = new File(xmlFileName);
                if (profileFile.exists()) {
                    // Profiles file was found, so read it.
                  
                    try {
                        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
                        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
                        Document doc = docBuilder.parse(new File(xmlFileName));
                        
                        if (doc.getDocumentElement().getNodeName().equals("Profiles")) {
                            Node profiles = doc.getElementsByTagName("Profiles").item(0);
                            NodeList profileDefinitions = profiles.getChildNodes();
                            for(int i = 0; i < profileDefinitions.getLength(); i++) {
                                ProfileSettings newProfile = new ProfileSettings();
                                Node profile = profileDefinitions.item(i);
                                double yMin = 0.0;
                                double yMax = 1.0;
                                String chanName = "";
                                if (profile.getNodeName().equals("Profile")) {
                                    newProfile.channel = Integer.parseInt(profile.getAttributes().getNamedItem("channel").getNodeValue());
                                    newProfile.color = new Color(Integer.parseInt(profile.getAttributes().getNamedItem("color").getNodeValue()));
                                    newProfile.width = Integer.parseInt(profile.getAttributes().getNamedItem("width").getNodeValue());
                                    newProfile.position = Integer.parseInt(profile.getAttributes().getNamedItem("position").getNodeValue());
                                    if (profile.getAttributes().getNamedItem("threshold") != null) {
                                        newProfile.threshold = Boolean.parseBoolean(profile.getAttributes().getNamedItem("threshold").getNodeValue());
                                        newProfile.thresholdMin = Double.parseDouble(profile.getAttributes().getNamedItem("thresholdMin").getNodeValue());
                                        newProfile.thresholdMax = Double.parseDouble(profile.getAttributes().getNamedItem("thresholdMax").getNodeValue());
                                    }
                                    // Make sure that the channel number is valid for this data set.
                                    if (newProfile.channel < lsNumChans) {
                                        // Make sure that the profile position falls within the current data
                                        if ((newProfile.position + (newProfile.width - 1)) < lsPixelsPerLine) {
                                            if (lsNumChans == 1) {
                                                yMin = lsYMin;
                                                yMax = lsYMax;
                                                switch (newProfile.channel) {
                                                    case 0:
                                                        yMin = lsYMin1;
                                                        yMax = lsYMax1;
                                                        chanName = lsCh1Label;
                                                        break;
                                                    case 1:
                                                        yMin = lsYMin2;
                                                        yMax = lsYMax2;
                                                        chanName = lsCh2Label;
                                                        break;
                                                    case 2:
                                                        yMin = lsYMin3;
                                                        yMax = lsYMax3;
                                                        chanName = lsCh3Label;
                                                        break;
                                                    case 3:
                                                        yMin = lsYMin4;
                                                        yMax = lsYMax4;
                                                        chanName = lsCh4Label;
                                                        break;
                                                }
                                             }
                                             else {
                                                switch (newProfile.channel) {
                                                    case 0:
                                                        yMin = lsYMin1;
                                                        yMax = lsYMax1;
                                                        chanName = lsCh1Label;
                                                        break;
                                                    case 1:
                                                        yMin = lsYMin2;
                                                        yMax = lsYMax2;
                                                        chanName = lsCh2Label;
                                                        break;
                                                    case 2:
                                                        yMin = lsYMin3;
                                                        yMax = lsYMax3;
                                                        chanName = lsCh3Label;
                                                        break;
                                                    case 3:
                                                        yMin = lsYMin4;
                                                        yMax = lsYMax4;
                                                        chanName = lsCh4Label;
                                                        break;
                                                }
                                            }
                                            newProfile.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (i + 1) + ":" + chanName, "Time (ms)", "Intensity");
                                            newProfile.plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
                                            newProfile.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (i + 1) + ":" + chanName, newProfile.plotWindow.getProcessor());
                                            lsProfiles.add(newProfile);
                                        }
                                     }
                                }
                            }
                        }
                    } catch (Throwable t) {
			try {
                            FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                            PrintStream logStream = new PrintStream(logFile);
                            t.printStackTrace(logStream);
                            logStream.flush();
                            logStream.close();
                            logFile.flush();
                            logFile.close();
                            IJ.showMessage("Prairie Reader", "Error Parsing: " + xmlFileName + "\n" + "Error: " + "\n" + t.toString());
			} catch (IOException exception) {}
                    }
                   
                    if (lsProfiles.size() > 0)
                        UpdateProfiles();
                }
            }
            
            public void SetPrairieViewCreatedProfile(int index, int channel, int position, int width, int color) {
                ProfileSettings newProfile = new ProfileSettings();
                newProfile.channel = channel;
                newProfile.color = new Color(color);
                newProfile.width = width;
                newProfile.position = position;
                newProfile.threshold = false;
                newProfile.prairieViewProfile = true;
                newProfile.prairieViewIndex = index;
                double yMin = 0.0;
                double yMax = 1.0;
                String chanName = "";
                if (lsNumChans == 1) {
                    yMin = lsYMin;
                    yMax = lsYMax;
                    switch (newProfile.channel) {
                        case 0:
                            yMin = lsYMin1;
                            yMax = lsYMax1;
                            chanName = lsCh1Label;
                            break;
                        case 1:
                            yMin = lsYMin2;
                            yMax = lsYMax2;
                            chanName = lsCh2Label;
                            break;
                        case 2:
                            yMin = lsYMin3;
                            yMax = lsYMax3;
                            chanName = lsCh3Label;
                            break;
                        case 3:
                            yMin = lsYMin4;
                            yMax = lsYMax4;
                            chanName = lsCh4Label;
                            break;
                    }
                 }
                 else {
                    switch (newProfile.channel) {
                        case 0:
                            yMin = lsYMin1;
                            yMax = lsYMax1;
                            chanName = lsCh1Label;
                            break;
                        case 1:
                            yMin = lsYMin2;
                            yMax = lsYMax2;
                            chanName = lsCh2Label;
                            break;
                        case 2:
                            yMin = lsYMin3;
                            yMax = lsYMax3;
                            chanName = lsCh3Label;
                            break;
                        case 3:
                            yMin = lsYMin4;
                            yMax = lsYMax4;
                            chanName = lsCh4Label;
                            break;
                    }
                }
                newProfile.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (index + 1) + ":" + chanName, "Time (ms)", "Intensity");
                newProfile.plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
                newProfile.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (index + 1) + ":" + chanName, newProfile.plotWindow.getProcessor());
                lsProfiles.add(newProfile);
            }
            
            private void jButtonCreateProfileActionPerformed(java.awt.event.ActionEvent evt) {
                int numProfilesCreated = 0;
                ProfileSettings newProfile1 = new ProfileSettings();
                newProfile1.color = jPanelProfileColor.getBackground();
                newProfile1.width = (jSliderProfileWidth.getValue() * 2) + 1;
                newProfile1.position = lsWindow.getImagePlus().getHeight() / 2;
                newProfile1.threshold = false;
                newProfile1.prairieViewProfile = false;
                ProfileSettings newProfile2 = new ProfileSettings();
                newProfile2.color = jPanelProfileColor.getBackground();
                newProfile2.width = (jSliderProfileWidth.getValue() * 2) + 1;
                newProfile2.position = lsWindow.getImagePlus().getHeight() / 2;
                newProfile2.threshold = false;
                newProfile2.prairieViewProfile = false;
                ProfileSettings newProfile3 = new ProfileSettings();
                newProfile3.color = jPanelProfileColor.getBackground();
                newProfile3.width = (jSliderProfileWidth.getValue() * 2) + 1;
                newProfile3.position = lsWindow.getImagePlus().getHeight() / 2;
                newProfile3.threshold = false;
                newProfile3.prairieViewProfile = false;
                ProfileSettings newProfile4 = new ProfileSettings();
                newProfile4.color = jPanelProfileColor.getBackground();
                newProfile4.width = (jSliderProfileWidth.getValue() * 2) + 1;
                newProfile4.position = lsWindow.getImagePlus().getHeight() / 2;
                newProfile4.threshold = false;
                newProfile4.prairieViewProfile = false;
                // Add the profile definition to the list of profiles
                // It is necessary to create a new profile for each channel is multiple channels are selected
                if (lsNumChans == 1) {
                    newProfile1.channel = 0;
                    newProfile1.thresholdMin = lsYMin;
                    newProfile1.thresholdMax = lsYMax;
                    newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                    newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin, lsYMax);
                    newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                    lsProfiles.add(newProfile1);
                    numProfilesCreated = 1;
                }
                else if (lsNumChans == 2) {
                    switch (jComboBoxChannelSelection.getSelectedIndex()) {
                        case 0:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            numProfilesCreated = 1;
                            break;
                        case 1:
                            newProfile1.channel = 1;
                            newProfile1.thresholdMin = lsYMin2;
                            newProfile1.thresholdMax = lsYMax2;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            numProfilesCreated = 1;
                            break;
                        case 2:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 1;
                            newProfile2.thresholdMin = lsYMin2;
                            newProfile2.thresholdMax = lsYMax2;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;   
                    }
                }
                else if (lsNumChans == 3) {
                    switch (jComboBoxChannelSelection.getSelectedIndex()) {
                        case 0:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            numProfilesCreated = 1;
                            break;
                        case 1:
                            newProfile1.channel = 1;
                            newProfile1.thresholdMin = lsYMin2;
                            newProfile1.thresholdMax = lsYMax2;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            numProfilesCreated = 1;
                            break;
                        case 2:
                            newProfile1.channel = 2;
                            newProfile1.thresholdMin = lsYMin3;
                            newProfile1.thresholdMax = lsYMax3;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            numProfilesCreated = 1;
                            break;
                        case 3:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 1;
                            newProfile2.thresholdMin = lsYMin2;
                            newProfile2.thresholdMax = lsYMax2;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;
                        case 4:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 2;
                            newProfile1.thresholdMin = lsYMin3;
                            newProfile1.thresholdMax = lsYMax3;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;
                        case 5:
                            newProfile1.channel = 1;
                            newProfile1.thresholdMin = lsYMin2;
                            newProfile1.thresholdMax = lsYMax2;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 2;
                            newProfile2.thresholdMin = lsYMin3;
                            newProfile2.thresholdMax = lsYMax3;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;
                        case 6:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 1;
                            newProfile2.thresholdMin = lsYMin2;
                            newProfile2.thresholdMax = lsYMax2;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            newProfile3.channel = 2;
                            newProfile3.thresholdMin = lsYMin3;
                            newProfile3.thresholdMax = lsYMax3;
                            newProfile3.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile3.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile3.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile3.plotWindow.getProcessor());
                            lsProfiles.add(newProfile3);
                            numProfilesCreated = 3;
                            break;   
                    }
                }
                else if (lsNumChans == 4) {
                    switch (jComboBoxChannelSelection.getSelectedIndex()) {
                        case 0:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            numProfilesCreated = 1;
                            break;
                        case 1:
                            newProfile1.channel = 1;
                            newProfile1.thresholdMin = lsYMin2;
                            newProfile1.thresholdMax = lsYMax2;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            numProfilesCreated = 1;
                            break;
                        case 2:
                            newProfile1.channel = 2;
                            newProfile1.thresholdMin = lsYMin3;
                            newProfile1.thresholdMax = lsYMax3;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            numProfilesCreated = 1;
                            break;
                        case 3:
                            newProfile1.channel = 3;
                            newProfile1.thresholdMin = lsYMin4;
                            newProfile1.thresholdMax = lsYMax4;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin4, lsYMax4);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            numProfilesCreated = 1;
                            break;
                        case 4:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 1;
                            newProfile2.thresholdMin = lsYMin2;
                            newProfile2.thresholdMax = lsYMax2;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;
                        case 5:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 2;
                            newProfile2.thresholdMin = lsYMin3;
                            newProfile2.thresholdMax = lsYMax3;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;
                        case 6:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 3;
                            newProfile2.thresholdMin = lsYMin4;
                            newProfile2.thresholdMax = lsYMax4;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin4, lsYMax4);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;
                        case 7:
                            newProfile1.channel = 1;
                            newProfile1.thresholdMin = lsYMin2;
                            newProfile1.thresholdMax = lsYMax2;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 2;
                            newProfile2.thresholdMin = lsYMin3;
                            newProfile2.thresholdMax = lsYMax3;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;
                        case 8:
                            newProfile1.channel = 1;
                            newProfile1.thresholdMin = lsYMin2;
                            newProfile1.thresholdMax = lsYMax2;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 3;
                            newProfile2.thresholdMin = lsYMin4;
                            newProfile2.thresholdMax = lsYMax4;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin4, lsYMax4);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;
                        case 9:
                            newProfile1.channel = 2;
                            newProfile1.thresholdMin = lsYMin3;
                            newProfile1.thresholdMax = lsYMax3;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 3;
                            newProfile2.thresholdMin = lsYMin4;
                            newProfile2.thresholdMax = lsYMax4;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin4, lsYMax4);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            numProfilesCreated = 2;
                            break;
                        case 10:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 1;
                            newProfile2.thresholdMin = lsYMin2;
                            newProfile2.thresholdMax = lsYMax2;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            newProfile3.channel = 2;
                            newProfile3.thresholdMin = lsYMin3;
                            newProfile3.thresholdMax = lsYMax3;
                            newProfile3.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile3.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile3.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile3.plotWindow.getProcessor());
                            lsProfiles.add(newProfile3);
                            numProfilesCreated = 3;
                            break;   
                         case 11:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 1;
                            newProfile2.thresholdMin = lsYMin2;
                            newProfile2.thresholdMax = lsYMax2;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            newProfile3.channel = 3;
                            newProfile3.thresholdMin = lsYMin4;
                            newProfile3.thresholdMax = lsYMax4;
                            newProfile3.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, "Time (ms)", "Intensity");
                            newProfile3.plotWindow.setLimits(0.0, lsXMax, lsYMin4, lsYMax4);
                            newProfile3.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, newProfile3.plotWindow.getProcessor());
                            lsProfiles.add(newProfile3);
                            numProfilesCreated = 3;
                            break;   
                         case 12:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 2;
                            newProfile2.thresholdMin = lsYMin3;
                            newProfile2.thresholdMax = lsYMax3;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            newProfile3.channel = 3;
                            newProfile3.thresholdMin = lsYMin4;
                            newProfile3.thresholdMax = lsYMax4;
                            newProfile3.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, "Time (ms)", "Intensity");
                            newProfile3.plotWindow.setLimits(0.0, lsXMax, lsYMin4, lsYMax4);
                            newProfile3.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, newProfile3.plotWindow.getProcessor());
                            lsProfiles.add(newProfile3);
                            numProfilesCreated = 3;
                            break;   
                         case 13:
                            newProfile1.channel = 1;
                            newProfile1.thresholdMin = lsYMin2;
                            newProfile1.thresholdMax = lsYMax2;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 2;
                            newProfile2.thresholdMin = lsYMin3;
                            newProfile2.thresholdMax = lsYMax3;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            newProfile3.channel = 3;
                            newProfile3.thresholdMin = lsYMin4;
                            newProfile3.thresholdMax = lsYMax4;
                            newProfile3.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, "Time (ms)", "Intensity");
                            newProfile3.plotWindow.setLimits(0.0, lsXMax, lsYMin4, lsYMax4);
                            newProfile3.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, newProfile3.plotWindow.getProcessor());
                            lsProfiles.add(newProfile3);
                            numProfilesCreated = 3;
                            break;   
                         case 14:
                            newProfile1.channel = 0;
                            newProfile1.thresholdMin = lsYMin1;
                            newProfile1.thresholdMax = lsYMax1;
                            newProfile1.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, "Time (ms)", "Intensity");
                            newProfile1.plotWindow.setLimits(0.0, lsXMax, lsYMin1, lsYMax1);
                            newProfile1.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh1Label, newProfile1.plotWindow.getProcessor());
                            lsProfiles.add(newProfile1);
                            newProfile2.channel = 1;
                            newProfile2.thresholdMin = lsYMin2;
                            newProfile2.thresholdMax = lsYMax2;
                            newProfile2.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, "Time (ms)", "Intensity");
                            newProfile2.plotWindow.setLimits(0.0, lsXMax, lsYMin2, lsYMax2);
                            newProfile2.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh2Label, newProfile2.plotWindow.getProcessor());
                            lsProfiles.add(newProfile2);
                            newProfile3.channel = 2;
                            newProfile3.thresholdMin = lsYMin3;
                            newProfile3.thresholdMax = lsYMax3;
                            newProfile3.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, "Time (ms)", "Intensity");
                            newProfile3.plotWindow.setLimits(0.0, lsXMax, lsYMin3, lsYMax3);
                            newProfile3.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh3Label, newProfile3.plotWindow.getProcessor());
                            lsProfiles.add(newProfile3);
                            newProfile4.channel = 3;
                            newProfile4.thresholdMin = lsYMin4;
                            newProfile4.thresholdMax = lsYMax4;
                            newProfile4.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, "Time (ms)", "Intensity");
                            newProfile4.plotWindow.setLimits(0.0, lsXMax, lsYMin4, lsYMax4);
                            newProfile4.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Profile " + (lsProfiles.size() + 1) + ":" + lsCh4Label, newProfile4.plotWindow.getProcessor());
                            lsProfiles.add(newProfile4);
                            numProfilesCreated = 4;
                            break;   
                    }
                }
                
                // Call the method to update the list of profiles and generate and display the profile data
                UpdateProfiles();
                
                // Automatically 'select' the newly created profile(s)
                int indexes[] = listProfileList.getSelectedIndexes();
                for (int i = 0; i < numProfilesCreated; i++)
                    listProfileList.select(lsProfiles.size() - 1 - i);
                
                if ((indexes.length + numProfilesCreated) == 1) {
                    // Only one profile is selected so update the width, color, and position controls 
                    // to reflect this profile's setting.
                    jPanelProfileColor.setBackground(lsProfiles.lastElement().color);
                    updateProfileWidthDisplay(lsProfiles.lastElement().width);
                    jSliderProfileWidth.setValue((lsProfiles.lastElement().width / 2) - 1);
                    jScrollBarProfilePosition.setValue(lsProfiles.lastElement().position);
                    // Also update the threshold checkbox
                    jCheckBoxThresholdProfile.setSelected(lsProfiles.lastElement().threshold);
                    jCheckBoxThresholdProfile.setEnabled(true);
                    jToggleButtonThresholdEdit.setEnabled(true);
                }
                
                UpdateProfiles();
            }

            private void SaveProfiles(boolean allProfiles) {
                
                // If analog data is present with this data set, prompt the operator about saving the
                // analog data in addition to the profile data.
                boolean saveAnalogData = false;
                if (lsAnalogDataPresent) {
                    saveAnalogData = IJ.showMessageWithCancel("Linescan Analog data", "Save analog data and analog data functions (if used) in addition to the profiles?");
                }
                
                // Prompt the operator for the file name to use for the data
                jFileChooserSaveProfiles.setDialogTitle("Select file for profile data");
                jFileChooserSaveProfiles.setDialogType(JFileChooser.SAVE_DIALOG);
                File curDir = new File(lsDirectory);
                jFileChooserSaveProfiles.setCurrentDirectory(curDir);
                jFileChooserSaveProfiles.setMultiSelectionEnabled(false);
                FileFilter filter1 = new ExtensionFileFilter("csv", new String[] {"csv"});
                jFileChooserSaveProfiles.setFileFilter(filter1);
                int returnVal = jFileChooserSaveProfiles.showOpenDialog(this);
                String strFile = "";
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                    strFile = jFileChooserSaveProfiles.getSelectedFile().toString();
                    // Make sure the filename ends with .csv
                    if (!strFile.endsWith("-Profiles.csv")) {
                        // File doesn't end with .csv so add it
                        strFile = strFile.concat("-Profiles.csv");
                    }
                    File selectedFile = new File(strFile);
                    boolean saveData = true;
                    // Check if file exists and warn the operator.
                    if (selectedFile.exists()) {
                        int choice = JOptionPane.showConfirmDialog(this, "The file you have selected already exists,\ndo you wish to overwrite it?", "File Exists", JOptionPane.YES_NO_OPTION);
                        if (choice == 1)
                            saveData = false;
                    }
                    if (saveData) {
                        Vector<Integer> profileIndexes = new Vector<Integer>();
                        if (allProfiles) {
                            for (int i = 0; i < lsProfiles.size(); i++)
                                profileIndexes.add(i);
                        }
                        else {
                            int indexes[] = listProfileList.getSelectedIndexes();
                            for (int i = 0; i < indexes.length; i++)
                                profileIndexes.add(indexes[i]);
                        }
                        
                        Vector<Integer> functionIndexes = new Vector<Integer>();
                        if (allProfiles) {
                            for (int i = 0; i < lsFunctions.size(); i++)
                                functionIndexes.add(i);
                        }
                        else {
                            int indexes[] = listProfileFunctionList.getSelectedIndexes();
                            for (int i = 0; i < indexes.length; i++)
                                functionIndexes.add(indexes[i]);
                        }
                        
                        try {
                            FileWriter fw = new FileWriter(strFile);
                            PrintWriter pw = new PrintWriter(fw);
                            
                            // Loop through the desired profiles and write the necessary data.
                            
                            // First write the appropriate column headers
                            for (int i = 0; i < profileIndexes.size(); i++) {
                                String profileLabel;
                                switch (lsProfiles.elementAt(profileIndexes.elementAt(i)).channel) {
                                   case 0:
                                       profileLabel = "Profile " + (profileIndexes.elementAt(i) + 1) + ": " + lsCh1Label;
                                       break;
                                   case 1:
                                       profileLabel = "Profile " + (profileIndexes.elementAt(i) + 1) + ": " + lsCh2Label;
                                       break;
                                   case 2:
                                       profileLabel = "Profile " + (profileIndexes.elementAt(i) + 1) + ": " + lsCh3Label;
                                       break;
                                   case 3:
                                       profileLabel = "Profile " + (profileIndexes.elementAt(i) + 1) + ": " + lsCh4Label;
                                       break;
                                   default:
                                       profileLabel = "Unknown channel";
                               }
                                if (i > 0)
                                    pw.print(",");
                                pw.print(profileLabel);
                                pw.print(",");
                                pw.print(profileLabel);
                            }
                            
                            for (int i = 0; i < functionIndexes.size(); i++) {
                                String functionLabel = lsFunctions.elementAt(functionIndexes.elementAt(i)).functionName + " : " + lsFunctions.elementAt(functionIndexes.elementAt(i)).functionExpression;
                                if (profileIndexes.size() > 0)
                                   pw.print(",");
                                else {
                                    if (i > 0)
                                        pw.print(",");
                                }
                                pw.print(functionLabel);
                                pw.print(",");
                                pw.print(functionLabel);
                            }
                            
                            pw.println();
                            
                            for (int i = 0; i < profileIndexes.size(); i++) {
                                if (i > 0)
                                    pw.print(",");
                                pw.print("time(ms)");
                                pw.print(",");
                                pw.print("intensity");
                            }
                            
                            for (int i = 0; i < functionIndexes.size(); i++) {
                                if (profileIndexes.size() > 0)
                                   pw.print(",");
                                else {
                                    if (i > 0)
                                        pw.print(",");
                                }
                                pw.print("time(ms)");
                                pw.print(",");
                                pw.print("intensity");
                            }
                            
                            pw.println();
                            
                            // Now write the actual profile data
                            for (int i = 0; i < lsNumLines; i++) {
                                for (int j = 0; j < profileIndexes.size(); j++) {
                                    if (j > 0)
                                        pw.print(",");
                                    pw.print(lsProfiles.elementAt(profileIndexes.elementAt(j)).time[i]);
                                    pw.print(",");
                                    pw.print(lsProfiles.elementAt(profileIndexes.elementAt(j)).intensity[i]);
                                }
                                for (int j = 0; j < functionIndexes.size(); j++) {
                                    if (profileIndexes.size() > 0)
                                       pw.print(",");
                                    else {
                                        if (j > 0)
                                            pw.print(",");
                                    }
                                    pw.print(lsFunctions.elementAt(functionIndexes.elementAt(j)).time[i]);
                                    pw.print(",");
                                    pw.print(lsFunctions.elementAt(functionIndexes.elementAt(j)).intensity[i]);
                                }
                                pw.println();
                            }
                            
                            pw.flush();
                            pw.close();
                            fw.close();
                        }
                        catch (java.io.IOException exc) {
                            try {
                                FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                                PrintStream logStream = new PrintStream(logFile);
                                exc.printStackTrace(logStream);
                                logStream.flush();
                                logStream.close();
                                logFile.flush();
                                logFile.close();
                            } catch (IOException exception) {}
                        }
                    }
                    
                    // Now save the analog data if necessary.
                    if (saveAnalogData) {
                        // This data will be saved to a separate file with the same basic naming structure
                        strFile = strFile.replace("Profiles.csv", "AnalogData.csv");
                        
                        selectedFile = new File(strFile);
                        
                        try {
                            FileWriter fw = new FileWriter(strFile);
                            PrintWriter pw = new PrintWriter(fw);

                            // Loop through the analog data channels and write the necessary data.

                            // First write the appropriate column headers
                            int columnsCreated = 0;
                            for (int i = 0; i < lsAnalogData.size(); i++) {
                                if (lsAnalogData.elementAt(i).status) {
                                    String dataLabel;
                                    if (lsAnalogData.elementAt(i).name == "")
                                        dataLabel = "N/A";
                                    else
                                        dataLabel = lsAnalogData.elementAt(i).name;
                                    if (columnsCreated > 0)
                                        pw.print(",");
                                    pw.print(dataLabel);
                                    pw.print(",");
                                    pw.print(dataLabel);
                                    columnsCreated++;
                                }
                            }
                            
                            for (int i = 0; i < lsAnalogDataFunctions.size(); i++) {
                                String functionLabel = lsAnalogDataFunctions.elementAt(i).functionName + " : " + lsAnalogDataFunctions.elementAt(i).functionExpression;
                                pw.print(",");
                                pw.print(functionLabel);
                                pw.print(",");
                                pw.print(functionLabel);
                            }
                            
                            pw.println();

                            columnsCreated = 0;
                            for (int i = 0; i < lsAnalogData.size(); i++) {
                                if (lsAnalogData.elementAt(i).status) {
                                    String dataUnits;
                                    if (lsAnalogData.elementAt(i).units == "")
                                        dataUnits = "N/A";
                                    else
                                        dataUnits = lsAnalogData.elementAt(i).units;
                                    if (columnsCreated > 0)
                                        pw.print(",");
                                    pw.print("time(ms)");
                                    pw.print(",");
                                    pw.print(dataUnits);
                                    columnsCreated++;
                                }
                            }
                            
                            for (int i = 0; i < lsAnalogDataFunctions.size(); i++) {
                                pw.print(",");
                                pw.print("time(ms)");
                                pw.print(",");
                                pw.print("N/A");
                            }
                            
                            pw.println();

                            // Determine the number of data entries for an analog data collection.
                            int timeSamples = 0;
                            for (int i = 0; i < 8; i++) {
                                if (lsAnalogData.elementAt(i).status) {
                                    timeSamples = lsAnalogData.elementAt(i).time.size();
                                    i = 8;
                                }
                            }
                            
                            // Now write the actual analog data
                            for (int i = 0; i < timeSamples; i++) {
                                columnsCreated = 0;
                                for (int j = 0; j < lsAnalogData.size(); j++) {
                                    if (lsAnalogData.elementAt(j).status) {
                                        if (columnsCreated > 0)
                                            pw.print(",");
                                        pw.print(lsAnalogData.elementAt(j).time.elementAt(i));
                                        pw.print(",");
                                        pw.print(lsAnalogData.elementAt(j).data.elementAt(i));
                                        columnsCreated++;
                                    }
                                }
                                
                                // write any analog data function data
                                for (int j = 0; j < lsAnalogDataFunctions.size(); j++) {
                                    pw.print(",");
                                    pw.print(lsAnalogDataFunctions.elementAt(j).time[i]);
                                    pw.print(",");
                                    pw.print(lsAnalogDataFunctions.elementAt(j).intensity[i]);
                                }
                                
                                pw.println();
                            }

                            pw.flush();
                            pw.close();
                            fw.close();
                        }
                        catch (java.io.IOException exc) {
                            try {
                                FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                                PrintStream logStream = new PrintStream(logFile);
                                exc.printStackTrace(logStream);
                                logStream.flush();
                                logStream.close();
                                logFile.flush();
                                logFile.close();
                            } catch (IOException exception) {}
                        }
                    }
                }
                else {
                    //IJ.showStatus("file not selected");
                }
                //**************** original code follows *****************************
                
//                // This plot will always be present.
//                lsPlotWindow.show();
//                
//                // If more than one channel is present in the data set, only show the plots for channels
//                // that have profiles created for them and that are currently selected.
//                if (lsNumChans > 1) {
//                    int numCh1Profiles = 0;
//                    int numCh2Profiles = 0;
//                    int numCh3Profiles = 0;
//                    int numCh4Profiles = 0;
//                    int indexes[] = listProfileList.getSelectedIndexes();
//                    for (int i = 0; i < indexes.length; i++) {
//                        if (lsProfiles.elementAt(indexes[i]).channel == 0)
//                            numCh1Profiles++;
//                        else if (lsProfiles.elementAt(indexes[i]).channel == 1)
//                            numCh2Profiles++;
//                        else if (lsProfiles.elementAt(indexes[i]).channel == 2)
//                            numCh3Profiles++;
//                        else if (lsProfiles.elementAt(indexes[i]).channel == 3)
//                            numCh4Profiles++;
//                    }
//                    if (numCh1Profiles > 0)
//                        lsPlotSingleChannelWindow1.show();
//                    if (numCh2Profiles > 0)
//                        lsPlotSingleChannelWindow2.show();
//                    if (numCh3Profiles > 0)
//                        lsPlotSingleChannelWindow3.show();
//                    if (numCh4Profiles > 0)
//                        lsPlotSingleChannelWindow4.show();
//                }
            }
            
            private void jSliderProfileWidthMouseDragged(java.awt.event.MouseEvent evt) {
                // TODO add your handling code here:
                int width = (2 * jSliderProfileWidth.getValue()) + 1;
                updateProfileWidthDisplay(width);
            
               int indexes[] = listProfileList.getSelectedIndexes();
               if (indexes.length == 1) {
                   // Only one profile is selected so update the width setting for that profile.
                   // But first make sure that the width setting will not exceed the image boundaries.
                   if (((lsProfiles.elementAt(indexes[0]).position - width) >= 0) && ((lsProfiles.elementAt(indexes[0]).position + width) < lsPixelsPerLine)) {
                       lsProfiles.elementAt(indexes[0]).width = width;
                       UpdateProfiles();
                   }
                   // Reselect the list item since it is unselected by this action.
                   listProfileList.select(indexes[0]);
                }
            }

            private void jSliderProfileWidthMouseReleased(java.awt.event.MouseEvent evt) {
                // TODO add your handling code here:
                int width = (2 * jSliderProfileWidth.getValue()) + 1;
                updateProfileWidthDisplay(width);
            
               int indexes[] = listProfileList.getSelectedIndexes();
               if (indexes.length == 1) {
                   // Only one profile is selected so update the width setting for that profile.
                   // But first make sure that the width setting will not exceed the image boundaries.
                   if (((lsProfiles.elementAt(indexes[0]).position - width) >= 0) && ((lsProfiles.elementAt(indexes[0]).position + width) < lsPixelsPerLine)) {
                       lsProfiles.elementAt(indexes[0]).width = width;
                       UpdateProfiles();
                   }
                   // Reselect the list item since it is unselected by this action.
                   listProfileList.select(indexes[0]);
                }
            }
            
            private void updateProfileWidthDisplay(int width) {
                jLabelProfileWidthValue.setText(String.valueOf(width));
            }
                
            private void jComboBoxIntensityMethodActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateProfiles();
            }

            private void jCheckBoxThresholdProfileActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                int indexes[] = listProfileList.getSelectedIndexes();
                if (indexes.length == 1) {
                    lsProfiles.elementAt(indexes[0]).threshold = jCheckBoxThresholdProfile.isSelected();
                    UpdateProfiles();    
                }
            }
            
            private void setControlsForThresholdEdit(boolean controlState) {
                jScrollBarThresholdMin.setEnabled(controlState);
                jLabelThresholdMin.setEnabled(controlState);
                jLabelThresholdMinValue.setEnabled(controlState);
                jButtonThresholdMinReset.setEnabled(controlState);
                jScrollBarThresholdMax.setEnabled(controlState);
                jLabelThresholdMax.setEnabled(controlState);
                jLabelThresholdMaxValue.setEnabled(controlState);
                jButtonThresholdMaxReset.setEnabled(controlState);
                
                jCheckBoxThresholdProfile.setEnabled(!controlState);
                jLabelChannelSelection1.setEnabled(!controlState);
                jLabelChannelSelection2.setEnabled(!controlState);
                jComboBoxChannelSelection.setEnabled(!controlState);
                jButtonCreateProfile.setEnabled(!controlState);
                listProfileList.setEnabled(!controlState);
                jLabelProfileSelection1.setEnabled(!controlState);
                jCheckBoxProfilesInSeparateWindows.setEnabled(!controlState);
                jCheckBoxThresholdProfile.setEnabled(!controlState);
                jButtonCopyProfiles.setEnabled(!controlState);
                jButtonPasteProfiles.setEnabled(!controlState);
                jButtonDeleteProfile.setEnabled(!controlState);
                jButtonDeleteAllProfiles.setEnabled(!controlState);
                jButtonExportSelectedProfiles.setEnabled(!controlState);
                jButtonExportAllProfiles.setEnabled(!controlState);
                jLabelProfileWidth.setEnabled(!controlState);
                jLabelProfileWidthValue.setEnabled(!controlState);
                jSliderProfileWidth.setEnabled(!controlState);
                jLabelIntensityMethod1.setEnabled(!controlState);
                jLabelIntensityMethod2.setEnabled(!controlState);
                jComboBoxIntensityMethod.setEnabled(!controlState);
                jLabelProfileColor1.setEnabled(!controlState);
                jButtonSelectProfileColor.setEnabled(!controlState);
                jPanelProfileColor.setEnabled(!controlState);
                jScrollBarProfilePosition.setEnabled(!controlState);
                jLabelProfilePosition1.setEnabled(!controlState);
                jLabelProfilePosition2.setEnabled(!controlState);
            }
            
            private void jToggleButtonThresholdEditActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                int indexes[] = listProfileList.getSelectedIndexes();
                if ((indexes.length == 1) && (lsProfiles.elementAt(indexes[0]).width > 1)) {
                    if (jToggleButtonThresholdEdit.isSelected()) {
                        jToggleButtonThresholdEdit.setText("Done");
                        setControlsForThresholdEdit(true);
                        // Set the maximum scrollbar values based upon the image data limits
                        double yMax = 4095.0;
                        String chanName = "";
                        if (lsNumChans == 1) {
                            yMax = lsYMax;
//                            switch (lsProfiles.elementAt(indexes[0]).channel) {
//                                case 0:
//                                    yMax = lsYMax1;
//                                    chanName = lsCh1Label;
//                                    break;
//                                case 1:
//                                    yMax = lsYMax2;
//                                    chanName = lsCh2Label;
//                                    break;
//                                case 2:
//                                    yMax = lsYMax3;
//                                    chanName = lsCh3Label;
//                                    break;
//                                case 3:
//                                    yMax = lsYMax4;
//                                    chanName = lsCh4Label;
//                                    break;
//                            }
                        }
                        else {
                            switch (lsProfiles.elementAt(indexes[0]).channel) {
                                case 0:
                                    yMax = lsYMax1;
                                    chanName = lsCh1Label;
                                    break;
                                case 1:
                                    yMax = lsYMax2;
                                    chanName = lsCh2Label;
                                    break;
                                case 2:
                                    yMax = lsYMax3;
                                    chanName = lsCh3Label;
                                    break;
                                case 3:
                                    yMax = lsYMax4;
                                    chanName = lsCh4Label;
                                    break;
                            }
                        }
                        jScrollBarThresholdMax.setMaximum((int)yMax + 10);
                        jScrollBarThresholdMin.setMaximum((int)yMax + 10);
                        // Set the values for the Min and Max sliders to 
                        // the current values for the selected profile
                        jScrollBarThresholdMin.setValue((int)lsProfiles.elementAt(indexes[0]).thresholdMin);
                        jLabelThresholdMinValue.setText(String.valueOf((int)lsProfiles.elementAt(indexes[0]).thresholdMin));
                        jScrollBarThresholdMax.setValue((int)lsProfiles.elementAt(indexes[0]).thresholdMax);
                        jLabelThresholdMaxValue.setText(String.valueOf((int)lsProfiles.elementAt(indexes[0]).thresholdMax));
                        
                        // Create the image window that will be used for displaying the profile selection
                    }
                    else {
                        jToggleButtonThresholdEdit.setText("Edit");
                        setControlsForThresholdEdit(false);
                    }
                }
                else
                    jToggleButtonThresholdEdit.setSelected(false);
            }

            private void jScrollBarThresholdMinAdjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {
                // TODO add your handling code here:
                // Make sure that the minimum value does not exceed the maximum value
                int indexes[] = listProfileList.getSelectedIndexes();
                int minValue = jScrollBarThresholdMin.getValue();
                if (minValue < lsProfiles.elementAt(indexes[0]).thresholdMax) {
                    lsProfiles.elementAt(indexes[0]).thresholdMin = minValue;
                    jLabelThresholdMinValue.setText(String.valueOf(minValue));
                }
                else {
                    int maxValue = minValue + 1;
                    if (maxValue <= jScrollBarThresholdMin.getMaximum()) {
                        lsProfiles.elementAt(indexes[0]).thresholdMax = maxValue;
                        jScrollBarThresholdMax.setValue(maxValue);
                        jLabelThresholdMaxValue.setText(String.valueOf(maxValue));
                    }
                    else {
                        maxValue = jScrollBarThresholdMin.getMaximum();
                        minValue = maxValue - 1;
                        lsProfiles.elementAt(indexes[0]).thresholdMin = minValue;
                        jScrollBarThresholdMin.setValue(minValue);
                        jLabelThresholdMinValue.setText(String.valueOf(minValue));
                        lsProfiles.elementAt(indexes[0]).thresholdMax = maxValue;
                        jScrollBarThresholdMax.setValue(maxValue);
                        jLabelThresholdMaxValue.setText(String.valueOf(maxValue));
                    }
                }
                // Call the routine to update the 'thresholded' profile image
                
                UpdateProfiles();
            }

            private void jScrollBarThresholdMaxAdjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {
                // TODO add your handling code here:
                // Make sure that the maximum value does not exceed the maximum value
                int indexes[] = listProfileList.getSelectedIndexes();
                int maxValue = jScrollBarThresholdMax.getValue();
                if (maxValue > lsProfiles.elementAt(indexes[0]).thresholdMin) {
                    lsProfiles.elementAt(indexes[0]).thresholdMax = maxValue;
                    jLabelThresholdMaxValue.setText(String.valueOf(maxValue));
                }
                else {
                    int minValue = maxValue - 1;
                    if (minValue >= 0) {
                        lsProfiles.elementAt(indexes[0]).thresholdMin = minValue;
                        jScrollBarThresholdMin.setValue(minValue);
                        jLabelThresholdMinValue.setText(String.valueOf(minValue));
                    }
                    else {
                        minValue = 0;
                        maxValue = minValue + 1;
                        lsProfiles.elementAt(indexes[0]).thresholdMin = minValue;
                        jScrollBarThresholdMin.setValue(minValue);
                        jLabelThresholdMinValue.setText(String.valueOf(minValue));
                        lsProfiles.elementAt(indexes[0]).thresholdMax = maxValue;
                        jScrollBarThresholdMax.setValue(maxValue);
                        jLabelThresholdMaxValue.setText(String.valueOf(maxValue));
                    }
                }
                // Call the routine to update the 'thresholded' profile image
                
                UpdateProfiles();
            }

            private void jButtonThresholdMinResetActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                int indexes[] = listProfileList.getSelectedIndexes();
                jScrollBarThresholdMin.setValue(0);
                jLabelThresholdMinValue.setText("0");
                lsProfiles.elementAt(indexes[0]).thresholdMin = 0;
                UpdateProfiles();
            }

            private void jButtonThresholdMaxResetActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                int indexes[] = listProfileList.getSelectedIndexes();
                jScrollBarThresholdMax.setValue(jScrollBarThresholdMax.getMaximum() - 10);
                jLabelThresholdMaxValue.setText(String.valueOf(jScrollBarThresholdMax.getMaximum() - 10));
                lsProfiles.elementAt(indexes[0]).thresholdMax = jScrollBarThresholdMax.getMaximum() - 10;
                UpdateProfiles();
            }

            
            private void jButtonSelectProfileColorActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                // Present the color chooser dialog to the operator
                Color profileColor = JColorChooser.showDialog(this, "Select Profile Color", jPanelProfileColor.getBackground());
                if (profileColor != null) {
                    jPanelProfileColor.setBackground(profileColor);
                
                    int indexes[] = listProfileList.getSelectedIndexes();
                    if (indexes.length == 1) {
                        // Only one profile is selected so update the color setting for that profile.
                        lsProfiles.elementAt(indexes[0]).color = profileColor;
                        UpdateProfiles();
                       // Reselect the list item since it is unselected by this action.
                       listProfileList.select(indexes[0]);
                    }
                }
            }
            
            private void jButtonSelectFunctionColorActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                // Present the color chooser dialog to the operator
                Color functionColor = JColorChooser.showDialog(this, "Select Function Color", jPanelProfileColor.getBackground());
                if (functionColor != null) {
                    jPanelFunctionColor.setBackground(functionColor);
                
                    int indexes[] = listProfileFunctionList.getSelectedIndexes();
                    if (indexes.length == 1) {
                        // Only one profile is selected so update the color setting for that profile.
                        lsFunctions.elementAt(indexes[0]).color = functionColor;
                        UpdateProfiles();
                       // Reselect the list item since it is unselected by this action.
                       listProfileFunctionList.select(indexes[0]);
                    }
                }
           }
            
            private void jButtonCopyProfilesActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                CopySelectedProfiles();
            }

            private void jButtonPasteProfilesActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                PasteProfiles();
            }
            
            private void jButtonDeleteProfileActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                // If no profiles are selected or non exist, then merely exit
                if (lsProfiles.size() == 0)
                    return;
                int indexes[] = listProfileList.getSelectedIndexes();
                if (indexes.length == 0)
                    return;
                
                boolean deleteProfiles = IJ.showMessageWithCancel("Delete Selected Profiles", "Are you sure you want to delete the selected profiles?\n\nAny Profiles created in Prairie View will not be deleted!");
                if (deleteProfiles) {
                    // Loop through the selected "indexes" backward, deleting the selected profiles.
                    for (int i = indexes.length - 1; i >= 0; i--) {
                        // Don't delete any profiles that were created in Prairie View
                        if (!lsProfiles.elementAt(indexes[i]).prairieViewProfile) {
                            // Close the graph window before removing it from the list
                            lsProfiles.elementAt(indexes[i]).imagePlusPlotWindow.close();
                            lsProfiles.removeElementAt(indexes[i]);
                        }
                    }

                    // Loop through the selected "indexes" and "deselect" them
                    for (int i = indexes.length - 1; i >= 0; i--) {
                        if (!lsProfiles.elementAt(indexes[i]).prairieViewProfile)
                            listProfileList.deselect(indexes[i]);
                    }

                    UpdateProfiles();
                }
            }

            private void jButtonDeleteAllProfilesActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                if (lsProfiles.size() == 0)
                    return;
                boolean deleteProfiles = IJ.showMessageWithCancel("Delete All Profiles", "Are you sure you want to delete all profiles?\n\nAny Profiles created in Prairie View will not be deleted!");
                if (deleteProfiles) {
                    int numProfiles = lsProfiles.size();
                    for (int i = numProfiles - 1; i >= 0; i--) {
                        // Don't delete any profiles that were created in Prairie View
                        if (!lsProfiles.elementAt(i).prairieViewProfile) {
                            // Close the graph window before removing it from the list
                            lsProfiles.elementAt(i).imagePlusPlotWindow.close();
                            lsProfiles.removeElementAt(i);
                        }
                    }
                    //lsProfiles.clear();
                    UpdateProfiles();
                }
            }

            private void listProfileListMouseReleased(java.awt.event.MouseEvent evt) {
                // TODO add your handling code here:
                int indexes[] = listProfileList.getSelectedIndexes();
                if (indexes.length == 1) {
                    // Only one profile is selected so update the width, color, and position controls 
                    // to reflect this profile's setting.
                    jPanelProfileColor.setBackground(lsProfiles.elementAt(indexes[0]).color);
                    updateProfileWidthDisplay(lsProfiles.elementAt(indexes[0]).width);
                    jSliderProfileWidth.setValue((lsProfiles.elementAt(indexes[0]).width / 2) - 1);
                    jScrollBarProfilePosition.setValue(lsProfiles.elementAt(indexes[0]).position);
                    // Also update the threshold checkbox
                    jCheckBoxThresholdProfile.setSelected(lsProfiles.elementAt(indexes[0]).threshold);
                    jCheckBoxThresholdProfile.setEnabled(true);
                    jToggleButtonThresholdEdit.setEnabled(true);
                }
                else {
                    jCheckBoxThresholdProfile.setEnabled(false);
                    jToggleButtonThresholdEdit.setEnabled(false);
                }
                UpdateProfiles();
            }

            private void jButtonExportSelectedProfilesActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                if (lsProfiles.size() == 0) {
                    IJ.showMessage("No profiles exist!");
                    return;
                }
                
                int[] originalProfiles = listProfileList.getSelectedIndexes();
                int[] originalFunctions = listProfileFunctionList.getSelectedIndexes();
                if ((originalProfiles.length == 0) && (originalFunctions.length == 0)) {
                    IJ.showMessage("No Profile(s) or Function(s) are selected!");
                    return;
                }
                
                // Select all of the analog data functions
                for (int i = 0; i < lsAnalogDataFunctions.size(); i++)
                    listAnalogDataFunctionList.select(i);
                
                UpdateProfiles();
                SaveProfiles(false);
            }

            private void jButtonExportAllProfilesActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                if (lsProfiles.size() == 0) {
                    IJ.showMessage("No profiles exist!");
                    return;
                }
                
                // Select all of the profiles
                for (int i = 0; i < lsProfiles.size(); i++)
                    listProfileList.select(i);
                
                // Select all of the profile functions
                for (int i = 0; i < lsFunctions.size(); i++)
                    listProfileFunctionList.select(i);
                
                // Select all of the analog data functions
                for (int i = 0; i < lsAnalogDataFunctions.size(); i++)
                    listAnalogDataFunctionList.select(i);
                
                UpdateProfiles();
                SaveProfiles(true);
            }
            
            private void UpdateProfilePosition (int positionDelta) {
                if (positionDelta == 0)
                    return;
                
                int indexes[] = listProfileList.getSelectedIndexes();
                
                if (indexes.length == 0)
                    return;
                
                if (indexes.length == 1) {
                   // Only one profile is selected so update the position for that profile.
                   // But first make sure that the position will not exceed the image boundaries.
                   int width = lsProfiles.elementAt(indexes[0]).width;
                   int position = jScrollBarProfilePosition.getValue();
                   if (width == 1) {
                       lsProfiles.elementAt(indexes[0]).position = position;
                   }
                   else {
                       int minLine = position - ((width - 1) / 2);
                       int maxLine = position + ((width - 1) / 2);
                       if ((minLine >= 0) && (maxLine < lsPixelsPerLine))
                            lsProfiles.elementAt(indexes[0]).position = position;
                   }
                }
                else {
                    // More than one profile is selected, so compute the position for each of the 
                    // selected profiles and if any of them are outside of the image boundaries, do
                    // not update any of them.
                    boolean outsideLimits = false;
                    int position = jScrollBarProfilePosition.getValue();
                    for (int i = 0; i < indexes.length; i++) {
                        int width = lsProfiles.elementAt(indexes[i]).width;
                        if (width == 1) {
                            if (((lsProfiles.elementAt(indexes[i]).position + positionDelta) < 0) || ((lsProfiles.elementAt(indexes[i]).position + positionDelta) >= lsPixelsPerLine))
                                outsideLimits = true;
                        }
                        else {
                            int minLine = lsProfiles.elementAt(indexes[i]).position + positionDelta - ((width - 1) / 2);
                            int maxLine = lsProfiles.elementAt(indexes[i]).position + positionDelta + ((width - 1) / 2);
                            if ((minLine < 0) || (maxLine >= lsPixelsPerLine))
                                outsideLimits = true;
                        }
                    }
                    if (outsideLimits == false) {
                        // All of the selected Profiles can be safely moved, so adjust their positions
                        for (int i = 0; i < indexes.length; i++) {
                            lsProfiles.elementAt(indexes[i]).position += positionDelta;
                        }
                    }
                }
                
                UpdateProfiles();

                // Reselect the list item since it is unselected by this action.
                listProfileList.select(indexes[0]);
            }
            
            private int lastPosition = 0;
            private boolean firstMove = true;
            
            private void jScrollBarProfilePositionAdjustmentValueChanged(java.awt.event.AdjustmentEvent evt) {
                // TODO add your handling code here:
                if (firstMove) {
                    lastPosition = jScrollBarProfilePosition.getValue();
                    firstMove = false;
                }
                UpdateProfilePosition(jScrollBarProfilePosition.getValue() - lastPosition);
                lastPosition = jScrollBarProfilePosition.getValue();
            }

            private void jButtonProfileCreateFunctionActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                functionEditorCreateMode = true;
                FunctionEditor fe = new FunctionEditor(lsDialogParentFrame, true, 0);
                fe.setVisible(true);
                fe.toFront();
                
                if (!functionEditorCanceled) {
                    // Function Editor was not canceled, so update the function profiles list.
                    LSFunctionSettings lsFunc = new LSFunctionSettings();
                    lsFunc.functionName = PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName;
                    lsFunc.functionExpression = PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionExpression;
                    lsFunc.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Function " + PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName, "Time (ms)", "Intensity");
                    //lsFunc.plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
                    lsFunc.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Function " + PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName, lsFunc.plotWindow.getProcessor());
                    lsFunctions.add(lsFunc);
                    UpdateProfiles();
                }
            }

            private void jButtonProfileEditFunctionActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                if (lsFunctions.isEmpty())
                    return;
                int indexes[] = listProfileFunctionList.getSelectedIndexes();
                if (indexes.length > 1)
                    return;
                functionEditorCreateMode = false;
                functionEditorFunctionName = lsFunctions.elementAt(indexes[0]).functionName;
                String functionExpression = lsFunctions.elementAt(indexes[0]).functionExpression;
                FunctionEditor fe = new FunctionEditor(lsDialogParentFrame, true, 0);
                fe.setVisible(true);
                fe.toFront();
                
                if (!functionEditorCanceled) {
                    // Function Editor was not canceled, so update the function profiles list.
                    
                    // First, loop through the functions and compare
                    // the original function name (before the editor was called) with the list of
                    // current function names and see if there is a match.  If so, update the function
                    // definition.
                    boolean matchFound = false;
                    for (int j = 0; j < PrairieReaderFunctions.size(); j++) {
                        if (functionEditorFunctionName.equalsIgnoreCase(PrairieReaderFunctions.elementAt(j).functionName)) {
                            matchFound = true;
                            lsFunctions.elementAt(indexes[0]).functionName = PrairieReaderFunctions.elementAt(j).functionName;
                            lsFunctions.elementAt(indexes[0]).functionExpression = PrairieReaderFunctions.elementAt(j).functionExpression;
                        }
                    }
                   
                    // If no match was found, compare the function definitions since this might point to just
                    // a changed function name.
                    if (!matchFound) {
                        for (int j = 0; j < PrairieReaderFunctions.size(); j++) {
                            if (functionExpression.equalsIgnoreCase(PrairieReaderFunctions.elementAt(j).functionExpression)) {
                                matchFound = true;
                                lsFunctions.elementAt(indexes[0]).functionName = PrairieReaderFunctions.elementAt(j).functionName;
                                lsFunctions.elementAt(indexes[0]).functionExpression = PrairieReaderFunctions.elementAt(j).functionExpression;
                            }
                        }
                    }
                    
                    // If a match has still not been found, then remove this function from the function list
                    if (!matchFound) {
                        IJ.showMessage("The function to be edited, \"functionEditorFunctionName\", appears to be deleted!");
                        for (int i = indexes.length - 1; i >= 0; i--) {
                            // Close the graph window before removing it from the list
                            lsFunctions.elementAt(indexes[i]).imagePlusPlotWindow.close();
                            lsFunctions.removeElementAt(indexes[i]);
                        }

                        // Loop through the selected "indexes" and "deselect" them
                        for (int i = indexes.length - 1; i >= 0; i--) {
                            listProfileFunctionList.deselect(indexes[i]);
                        }
                    }
                    
//                    LSFunctionSettings lsFunc = new LSFunctionSettings();
//                    lsFunc.functionName = PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName;
//                    lsFunc.functionExpression = PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionExpression;
//                    lsFunc.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Function " + PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName, "Time (ms)", "Intensity");
//                    //lsFunc.plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
//                    lsFunc.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Function " + PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName, lsFunc.plotWindow.getProcessor());
//                    lsFunctions.add(lsFunc);
                    UpdateProfiles();
                }
            }

            private void jButtonProfileRemoveFunctionActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                // If no functions are selected or non exist, then merely exit
                if (lsFunctions.isEmpty())
                    return;
                int indexes[] = listProfileFunctionList.getSelectedIndexes();
                if (indexes.length == 0)
                    return;
                
                boolean deleteFunctions = IJ.showMessageWithCancel("Delete Selected Functions", "Are you sure you want to delete the selected functions?");
                if (deleteFunctions) {
                    // Loop through the selected "indexes" backward, deleting the selected functions.
                    for (int i = indexes.length - 1; i >= 0; i--) {
                        // Close the graph window before removing it from the list
                        lsFunctions.elementAt(indexes[i]).imagePlusPlotWindow.close();
                        lsFunctions.removeElementAt(indexes[i]);
                    }

                    // Loop through the selected "indexes" and "deselect" them
                    for (int i = indexes.length - 1; i >= 0; i--) {
                        listProfileFunctionList.deselect(indexes[i]);
                    }

                    UpdateProfiles();
                }
            }

            private void jButtonProfileClearFunctionsActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                if (lsFunctions.size() == 0)
                    return;
                boolean deleteFunctions = IJ.showMessageWithCancel("Delete All Functions", "Are you sure you want to delete all functions?");
                if (deleteFunctions) {
                    int numFunctions = lsFunctions.size();
                    for (int i = numFunctions - 1; i >= 0; i--) {
                        // Close the graph window before removing it from the list
                        lsFunctions.elementAt(i).imagePlusPlotWindow.close();
                        lsFunctions.removeElementAt(i);
                    }
                    //lsProfiles.clear();
                    UpdateProfiles();
                }
            }
            
            private void listProfileFunctionListMouseReleased(java.awt.event.MouseEvent evt) {
                // TODO add your handling code here:
                int indexes[] = listProfileFunctionList.getSelectedIndexes();
                
                if (indexes.length == 1) {
                    // Only one function is selected so update the color control with this 
                    // functions's setting.
                    jPanelFunctionColor.setBackground(lsFunctions.elementAt(indexes[0]).color);
                }
                UpdateProfiles();
            }

            private void jCheckBoxApplyTriggerSyncScalingActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateAnalogDisplay();
            }

            private void jToggleButtonAI0ActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateAnalogDisplay();
            }

            private void jToggleButtonAI1ActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateAnalogDisplay();
            }

            private void jToggleButtonAI2ActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateAnalogDisplay();
            }

            private void jToggleButtonAI3ActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateAnalogDisplay();
            }

            private void jToggleButtonAI4ActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateAnalogDisplay();
            }

            private void jToggleButtonAI5ActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateAnalogDisplay();
            }

            private void jToggleButtonAI6ActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateAnalogDisplay();
            }

            private void jToggleButtonAI7ActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateAnalogDisplay();
            }
            
            private void jCheckBoxProfilesInSeparateWindowsActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                UpdateProfileDisplayOption(jCheckBoxProfilesInSeparateWindows.isSelected());
            }
            
            private void jButtonAnalogDataCreateFunctionActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                functionEditorCreateMode = true;
                FunctionEditor fe = new FunctionEditor(lsDialogParentFrame, true, 1);
                fe.setVisible(true);
                fe.toFront();
                
                if (!functionEditorCanceled) {
                    // Function Editor was not canceled, so update the function profiles list.
                    LSAnalogDataFunctionSettings lsFunc = new LSAnalogDataFunctionSettings();
                    lsFunc.functionName = PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName;
                    lsFunc.functionExpression = PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionExpression;
                    lsFunc.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Function " + PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName, "Time (ms)", "Intensity");
                    //lsFunc.plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
                    lsFunc.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Function " + PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName, lsFunc.plotWindow.getProcessor());
                    lsAnalogDataFunctions.add(lsFunc);
                    UpdateProfiles();
                }
            }

            private void jButtonAnalogDataEditFunctionActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                if (lsAnalogDataFunctions.isEmpty())
                    return;
                int indexes[] = listAnalogDataFunctionList.getSelectedIndexes();
                if (indexes.length > 1)
                    return;
                functionEditorCreateMode = false;
                functionEditorFunctionName = lsAnalogDataFunctions.elementAt(indexes[0]).functionName;
                String functionExpression = lsAnalogDataFunctions.elementAt(indexes[0]).functionExpression;
                FunctionEditor fe = new FunctionEditor(lsDialogParentFrame, true, 1);
                fe.setVisible(true);
                fe.toFront();
                
                if (!functionEditorCanceled) {
                    // Function Editor was not canceled, so update the function profiles list.
                    
                    // First, loop through the functions and compare
                    // the original function name (before the editor was called) with the list of
                    // current function names and see if there is a match.  If so, update the function
                    // definition.
                    boolean matchFound = false;
                    for (int j = 0; j < PrairieReaderFunctions.size(); j++) {
                        if (functionEditorFunctionName.equalsIgnoreCase(PrairieReaderFunctions.elementAt(j).functionName)) {
                            matchFound = true;
                            lsAnalogDataFunctions.elementAt(indexes[0]).functionName = PrairieReaderFunctions.elementAt(j).functionName;
                            lsAnalogDataFunctions.elementAt(indexes[0]).functionExpression = PrairieReaderFunctions.elementAt(j).functionExpression;
                        }
                    }
                   
                    // If no match was found, compare the function definitions since this might point to just
                    // a changed function name.
                    if (!matchFound) {
                        for (int j = 0; j < PrairieReaderFunctions.size(); j++) {
                            if (functionExpression.equalsIgnoreCase(PrairieReaderFunctions.elementAt(j).functionExpression)) {
                                matchFound = true;
                                lsAnalogDataFunctions.elementAt(indexes[0]).functionName = PrairieReaderFunctions.elementAt(j).functionName;
                                lsAnalogDataFunctions.elementAt(indexes[0]).functionExpression = PrairieReaderFunctions.elementAt(j).functionExpression;
                            }
                        }
                    }
                    
                    // If a match has still not been found, then remove this function from the function list
                    if (!matchFound) {
                        IJ.showMessage("The function to be edited, \"functionEditorFunctionName\", appears to be deleted!");
                        for (int i = indexes.length - 1; i >= 0; i--) {
                            // Close the graph window before removing it from the list
                            lsAnalogDataFunctions.elementAt(indexes[i]).imagePlusPlotWindow.close();
                            lsAnalogDataFunctions.removeElementAt(indexes[i]);
                        }

                        // Loop through the selected "indexes" and "deselect" them
                        for (int i = indexes.length - 1; i >= 0; i--) {
                            listAnalogDataFunctionList.deselect(indexes[i]);
                        }
                    }
                    
//                    LSFunctionSettings lsFunc = new LSFunctionSettings();
//                    lsFunc.functionName = PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName;
//                    lsFunc.functionExpression = PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionExpression;
//                    lsFunc.plotWindow = new Plot("Prairie Sequence " + lsSequenceNumber + " Function " + PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName, "Time (ms)", "Intensity");
//                    //lsFunc.plotWindow.setLimits(0.0, lsXMax, yMin, yMax);
//                    lsFunc.imagePlusPlotWindow = new ImagePlus("Prairie Sequence " + lsSequenceNumber + " Function " + PrairieReaderFunctions.elementAt(functionEditorSelectedFunction).functionName, lsFunc.plotWindow.getProcessor());
//                    lsFunctions.add(lsFunc);
                    UpdateProfiles();
                }
            }

            private void jButtonAnalogDataRemoveFunctionActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                // If no functions are selected or non exist, then merely exit
                if (lsAnalogDataFunctions.isEmpty())
                    return;
                int indexes[] = listAnalogDataFunctionList.getSelectedIndexes();
                if (indexes.length == 0)
                    return;
                
                boolean deleteFunctions = IJ.showMessageWithCancel("Delete Selected Functions", "Are you sure you want to delete the selected functions?");
                if (deleteFunctions) {
                    // Loop through the selected "indexes" backward, deleting the selected functions.
                    for (int i = indexes.length - 1; i >= 0; i--) {
                        // Close the graph window before removing it from the list
                        lsAnalogDataFunctions.elementAt(indexes[i]).imagePlusPlotWindow.close();
                        lsAnalogDataFunctions.removeElementAt(indexes[i]);
                    }

                    // Loop through the selected "indexes" and "deselect" them
                    for (int i = indexes.length - 1; i >= 0; i--) {
                        listAnalogDataFunctionList.deselect(indexes[i]);
                    }

                    UpdateProfiles();
                }
            }

            private void jButtonAnalogDataClearFunctionsActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                if (lsAnalogDataFunctions.size() == 0)
                    return;
                boolean deleteFunctions = IJ.showMessageWithCancel("Delete All Functions", "Are you sure you want to delete all functions?");
                if (deleteFunctions) {
                    int numFunctions = lsAnalogDataFunctions.size();
                    for (int i = numFunctions - 1; i >= 0; i--) {
                        // Close the graph window before removing it from the list
                        lsAnalogDataFunctions.elementAt(i).imagePlusPlotWindow.close();
                        lsAnalogDataFunctions.removeElementAt(i);
                    }
                    //lsProfiles.clear();
                    UpdateProfiles();
                }
            }

            private void listAnalogDataFunctionListMouseReleased(java.awt.event.MouseEvent evt) {
                // TODO add your handling code here:
                int indexes[] = listAnalogDataFunctionList.getSelectedIndexes();
                
                if (indexes.length == 1) {
                    // Only one function is selected so update the color control with this 
                    // functions's setting.
                    jPanelAnalogDataFunctionColor.setBackground(lsAnalogDataFunctions.elementAt(indexes[0]).color);
                }
                UpdateProfiles();
            }

            private void jButtonAnalogDataSelectFunctionColorActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
                // Present the color chooser dialog to the operator
                Color functionColor = JColorChooser.showDialog(this, "Select Function Color", jPanelProfileColor.getBackground());
                if (functionColor != null) {
                    jPanelAnalogDataFunctionColor.setBackground(functionColor);

                    int indexes[] = listAnalogDataFunctionList.getSelectedIndexes();
                    if (indexes.length == 1) {
                        // Only one profile is selected so update the color setting for that profile.
                        lsAnalogDataFunctions.elementAt(indexes[0]).color = functionColor;
                        UpdateProfiles();
                       // Reselect the list item since it is unselected by this action.
                       listAnalogDataFunctionList.select(indexes[0]);
                    }
                }
            }

            private void listAnalogDataFunctionListActionPerformed(java.awt.event.ActionEvent evt) {
                // TODO add your handling code here:
            }
        }
   
        public class RTFView extends JDialog  {   
            public RTFView(Frame parent, String title, boolean modal)   {   
                super(parent, title, modal);
 		setTitle( "Prairie Reader Revision History" );
                setSize( 900, 400 );
                setBackground( Color.gray );
                getContentPane().setLayout( new BorderLayout() );

                JPanel topPanel = new JPanel();
                topPanel.setLayout( new BorderLayout() );
                getContentPane().add( topPanel, BorderLayout.CENTER );

                // Create an RTF editor window   
                RTFEditorKit rtf = new RTFEditorKit();
                JEditorPane editor = new JEditorPane();
                editor.setEditorKit( rtf );
                editor.setBackground( Color.white );
                editor.setEditable(false);

                // This text could be big so add a scroll pane
                JScrollPane scroller = new JScrollPane();
                scroller.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
                //scroller.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
                scroller.getViewport().add( editor );
                topPanel.add( scroller, BorderLayout.CENTER );
                
                // Load an RTF file into the editor
                try {
                    String ijDir = System.getProperty("user.dir");
                    FileInputStream fi = new FileInputStream(ijDir + "\\plugins\\Input-Output\\IJ Prairie Reader Revision.rtf");
                    rtf.read( fi, editor.getDocument(), 0 );
                }   
                catch( FileNotFoundException e )
                {
                    System.out.println( "File not found" );
                }
                catch( IOException e )
                {
                    System.out.println( "I/O error" );
                }
                catch( BadLocationException e )
                {
                }
                // This will force the display back to the beginning of the document.
                editor.setCaretPosition(0);
            }
        }
        
        Toolkit toolkit;
        Timer timer;
        
        public void FileCheck(int seconds) {
            toolkit = Toolkit.getDefaultToolkit();
            timer = new Timer();
            timer.schedule(new FileCheckTask(), 1000, seconds);
        }
        
        // This original version of 'FileCheckTask' retrieved the .xml file name
        // from a file "C:\\pv-imagej.txt", but the more correct version is the one that
        // follows.
//        class FileCheckTask extends TimerTask {
//            public void run() {
//                File cacheFile = new File("C:\\pv-imagej.txt");
//                if (cacheFile.isFile()) {
//                    try {
//                        BufferedReader in = new BufferedReader(new FileReader(cacheFile));
//                        String strFile;
//                        if ((strFile = in.readLine()) != null) {
//                            // Break the string into a 'directory' segment and a 'filename' segment
//                            int lastSlash = strFile.lastIndexOf("\\");
//                            int strFileLength = strFile.length();
//                            String directory = strFile.substring(0, lastSlash + 1);
//                            String name = strFile.substring(lastSlash + 1, strFileLength);
//                            // Check if the file exists
//                            File dataFile = new File(directory + name);
//                            if (dataFile.isFile()) {
//                                in.close();
//                                cacheFile.delete();
//                                loadFile(directory, name);
//                            }
//                        }
//                        in.close();
//                    } catch (IOException e) {
//                    }
//                }               
//            }
//        }
        
        class FileCheckTask extends TimerTask {
            public void run() {
                if (pathAndFileFromOutside != null) {
                    String strFile = pathAndFileFromOutside;
                    // Break the string into a 'directory' segment and a 'filename' segment
                    int lastSlash = strFile.lastIndexOf("\\");
                    int strFileLength = strFile.length();
                    String directory = strFile.substring(0, lastSlash + 1);
                    String name = strFile.substring(lastSlash + 1, strFileLength);
                    // Check if the file exists
                    File dataFile = new File(directory + name);
                    if (dataFile.isFile()) {
                        pathAndFileFromOutside = null;
                        loadFile(directory, name);
                    }
                    syncFile.release();
                }
                
                if (sequenceFromOutside != -1) {
                    if (sequenceFromOutside > 0 && sequenceFromOutside <= sequenceSelection.getItemCount()) {
                        sequenceSelection.select(sequenceFromOutside - 1);
                        currentSequence = data.Sequences.elementAt(sequenceFromOutside - 1);
                        LoadSequence();
                    }
                    sequenceFromOutside = -1;
                    syncSequence.release();
                }
                
                if (frameFromOutside != -1) {
                    if (frameFromOutside > 0 && frameFromOutside <= frameSelection.getItemCount()) {
                        frameSelection.select(frameFromOutside - 1);
                        currentFrame = currentSequence.Frames.elementAt(frameFromOutside - 1);
                        LoadFrame(false);
                    }
                    frameFromOutside = -1;
                }
            }
        }
        
        static String pathAndFileFromOutside = null;
        static final Semaphore syncFile = new Semaphore(1, true);
        
        public static void SetFile(String pathAndFile) throws InterruptedException {
            if (pathAndFile == null || pathAndFile.isEmpty()) return;
            syncFile.acquire();
            pathAndFileFromOutside = pathAndFile;
        }
        
        static int sequenceFromOutside = -1;
        static final Semaphore syncSequence = new Semaphore(1, true);
	
        public static void SetSequence(int index) throws InterruptedException {
            if (index < 0) return;
            syncSequence.acquire();
            sequenceFromOutside = index;
        }
        
        public static int GetSequenceCount() throws InterruptedException {
            int count = 0;
            syncFile.acquire();
            count = sequenceSelection.getItemCount();
            syncFile.release();
            return count;
        }
        
        static int frameFromOutside = -1;
        
        public static void SetFrame(int index) {
           frameFromOutside = index;
        }
        
        public static int GetFrameCount() throws InterruptedException {
            int count = 0;
            syncSequence.acquire();
            count = frameSelection.getItemCount();
            syncSequence.release();
            return count;
        }
        
	private void LoadSequence() {
            int frameIndex = frameSelection.getSelectedIndex();
            frameSelection.removeAll();
            for(int index = 0; index < currentSequence.Frames.size(); index++)
                    frameSelection.add("Frame " + (index + 1));
            if (frameIndex < 0 || frameIndex >= currentSequence.Frames.size()) frameIndex = 0;
            frameSelection.select(frameIndex);
            currentFrame = currentSequence.Frames.elementAt(frameIndex);
            int currentSequenceNum = sequenceSelection.getSelectedIndex();
            if (data.isMatrix()) {
                if (data.Sequences.elementAt(0).Window == null) {
                    ShowImageWindow();
                } else if (data.Sequences.elementAt(0).Window.isClosed()) {
                    data.Sequences.elementAt(0).Window = null;
                    ShowImageWindow();
                } else {
                    if (data.Sequences.elementAt(0).Window.getState() == Frame.ICONIFIED) data.Sequences.elementAt(0).Window.setState(Frame.NORMAL);
                    data.Sequences.elementAt(0).Window.toFront();
                }
            } else {
                if (currentSequence.Window == null) {
                    ShowImageWindow();
                } else if (currentSequence.Window.isClosed()) {
                    currentSequence.Window = null;
                    ShowImageWindow();
                } else {
                    if (currentSequence.Window.getState() == Frame.ICONIFIED) currentSequence.Window.setState(Frame.NORMAL);
                    currentSequence.Window.toFront();
                }
            }
            LoadFrame(false);
//            if (currentSequence.isLinescan) {
//                // The current sequence has not had the "source" image windows (with the 
//                // linescan trace drawn on them) displayed.
//
//                Color lsColor = Color.CYAN;
//                Overlay lsImageOverlay = new Overlay();
//
//                if (currentSequence.LinescanType == currentSequence.LinescanTypeLine) {
//                    // Draw the overlay for the "Line" linescan
//                    //Line lsLine = new Line(currentSequence.LinescanStartPixelX, currentSequence.LinescanPixelY, currentSequence.LinescanStopPixelX, currentSequence.LinescanPixelY);
//                    // Since the image has been rotated 90 degrees to the left, the line must be rotated as well.
//                    Line lsLine = new Line(currentSequence.LinescanPixelY, currentSequence.LinescanCompositeWindow.getImagePlus().getHeight() - currentSequence.LinescanStartPixelX, currentSequence.LinescanPixelY, currentSequence.LinescanCompositeWindow.getImagePlus().getHeight() - currentSequence.LinescanStopPixelX);
//                    lsLine.setColor(lsColor);
//                    lsImageOverlay.add(lsLine);
//                }
//                else {
//                    // Draw the overly for the other patterns (Circle, Spiral, Lissajous, Freehand)
//                    for (int pointIndex = 0; pointIndex < currentSequence.LinescanFreehandPixelX.size() -1; pointIndex++) {
//                        //Line lsLine = new Line(currentSequence.LinescanFreehandPixelX.elementAt(pointIndex), currentSequence.LinescanFreehandPixelY.elementAt(pointIndex), currentSequence.LinescanFreehandPixelX.elementAt(pointIndex + 1), currentSequence.LinescanFreehandPixelY.elementAt(pointIndex + 1));
//                        // Since the image has been rotated 90 degrees to the left, the line must be rotated as well.
//                        Line lsLine = new Line(currentSequence.LinescanFreehandPixelY.elementAt(pointIndex), currentSequence.LinescanCompositeWindow.getImagePlus().getHeight() - currentSequence.LinescanFreehandPixelX.elementAt(pointIndex), currentSequence.LinescanFreehandPixelY.elementAt(pointIndex + 1), currentSequence.LinescanCompositeWindow.getImagePlus().getHeight() - currentSequence.LinescanFreehandPixelX.elementAt(pointIndex + 1));
//                        lsLine.setColor(lsColor);
//                        lsImageOverlay.add(lsLine);
//                    }
//                }
//
//                currentSequence.LinescanCompositeWindow.getImagePlus().setOverlay(lsImageOverlay);
//                currentSequence.LinescanCompositeWindow.getImagePlus().draw();
//
//                if (currentSequence.ChannelCount() > 1) {
//                    currentSequence.LinescanSingleChannelWindow1.getImagePlus().setOverlay(lsImageOverlay);
//                    currentSequence.LinescanSingleChannelWindow1.getImagePlus().draw();
//                    currentSequence.LinescanSingleChannelWindow2.getImagePlus().setOverlay(lsImageOverlay);
//                    currentSequence.LinescanSingleChannelWindow2.getImagePlus().draw();
//                    if (currentSequence.ChannelCount() > 2) {
//                        currentSequence.LinescanSingleChannelWindow3.getImagePlus().setOverlay(lsImageOverlay);
//                        currentSequence.LinescanSingleChannelWindow3.getImagePlus().draw();
//                    }
//                   if (currentSequence.ChannelCount() > 3) {
//                        currentSequence.LinescanSingleChannelWindow4.getImagePlus().setOverlay(lsImageOverlay);
//                        currentSequence.LinescanSingleChannelWindow4.getImagePlus().draw();
//                    }
//                }
//            }
            if (currentSequence.isPointscan) {
                //IJ.showMessage("csv file = " + currentSequence.PointScanDataFileName);
                if (currentSequence.PointScanPlotWindow == null) {
                    // The current sequence has not had the data displayed in a Plot
                    // Window yet.  Read the data.
                    Vector<String> plotTimeVector = new Vector<String>();
                    Vector<String> plotData1Vector = new Vector<String>();
                    Vector<String> plotData2Vector = new Vector<String>();
                    Vector<String> plotData3Vector = new Vector<String>();
                    Vector<String> plotData4Vector = new Vector<String>();
                    try {
                        File dataFile = new File(currentSequence.PointScanDataFileName);
                        BufferedReader dataReader = new BufferedReader(new FileReader(dataFile));
                        String dataLine = "";
                        while ((dataLine = dataReader.readLine()) != null) {
                            String[] dataArray = dataLine.split(",");
                            plotTimeVector.addElement(dataArray[0]);
                            plotData1Vector.addElement(dataArray[1]);
                            plotData2Vector.addElement(dataArray[2]);
                            plotData3Vector.addElement(dataArray[3]);
                            plotData4Vector.addElement(dataArray[4]);
                        }
                        dataReader.close();
                        int numElements = plotTimeVector.size();
                        double[] plotTime = new double[numElements];
                        double[] plotData1 = new double[numElements];
                        double[] plotData2 = new double[numElements];
                        double[] plotData3 = new double[numElements];
                        double[] plotData4 = new double[numElements];
                        for (int intJ = 0; intJ < numElements; intJ++) {
                            plotTime[intJ] = Double.parseDouble(plotTimeVector.elementAt(intJ).toString()) * 1000.0;
                            plotData1[intJ] = Double.parseDouble(plotData1Vector.elementAt(intJ).toString());
                            plotData2[intJ] = Double.parseDouble(plotData2Vector.elementAt(intJ).toString());
                            plotData3[intJ] = Double.parseDouble(plotData3Vector.elementAt(intJ).toString());
                            plotData4[intJ] = Double.parseDouble(plotData4Vector.elementAt(intJ).toString());
                        }
                        //Plot the data
                        int numPlots = 0;
                        String plotLabel = "";
                        Color plotColor = Color.BLACK;
                        String plotColorString = "Black";
                        if (currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelCount() > 1) {
                            plotColor = Color.RED;
                            plotColorString = "Red";
                        }
                        //currentSequence.PointScanPlotWindow = new Plot("Point Scan", "Time (ms)", "Intensity", plotTime, plotData1);
                        if (currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).Channel1Present) {
                            currentSequence.PointScanPlotWindow = new Plot("Point Scan: Sequence " + (currentSequenceNum + 1), "Time (ms)", "Intensity", plotTime, plotData1);
                            currentSequence.PointScanPlotWindow.setColor(plotColor);
                            currentSequence.PointScanPlotWindow.draw();
                            plotLabel += currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelName[0] + " (" + plotColorString + ")";
                            numPlots++;
                            if (currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelCount() > 1) {
                                if (numPlots == 1) {
                                    plotColor = Color.GREEN;
                                    plotColorString = "Green";
                                }
                                else if (numPlots == 2)
                                {
                                    plotColor = Color.BLUE;
                                    plotColorString = "Blue";
                                }
                                else if (numPlots == 3) {
                                    plotColor = Color.CYAN;
                                    plotColorString = "Cyan";
                                }
                                currentSequence.PointScanPlotWindow.setColor(plotColor);
                            }
                        }
                        if (currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).Channel2Present) {
                            if (numPlots == 0) {
                                currentSequence.PointScanPlotWindow = new Plot("Point Scan: Sequence " + (currentSequenceNum + 1), "Time (ms)", "Intensity", plotTime, plotData2);
                                currentSequence.PointScanPlotWindow.setColor(plotColor);
                                currentSequence.PointScanPlotWindow.draw();
                                plotLabel += currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelName[1] + " (" + plotColorString + ")";
                            }
                            else {
                                currentSequence.PointScanPlotWindow.addPoints(plotTime, plotData2, PlotWindow.LINE);
                                currentSequence.PointScanPlotWindow.draw();
                                plotLabel += ", " +currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelName[1] + " (" + plotColorString + ")";
                            }
                            numPlots++;
                            if (currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelCount() > 1) {
                                 if (numPlots == 1) {
                                    plotColor = Color.GREEN;
                                    plotColorString = "Green";
                                }
                                else if (numPlots == 2)
                                {
                                    plotColor = Color.BLUE;
                                    plotColorString = "Blue";
                                }
                                else if (numPlots == 3) {
                                    plotColor = Color.CYAN;
                                    plotColorString = "Cyan";
                                }
                                currentSequence.PointScanPlotWindow.setColor(plotColor);
                            }
                        }
                        if (currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).Channel3Present) {
                            if (numPlots == 0) {
                                currentSequence.PointScanPlotWindow = new Plot("Point Scan: Sequence " + (currentSequenceNum + 1), "Time (ms)", "Intensity", plotTime, plotData3);
                                currentSequence.PointScanPlotWindow.setColor(plotColor);
                                currentSequence.PointScanPlotWindow.draw();
                                plotLabel += currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelName[2] + " (" + plotColorString + ")";
                            }
                            else {
                                currentSequence.PointScanPlotWindow.addPoints(plotTime, plotData3, PlotWindow.LINE);
                                currentSequence.PointScanPlotWindow.draw();
                                plotLabel += ", " +currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelName[2] + " (" + plotColorString + ")";
                            }
                            numPlots++;
                            if (currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelCount() > 1) {
                                 if (numPlots == 1) {
                                    plotColor = Color.GREEN;
                                    plotColorString = "Green";
                                }
                                else if (numPlots == 2)
                                {
                                    plotColor = Color.BLUE;
                                    plotColorString = "Blue";
                                }
                                else if (numPlots == 3) {
                                    plotColor = Color.CYAN;
                                    plotColorString = "Cyan";
                                }
                                currentSequence.PointScanPlotWindow.setColor(plotColor);
                            }
                        }
                        if (currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).Channel4Present) {
                            if (numPlots == 0) {
                                currentSequence.PointScanPlotWindow = new Plot("Point Scan: Sequence " + (currentSequenceNum + 1), "Time (ms)", "Intensity", plotTime, plotData4);
                                currentSequence.PointScanPlotWindow.setColor(plotColor);
                                currentSequence.PointScanPlotWindow.draw();
                                plotLabel += currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelName[3] + " (" + plotColorString + ")";
                            }
                            else {
                                currentSequence.PointScanPlotWindow.addPoints(plotTime, plotData4, PlotWindow.LINE);
                                currentSequence.PointScanPlotWindow.draw();
                                plotLabel += ", " +currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelName[3] + " (" + plotColorString + ")";
                            }
                            numPlots++;
                            if (currentSequence.Frames.elementAt(frameSelection.getSelectedIndex()).ChannelCount() > 1) {
                                 if (numPlots == 1) {
                                    plotColor = Color.GREEN;
                                    plotColorString = "Green";
                                }
                                else if (numPlots == 2)
                                {
                                    plotColor = Color.BLUE;
                                    plotColorString = "Blue";
                                }
                                else if (numPlots == 3) {
                                    plotColor = Color.CYAN;
                                    plotColorString = "Cyan";
                                }
                                currentSequence.PointScanPlotWindow.setColor(plotColor);
                            }
                        }
                        currentSequence.PointScanPlotWindow.setColor(Color.BLACK);
                        currentSequence.PointScanPlotWindow.addLabel(0.0, 0.0, plotLabel + " Intensity versus Time");
                        currentSequence.PointScanPlotWindow.show();
                        
                        // Draw the Point scan indicators in the appropriate image windows
                        
                        // Define the overlay based upon the Point scan location for the imaging galvos
                        int lineLength = 15;
                        Line psImageLineX = new Line(currentSequence.PointScanImagingX - lineLength, currentSequence.PointScanImagingY, currentSequence.PointScanImagingX + lineLength, currentSequence.PointScanImagingY);
                        Line psImageLineY = new Line(currentSequence.PointScanImagingX, currentSequence.PointScanImagingY - lineLength, currentSequence.PointScanImagingX, currentSequence.PointScanImagingY + lineLength);
                        TextRoi psImageLineText = new TextRoi(currentSequence.PointScanImagingX + 2, currentSequence.PointScanImagingY - 4, "I");
                        
                        if (currentSequence.ChannelCount() == 1) {
                            psImageLineX.setColor(Color.CYAN);
                            psImageLineY.setColor(Color.CYAN);
                            psImageLineText.setColor(Color.CYAN);
                        }
                        
                        // Define the overlay based upon the Point scan location for the uncaging galvos
                        Line psUncageLineX = new Line(currentSequence.PointScanUncagingX - lineLength, currentSequence.PointScanUncagingY, currentSequence.PointScanUncagingX + lineLength, currentSequence.PointScanUncagingY);
                        Line psUncageLineY = new Line(currentSequence.PointScanUncagingX, currentSequence.PointScanUncagingY - lineLength, currentSequence.PointScanUncagingX, currentSequence.PointScanUncagingY + lineLength);
                        TextRoi psUncageLineText = new TextRoi(currentSequence.PointScanUncagingX + 2, currentSequence.PointScanUncagingY - 4, "U");
                         
                        if (currentSequence.ChannelCount() == 1) {
                            psUncageLineX.setColor(Color.CYAN);
                            psUncageLineY.setColor(Color.CYAN);
                            psUncageLineText.setColor(Color.CYAN);
                        }
                        
                        Overlay psImageOverlay = new Overlay();
                        if (currentSequence.PointScanGalvoType == currentSequence.PointScanGalvoImaging) {
                            psImageOverlay.add(psImageLineX);
                            psImageOverlay.add(psImageLineY);
                            psImageOverlay.add(psImageLineText);
                        }
                        else if (currentSequence.PointScanGalvoType == currentSequence.PointScanGalvoUncaging) {
                            psImageOverlay.add(psUncageLineX);
                            psImageOverlay.add(psUncageLineY);
                            psImageOverlay.add(psUncageLineText);
                        }
                        else if (currentSequence.PointScanGalvoType == currentSequence.PointScanGalvoImagingUncaging) {
                            psImageOverlay.add(psImageLineX);
                            psImageOverlay.add(psImageLineY);
                            psImageOverlay.add(psImageLineText);
                            psImageOverlay.add(psUncageLineX);
                            psImageOverlay.add(psUncageLineY);
                            psImageOverlay.add(psUncageLineText);
                        }
                        
                        currentSequence.Window.getImagePlus().setOverlay(psImageOverlay);
                        currentSequence.Window.getImagePlus().draw();
                    
                        if (currentSequence.ChannelCount() > 1) {
                            currentSequence.SingleChannelWindow1.getImagePlus().setOverlay(psImageOverlay);
                            currentSequence.SingleChannelWindow1.getImagePlus().draw();
                            currentSequence.SingleChannelWindow2.getImagePlus().setOverlay(psImageOverlay);
                            currentSequence.SingleChannelWindow2.getImagePlus().draw();
                            if (currentSequence.ChannelCount() > 2) {
                                currentSequence.SingleChannelWindow3.getImagePlus().setOverlay(psImageOverlay);
                                currentSequence.SingleChannelWindow3.getImagePlus().draw();
                            }
                           if (currentSequence.ChannelCount() > 3) {
                                currentSequence.SingleChannelWindow4.getImagePlus().setOverlay(psImageOverlay);
                                currentSequence.SingleChannelWindow4.getImagePlus().draw();
                            }
                        }
                    }
                    catch (java.io.IOException exception) {
                        IJ.showMessage("Point Scan data file, " + currentSequence.PointScanDataFileName + " was not found!" + "  Error: " + exception.getMessage());
                    }
                }
                else
                    currentSequence.PointScanPlotWindow.show();
            }
        }

        static String WindowI1 = "I1";
        static String WindowI2 = "I2";
        static String WindowI3 = "I3";
        static String WindowI4 = "I4";
        
        static String WindowNameExtension = "";
        
	private void ShowImageWindow() {
                Double minIntensity = 65535.0;
                Double maxIntensity = 0.0;
                Double lsMinIntensity = 65535.0;
                Double lsMaxIntensity = 0.0;
		ImageStack stack = null;
		ImageStack stack1 = null;
		ImageStack stack2 = null;
		ImageStack stack3 = null;
		ImageStack stack4 = null;
                ImagePlus imp1 = null;
                ImagePlus imp2 = null;
                ImagePlus imp3 = null;
                ImagePlus imp4 = null;
                ImageStack lsStack = null;
                ImageStack lsStack1 = null;
                ImageStack lsStack2 = null;
                ImageStack lsStack3 = null;
                ImageStack lsStack4 = null;
                ImagePlus lsImp1 = null;
                ImagePlus lsImp2 = null;
                ImagePlus lsImp3 = null;
                ImagePlus lsImp4 = null;
                
		try {
                    int currentSequenceNum = sequenceSelection.getSelectedIndex();
                    int frameCount = currentSequence.Frames.size();
                    int sequenceCount = 1;
                    int channelCount = currentSequence.ChannelCount();
                    int bitDepth = currentSequence.Frames.elementAt(0).BitDepth;
                    Calibration imageCalib = new Calibration();
                    imageCalib.setUnit("micron");
                    imageCalib.pixelWidth = currentFrame.NumMicronsPerPixelX();
                    if (currentSequence.isLinescan)
                        imageCalib.pixelHeight = currentFrame.ScanlinePeriod;
                    else
                        imageCalib.pixelHeight = currentFrame.NumMicronsPerPixelY();
                    if (currentSequence.isZSeries)
                        imageCalib.pixelDepth = currentSequence.ZSeriesStepSize;
                    if (data.isMatrix()) {
                            sequenceCount = data.Sequences.size();
                            for (int sequenceIndex = 0; sequenceIndex < sequenceCount; sequenceIndex++) {
                                    for (int frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                                            for (int channel = 0; channel < 4; channel++) {
                                                    String filename = data.Sequences.elementAt(sequenceIndex).Frames.elementAt(frameIndex).Filename[channel];
                                                    if (filename != null) {
                                                            ImagePlus imp = new ImagePlus(data.Directory + filename);
                                                            if (imp.getStatistics().max > maxIntensity) maxIntensity = imp.getStatistics().max;
                                                            if (imp.getStatistics().min < minIntensity) minIntensity = imp.getStatistics().min;
                                                            imp.setCalibration(imageCalib);
                                                            if (channelCount > 1) {
                                                                if (channel == 0) {
                                                                    imp1 = new ImagePlus(data.Directory + filename);
                                                                    imp1.setCalibration(imageCalib);
                                                                }
                                                                if (channel == 1) {
                                                                    imp2 = new ImagePlus(data.Directory + filename);
                                                                    imp2.setCalibration(imageCalib);
                                                                }
                                                            }
                                                            if (channelCount > 2) {
                                                                if (channel == 2) {
                                                                    imp3 = new ImagePlus(data.Directory + filename);
                                                                    imp3.setCalibration(imageCalib);
                                                                }
                                                            }
                                                            if (channelCount > 3) {
                                                                if (channel == 3) {
                                                                    imp4 = new ImagePlus(data.Directory + filename);
                                                                    imp4.setCalibration(imageCalib);
                                                                }
                                                            }
                                                            if (imp != null) {
                                                                    if (stack == null) stack = new ImageStack(imp.getWidth(), imp.getHeight(), imp.getProcessor().getColorModel());
                                                                    ImageStack inputStack = imp.getStack();
                                                                    stack.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                            }
                                                            if ((imp1 != null) && (channel == 0)) {
                                                                    if (stack1 == null) stack1 = new ImageStack(imp1.getWidth(), imp1.getHeight(), imp1.getProcessor().getColorModel());
                                                                    ImageStack inputStack = imp1.getStack();
                                                                    stack1.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                            }
                                                            if ((imp2 != null) && (channel == 1)) {
                                                                    if (stack2 == null) stack2 = new ImageStack(imp2.getWidth(), imp2.getHeight(), imp2.getProcessor().getColorModel());
                                                                    ImageStack inputStack = imp2.getStack();
                                                                    stack2.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                            }
                                                            if ((imp3 != null) && (channel == 2)) {
                                                                    if (stack3 == null) stack3 = new ImageStack(imp3.getWidth(), imp3.getHeight(), imp3.getProcessor().getColorModel());
                                                                    ImageStack inputStack = imp3.getStack();
                                                                    stack3.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                            }
                                                            if ((imp4 != null) && (channel == 3)) {
                                                                    if (stack4 == null) stack4 = new ImageStack(imp4.getWidth(), imp4.getHeight(), imp4.getProcessor().getColorModel());
                                                                    ImageStack inputStack = imp4.getStack();
                                                                    stack4.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                            }
                                                    }	
                                            }
                                    }
                            }
                    } else {
                            for (int frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                                    for (int channel = 0; channel < 4; channel++) {
                                            String filename = currentSequence.Frames.elementAt(frameIndex).Filename[channel];
                                            if (filename != null) {
                                                    ImagePlus imp = null;
                                                    try {
                                                            imp = new ImagePlus(data.Directory + filename);
                                                            if (imp.getStatistics().max > maxIntensity) maxIntensity = imp.getStatistics().max;
                                                            if (imp.getStatistics().min < maxIntensity) minIntensity = imp.getStatistics().min;
                                                            imp.setCalibration(imageCalib);
                                                    } catch (Throwable t) {
                                                            return;  // stop if there is a problem reading the file
                                                    }
                                                    if (imp != null) {
                                                            if (stack == null) {
                                                                if (currentSequence.isLinescan)
                                                                    stack = new ImageStack(imp.getHeight(), imp.getWidth(), imp.getProcessor().getColorModel());
                                                                else
                                                                    stack = new ImageStack(imp.getWidth(), imp.getHeight(), imp.getProcessor().getColorModel());
                                                            }
                                                            ImageStack inputStack;
                                                            if (currentSequence.isLinescan) {
                                                                ImageProcessor tmpIP = imp.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("", tmpIP);
                                                                inputStack = tmpIMP.getStack();
                                                            }
                                                            else {
                                                                inputStack = imp.getStack();
                                                            }
                                                            stack.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                    }
                                                    imp1 = null;
                                                    try {
                                                            if ((channelCount > 1) && (channel == 0)) {
                                                                imp1 = new ImagePlus(data.Directory + filename);
                                                                imp1.setCalibration(imageCalib);
                                                            }
                                                    } catch (Throwable t) {
                                                            return;  // stop if there is a problem reading the file
                                                    }
                                                    if ((imp1 != null) && (channel == 0)) {
                                                            if (stack1 == null) {
                                                                if (currentSequence.isLinescan)
                                                                    stack1 = new ImageStack(imp1.getHeight(), imp1.getWidth(), imp1.getProcessor().getColorModel());
                                                                else
                                                                    stack1 = new ImageStack(imp1.getWidth(), imp1.getHeight(), imp1.getProcessor().getColorModel());
                                                            }
                                                            ImageStack inputStack;
                                                            if (currentSequence.isLinescan) {
                                                                ImageProcessor tmpIP = imp1.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("", tmpIP);
                                                                inputStack = tmpIMP.getStack();
                                                            }
                                                            else {
                                                                inputStack = imp1.getStack();
                                                            }
                                                            stack1.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                    }
                                                    imp2 = null;
                                                    try {
                                                            if ((channelCount > 1) && (channel == 1)) {
                                                                imp2 = new ImagePlus(data.Directory + filename);
                                                                imp2.setCalibration(imageCalib);
                                                            }
                                                    } catch (Throwable t) {
                                                            return;  // stop if there is a problem reading the file
                                                    }
                                                    if ((imp2 != null) && (channel == 1)) {
                                                            if (stack2 == null) {
                                                                if (currentSequence.isLinescan)
                                                                    stack2 = new ImageStack(imp2.getHeight(), imp2.getWidth(), imp2.getProcessor().getColorModel());
                                                                else
                                                                    stack2 = new ImageStack(imp2.getWidth(), imp2.getHeight(), imp2.getProcessor().getColorModel());
                                                            }
                                                            ImageStack inputStack;
                                                            if (currentSequence.isLinescan) {
                                                                ImageProcessor tmpIP = imp2.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("", tmpIP);
                                                                inputStack = tmpIMP.getStack();
                                                            }
                                                            else {
                                                                inputStack = imp2.getStack();
                                                            }
                                                            stack2.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                    }
                                                    imp3 = null;
                                                    try {
                                                            if ((channelCount > 2) && (channel == 2)) {
                                                                imp3 = new ImagePlus(data.Directory + filename);
                                                                imp3.setCalibration(imageCalib);
                                                            }
                                                    } catch (Throwable t) {
                                                            return;  // stop if there is a problem reading the file
                                                    }
                                                    if ((imp3 != null) && (channel == 2)) {
                                                            if (stack3 == null) {
                                                                if (currentSequence.isLinescan)
                                                                    stack3 = new ImageStack(imp3.getHeight(), imp3.getWidth(), imp3.getProcessor().getColorModel());
                                                                else
                                                                    stack3 = new ImageStack(imp3.getWidth(), imp3.getHeight(), imp3.getProcessor().getColorModel());
                                                            }
                                                            ImageStack inputStack;
                                                            if (currentSequence.isLinescan) {
                                                                ImageProcessor tmpIP = imp3.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("", tmpIP);
                                                                inputStack = tmpIMP.getStack();
                                                            }
                                                            else {
                                                                inputStack = imp3.getStack();
                                                            }
                                                            stack3.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                    }
                                                    imp4 = null;
                                                    try {
                                                            if ((channelCount > 3) && (channel == 3)) {
                                                                imp4 = new ImagePlus(data.Directory + filename);
                                                                imp4.setCalibration(imageCalib);
                                                            }
                                                    } catch (Throwable t) {
                                                            return;  // stop if there is a problem reading the file
                                                    }
                                                    if ((imp4 != null) && (channel == 3)) {
                                                            if (stack4 == null) {
                                                                if (currentSequence.isLinescan)
                                                                    stack4 = new ImageStack(imp4.getHeight(), imp4.getWidth(), imp4.getProcessor().getColorModel());
                                                                else
                                                                    stack4 = new ImageStack(imp4.getWidth(), imp4.getHeight(), imp4.getProcessor().getColorModel());
                                                            }
                                                            ImageStack inputStack;
                                                            if (currentSequence.isLinescan) {
                                                                ImageProcessor tmpIP = imp4.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("", tmpIP);
                                                                inputStack = tmpIMP.getStack();
                                                            }
                                                            else {
                                                                inputStack = imp4.getStack();
                                                            }
                                                            stack4.addSlice(currentSequence.Frames.elementAt(frameIndex).Summary(), inputStack.getProcessor(1));
                                                    }
                                            }
                                            // If the sequence is "linescan" data, generate the appropriate
                                            // "source" image window(s)
                                            if (currentSequence.isLinescan) {
                                                String lsFilename = currentSequence.LinescanSourceImage[channel];
                                                if ((lsFilename != null) && (frameIndex == 0)){
                                                        ImagePlus lsImp = null;
                                                        try {
                                                            lsImp = new ImagePlus(data.Directory + lsFilename);
                                                            if (lsImp.getStatistics().max > lsMaxIntensity) lsMaxIntensity = lsImp.getStatistics().max;
                                                            if (lsImp.getStatistics().min < lsMaxIntensity) lsMinIntensity = lsImp.getStatistics().min;
                                                        } catch (Throwable t) {
                                                            return;  // stop if there is a problem reading the file
                                                        }
                                                        if (lsImp != null) {
                                                                //if (lsStack == null) lsStack = new ImageStack(lsImp.getWidth(), lsImp.getHeight(), lsImp.getProcessor().getColorModel());
                                                                // Since the image is being rotated 90 degrees left, need to swap width and height values in stack constructor.
                                                                if (lsStack == null) lsStack = new ImageStack(lsImp.getHeight(), lsImp.getWidth(), lsImp.getProcessor().getColorModel());
                                                                ImageProcessor tmpIP = lsImp.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("", tmpIP);
                                                                ImageStack inputStack = tmpIMP.getStack();
                                                                lsStack.addSlice("", inputStack.getProcessor(1));
                                                        }
                                                        lsImp1 = null;
                                                        try {
                                                                if ((channelCount > 1) && (channel == 0)) {
                                                                    lsImp1 = new ImagePlus(data.Directory + lsFilename);
                                                                    lsImp1.setCalibration(imageCalib);
                                                                }
                                                        } catch (Throwable t) {
                                                                return;  // stop if there is a problem reading the file
                                                        }
                                                        if ((lsImp1 != null) && (channel == 0)) {
                                                                //if (lsStack1 == null) lsStack1 = new ImageStack(lsImp1.getWidth(), lsImp1.getHeight(), lsImp1.getProcessor().getColorModel());
                                                                // Since the image is being rotated 90 degrees left, need to swap width and height values in stack constructor.
                                                                if (lsStack1 == null) lsStack1 = new ImageStack(lsImp1.getHeight(), lsImp1.getWidth(), lsImp1.getProcessor().getColorModel());
                                                                ImageProcessor tmpIP = lsImp1.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("1", tmpIP);
                                                                ImageStack inputStack = tmpIMP.getStack();
                                                                lsStack1.addSlice("", inputStack.getProcessor(1));
                                                        }
                                                        lsImp2 = null;
                                                        try {
                                                                if ((channelCount > 1) && (channel == 1)) {
                                                                    lsImp2 = new ImagePlus(data.Directory + lsFilename);
                                                                    lsImp2.setCalibration(imageCalib);
                                                                }
                                                        } catch (Throwable t) {
                                                                return;  // stop if there is a problem reading the file
                                                        }
                                                        if ((lsImp2 != null) && (channel == 1)) {
                                                                //if (lsStack2 == null) lsStack2 = new ImageStack(lsImp2.getWidth(), lsImp2.getHeight(), lsImp2.getProcessor().getColorModel());
                                                                // Since the image is being rotated 90 degrees left, need to swap width and height values in stack constructor.
                                                                if (lsStack2 == null) lsStack2 = new ImageStack(lsImp2.getHeight(), lsImp2.getWidth(), lsImp2.getProcessor().getColorModel());
                                                                ImageProcessor tmpIP = lsImp2.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("", tmpIP);
                                                                ImageStack inputStack = tmpIMP.getStack();
                                                                lsStack2.addSlice("", inputStack.getProcessor(1));
                                                        }
                                                        lsImp3 = null;
                                                        try {
                                                                if ((channelCount > 2) && (channel == 2)) {
                                                                    lsImp3 = new ImagePlus(data.Directory + lsFilename);
                                                                    lsImp3.setCalibration(imageCalib);
                                                                }
                                                        } catch (Throwable t) {
                                                                return;  // stop if there is a problem reading the file
                                                        }
                                                        if ((lsImp3 != null) && (channel == 2)) {
                                                                //if (lsStack3 == null) lsStack3 = new ImageStack(lsImp3.getWidth(), lsImp3.getHeight(), lsImp3.getProcessor().getColorModel());
                                                                // Since the image is being rotated 90 degrees left, need to swap width and height values in stack constructor.
                                                                if (lsStack3 == null) lsStack3 = new ImageStack(lsImp3.getHeight(), lsImp3.getWidth(), lsImp3.getProcessor().getColorModel());
                                                                ImageProcessor tmpIP = lsImp3.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("", tmpIP);
                                                                ImageStack inputStack = tmpIMP.getStack();
                                                                lsStack3.addSlice("", inputStack.getProcessor(1));
                                                        }
                                                        lsImp4 = null;
                                                        try {
                                                                if ((channelCount > 3) && (channel == 3)) {
                                                                    lsImp4 = new ImagePlus(data.Directory + lsFilename);
                                                                    lsImp4.setCalibration(imageCalib);
                                                                }
                                                        } catch (Throwable t) {
                                                                return;  // stop if there is a problem reading the file
                                                        }
                                                        if ((lsImp4 != null) && (channel == 3)) {
                                                                //if (lsStack4 == null) lsStack4 = new ImageStack(lsImp4.getWidth(), lsImp4.getHeight(), lsImp4.getProcessor().getColorModel());
                                                                // Since the image is being rotated 90 degrees left, need to swap width and height values in stack constructor.
                                                                if (lsStack4 == null) lsStack4 = new ImageStack(lsImp4.getHeight(), lsImp4.getWidth(), lsImp4.getProcessor().getColorModel());
                                                                ImageProcessor tmpIP = lsImp4.getProcessor().rotateLeft();
                                                                ImagePlus tmpIMP = new ImagePlus("", tmpIP);
                                                                ImageStack inputStack = tmpIMP.getStack();
                                                                lsStack4.addSlice("", inputStack.getProcessor(1));
                                                        }
                                                }
                                            }
                                    }
                            }
                    }
                    if (stack != null) {
                            ImagePlus imp = new ImagePlus(currentSequence.Filename + " - Sequence " + currentSequence.Index, stack);
                            imp.setCalibration(imageCalib);
                            imp.setDisplayRange(minIntensity, maxIntensity);
                            int[] dimComp = imp.getDimensions();
                            //IJ.showMessage("width = " + dimComp[0] + "   height = " + dimComp[1] + "    nChannels = " + dimComp[2] + "     nSlices = " + dimComp[3] + "     nFrames = " + dimComp[4]);
                            ImagePlus imp1a = null;
                            ImagePlus imp2a = null;
                            ImagePlus imp3a = null;
                            ImagePlus imp4a = null;
                            WindowNameExtension = currentSequence.Filename + " - Sequence "  + currentSequence.Index;
                            if (channelCount > 1) {
                                imp1a = new ImagePlus(WindowI1 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[0] + WindowNameExtension, stack1);
                                imp1a.setCalibration(imageCalib);
                                imp1a.setDisplayRange(minIntensity, maxIntensity);
                                //int[] dim1a = imp1a.getDimensions();
                                //IJ.showMessage("width = " + dim1a[0] + "   height = " + dim1a[1] + "    nChannels = " + dim1a[2] + "     nSlices = " + dim1a[3] + "     nFrames = " + dim1a[4]);
                                imp2a = new ImagePlus(WindowI2 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[1] + WindowNameExtension, stack2);
                                imp2a.setCalibration(imageCalib);
                                imp2a.setDisplayRange(minIntensity, maxIntensity);
                                //int[] dim2a = imp2a.getDimensions();
                                //IJ.showMessage("width = " + dim2a[0] + "   height = " + dim2a[1] + "    nChannels = " + dim2a[2] + "     nSlices = " + dim2a[3] + "     nFrames = " + dim2a[4]);
                            }
                            if (channelCount > 2) {
                                imp3a = new ImagePlus(WindowI3 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[2] + WindowNameExtension, stack3);
                                imp3a.setCalibration(imageCalib);
                                imp3a.setDisplayRange(minIntensity, maxIntensity);
                            }
                            if (channelCount > 3) {
                                imp4a = new ImagePlus(WindowI4 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[3] + WindowNameExtension, stack4);
                                imp4a.setCalibration(imageCalib);
                                imp4a.setDisplayRange(minIntensity, maxIntensity);
                            }
                            // Use the following line if you want to force the displayed data to use the
                            // full dynamic range of the acquisition device.  For completeness, this would
                            // have to be appliced to all the 'ImagePlus' creations that follow.
                            //imp.setDisplayRange(0, Math.pow(2, bitDepth));
                            
                            // Set the minimum and maximum intensity values for the linescan "source"
                            // image windows.
                            ImagePlus lsImp = null;
                            ImagePlus lsImp1a = null;
                            ImagePlus lsImp2a = null;
                            ImagePlus lsImp3a = null;
                            ImagePlus lsImp4a = null;
                            if (currentSequence.isLinescan) {
                                lsImp = new ImagePlus(currentSequence.Filename + " - Sequence " + currentSequence.Index + " Linescan Reference Image", lsStack);
                                lsImp.setDisplayRange(lsMinIntensity, lsMaxIntensity);
                                WindowNameExtension = currentSequence.Filename + " - Sequence "  + currentSequence.Index + " Linescan Reference Image";
                                if (channelCount > 1) {
                                    lsImp1a = new ImagePlus(WindowI1 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[0] + WindowNameExtension, lsStack1);
                                    lsImp1a.setDisplayRange(lsMinIntensity, lsMaxIntensity);
                                    lsImp2a = new ImagePlus(WindowI2 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[1] + WindowNameExtension, lsStack2);
                                    lsImp2a.setDisplayRange(lsMinIntensity, lsMaxIntensity);
                                }
                                if (channelCount > 2) {
                                    lsImp3a = new ImagePlus(WindowI3 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[2] + WindowNameExtension, lsStack3);
                                    lsImp3a.setDisplayRange(lsMinIntensity, lsMaxIntensity);
                                }
                                if (channelCount > 3) {
                                    lsImp4a = new ImagePlus(WindowI4 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[3] + WindowNameExtension, lsStack4);
                                    lsImp4a.setDisplayRange(lsMinIntensity, lsMaxIntensity);
                                }
                            }
                            
                            if (data.isMatrix()) {
                                if (data.isBiDirectionalZSeriesFlag) {
                                    if (data.isBiDirectionalZSeries) {
                                        WindowNameExtension = currentSequence.Filename + " Matrix BiDirectional Z";
                                        imp.setTitle(currentSequence.Filename + " Matrix BiDirectional Z");
                                        if (imp1a != null)
                                            imp1a.setTitle(WindowI1 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[0] + " Prairie Matrix BiDirectional Z");
                                        if (imp2a != null)
                                            imp2a.setTitle(WindowI2 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[1] + " Prairie Matrix BiDirectional Z");
                                        if (imp3a != null)
                                            imp3a.setTitle(WindowI3 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[2]+ " Prairie Matrix BiDirectional Z");
                                        if (imp4a != null)
                                            imp4a.setTitle(WindowI4 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[3] + " Prairie Matrix BiDirectional Z");
                                    }
                                    else {
                                        WindowNameExtension = currentSequence.Filename + " Matrix Non-BiDirectional Z";
                                        imp.setTitle(currentSequence.Filename + " Matrix Non-BiDirectional Z");
                                        if (imp1a != null)
                                            imp1a.setTitle(WindowI1 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[0] + " Prairie Matrix Non-BiDirectional Z");
                                        if (imp2a != null)
                                            imp2a.setTitle(WindowI2 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[1] + " Prairie Matrix Non-BiDirectional Z");
                                        if (imp3a != null)
                                            imp3a.setTitle(WindowI3 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[2] + " Prairie Matrix Non-BiDirectional Z");
                                        if (imp4a != null)
                                            imp4a.setTitle(WindowI4 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[3] + " Prairie Matrix Non-BiDirectional Z");
                                    }
                                }
                                else {
                                    WindowNameExtension = currentSequence.Filename + " Matrix";
                                    imp.setTitle(currentSequence.Filename + " Matrix");
                                    if (imp1a != null)
                                        imp1a.setTitle(WindowI1 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[0] + " Prairie Matrix");
                                    if (imp2a != null)
                                        imp2a.setTitle(WindowI2 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[1] + " Prairie Matrix");
                                    if (imp3a != null)
                                        imp3a.setTitle(WindowI3 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[2] + " Prairie Matrix");
                                    if (imp4a != null)
                                        imp4a.setTitle(WindowI4 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[3] + " Prairie Matrix");
                                }
                            }
                            if (currentSequence.isZSeries) {
                                    imp.setDimensions(channelCount, frameCount, sequenceCount);
                                    if (imp1a != null)
                                        imp1a.setDimensions(1, frameCount, sequenceCount);
                                    if (imp2a != null)
                                        imp2a.setDimensions(1, frameCount, sequenceCount);
                                    if (imp3a != null)
                                        imp3a.setDimensions(1, frameCount, sequenceCount);
                                    if (imp4a != null)
                                        imp4a.setDimensions(1, frameCount, sequenceCount);
                            }
                            else {
                                    imp.setDimensions(channelCount, 1, frameCount);
                                    if (imp1a != null)
                                        imp1a.setDimensions(1, 1, frameCount);
                                    if (imp2a != null)
                                        imp2a.setDimensions(1, 1, frameCount);
                                    if (imp3a != null)
                                        imp3a.setDimensions(1, 1, frameCount);
                                    if (imp4a != null)
                                        imp4a.setDimensions(1, 1, frameCount);
                            }
                            imp.setOpenAsHyperStack(true);
                            if (imp1a != null)
                                imp1a.setOpenAsHyperStack(true);
                            if (imp2a != null)
                                imp2a.setOpenAsHyperStack(true);
                            if (imp3a != null)
                                imp3a.setOpenAsHyperStack(true);
                            if (imp4a != null)
                                imp4a.setOpenAsHyperStack(true);
                            if (channelCount > 1) {
                                    CompositeImage cmp = new CompositeImage(imp);
                                    cmp.setMode(CompositeImage.COMPOSITE);
                                    cmp.addImageListener(this);
                                    //try { cmp.show(); } catch (Throwable t) {}
                                    cmp.show();
                                    if (data.isMatrix()) {
                                            data.Sequences.elementAt(0).Window = cmp.getWindow();
                                    } else {
                                            currentSequence.Window = cmp.getWindow();
                                    }

                                    //int[] disp1a = imp1a.getDimensions();
                                    //IJ.showMessage("channels = " + disp1a[2] + "    slices = " + disp1a[3] + "     frames = " + disp1a[4]);
                                    CompositeImage cmp1 = new CompositeImage(imp1a);
                                    cmp1.setMode(CompositeImage.COLOR);
                                    cmp1.setColor(Color.RED);
                                    cmp1.addImageListener(this);
                                    //try { cmp.show(); } catch (Throwable t) {}
                                    cmp1.show();
                                    IJ.run("Red");
                                    if (data.isMatrix()) {
                                            data.Sequences.elementAt(0).SingleChannelWindow1 = cmp1.getWindow();
                                            data.Sequences.elementAt(0).SingleChannelWindow1.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                    } else {
                                            currentSequence.SingleChannelWindow1 = cmp1.getWindow();
                                            currentSequence.SingleChannelWindow1.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                    }

                                    CompositeImage cmp2 = new CompositeImage(imp2a);
                                    cmp2.setMode(CompositeImage.COLOR);
                                    cmp2.setColor(Color.GREEN);
                                    cmp2.addImageListener(this);
                                    //try { cmp.show(); } catch (Throwable t) {}
                                    cmp2.show();
                                    IJ.run("Green"); 
                                    if (data.isMatrix()) {
                                            data.Sequences.elementAt(0).SingleChannelWindow2 = cmp2.getWindow();
                                            data.Sequences.elementAt(0).SingleChannelWindow2.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                    } else {
                                            currentSequence.SingleChannelWindow2 = cmp2.getWindow();
                                            currentSequence.SingleChannelWindow2.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                     }

                                    if (channelCount > 2) {                        
                                        CompositeImage cmp3 = new CompositeImage(imp3a);
                                        cmp3.setMode(CompositeImage.COLOR);
                                        cmp3.setColor(Color.BLUE);
                                        cmp3.addImageListener(this);
                                        //try { cmp.show(); } catch (Throwable t) {}
                                        cmp3.show();
                                        IJ.run("Blue"); 
                                        if (data.isMatrix()) {
                                                data.Sequences.elementAt(0).SingleChannelWindow3 = cmp3.getWindow();
                                                data.Sequences.elementAt(0).SingleChannelWindow3.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                        } else {
                                                currentSequence.SingleChannelWindow3 = cmp3.getWindow();
                                                currentSequence.SingleChannelWindow3.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                        }
                                    }

                                    if (channelCount > 3) {                        
                                        CompositeImage cmp4 = new CompositeImage(imp4a);
                                        cmp4.setMode(CompositeImage.COLOR);
                                        cmp4.setColor(Color.CYAN);
                                        cmp4.addImageListener(this);
                                        //try { cmp.show(); } catch (Throwable t) {}
                                        cmp4.show();
                                        IJ.run("Cyan"); 
                                        if (data.isMatrix()) {
                                                data.Sequences.elementAt(0).SingleChannelWindow4 = cmp4.getWindow();
                                                data.Sequences.elementAt(0).SingleChannelWindow4.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                       } else {
                                                currentSequence.SingleChannelWindow4 = cmp4.getWindow();
                                                currentSequence.SingleChannelWindow4.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                        }
                                    }
                                    
                                    if (currentSequence.isLinescan) {
                                        // Handle the display of the linescan "source" images.  The previous
                                        // logic handled the linescan images themselves.
                                        
                                        lsImp.setDimensions(channelCount, 1, 1);
                                        CompositeImage lsCmp = new CompositeImage(lsImp);
                                        lsCmp.setMode(CompositeImage.COMPOSITE);
                                        //lsCmp.addImageListener(this);
                                        //try { cmp.show(); } catch (Throwable t) {}
                                        lsCmp.show();
                                        currentSequence.LinescanCompositeWindow = lsCmp.getWindow();
                                        
                                        CompositeImage lsCmp1 = new CompositeImage(lsImp1a);
                                        lsCmp1.setMode(CompositeImage.COLOR);
                                        lsCmp1.setColor(Color.RED);
                                        //lsCmp1.addImageListener(this);
                                        //try { cmp.show(); } catch (Throwable t) {}
                                        lsCmp1.show();
                                        IJ.run("Red"); 
                                        currentSequence.LinescanSingleChannelWindow1 = lsCmp1.getWindow();
                                        currentSequence.LinescanSingleChannelWindow1.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                        
                                        CompositeImage lsCmp2 = new CompositeImage(lsImp2a);
                                        lsCmp2.setMode(CompositeImage.COLOR);
                                        lsCmp2.setColor(Color.GREEN);
                                        //lsCmp2.addImageListener(this);
                                        //try { cmp.show(); } catch (Throwable t) {}
                                        lsCmp2.show();
                                        IJ.run("Green"); 
                                        currentSequence.LinescanSingleChannelWindow2 = lsCmp2.getWindow();
                                        currentSequence.LinescanSingleChannelWindow2.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                        
                                        if (channelCount > 2) {                        
                                            CompositeImage lsCmp3 = new CompositeImage(lsImp3a);
                                            lsCmp3.setMode(CompositeImage.COLOR);
                                            lsCmp3.setColor(Color.BLUE);
                                            //lsCmp3.addImageListener(this);
                                            //try { cmp.show(); } catch (Throwable t) {}
                                            lsCmp3.show();
                                            IJ.run("Blue"); 
                                            currentSequence.LinescanSingleChannelWindow3 = lsCmp3.getWindow();
                                            currentSequence.LinescanSingleChannelWindow3.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                        }

                                        if (channelCount > 3) {                        
                                            CompositeImage lsCmp4 = new CompositeImage(lsImp4a);
                                            lsCmp4.setMode(CompositeImage.COLOR);
                                            lsCmp4.setColor(Color.CYAN);
                                            //lsCmp4.addImageListener(this);
                                            //try { cmp.show(); } catch (Throwable t) {}
                                            lsCmp4.show();
                                            IJ.run("Cyan"); 
                                            currentSequence.LinescanSingleChannelWindow4 = lsCmp4.getWindow();
                                            currentSequence.LinescanSingleChannelWindow4.getImagePlus().setPositionWithoutUpdate(1, 1, 1);
                                        }
                                    }
                                    
                            } else {
                                    imp.addImageListener(this);
                                    //try { imp.show(); } catch (Throwable t) {}
                                    imp.show();
                                    if (data.isMatrix()) {
                                            data.Sequences.elementAt(0).Window = imp.getWindow();
                                    } else {
                                            currentSequence.Window = imp.getWindow();
                                    }
                                    if (currentSequence.isLinescan) {
                                        lsImp.show();
                                        currentSequence.LinescanCompositeWindow = lsImp.getWindow();
                                     }
                            }
                    }
                    if (currentSequence.isLinescan) {
                        if (currentSequence.LinescanAnalysisDialog == null) {
                            currentSequence.LinescanAnalysisDialog = new LinescanAnalysis(this, "Prairie Linescan Analysis Sequence " + (sequenceSelection.getSelectedIndex() + 1), false);
                            currentSequence.LinescanAnalysisDialog.setVisible(true);
                            currentSequence.LinescanAnalysisDialog.SetChannelNames(currentSequence.ChannelCount(), currentSequence.Frames.elementAt(0).ChannelName[0], currentSequence.Frames.elementAt(0).ChannelName[1], currentSequence.Frames.elementAt(0).ChannelName[2], currentSequence.Frames.elementAt(0).ChannelName[3]);
                            currentSequence.LinescanAnalysisDialog.SetLinescanWindows(currentSequence.LinescanCompositeWindow, currentSequence.LinescanSingleChannelWindow1, currentSequence.LinescanSingleChannelWindow2, currentSequence.LinescanSingleChannelWindow3, currentSequence.LinescanSingleChannelWindow4, currentSequence.Window, currentSequence.SingleChannelWindow1, currentSequence.SingleChannelWindow2, currentSequence.SingleChannelWindow3, currentSequence.SingleChannelWindow4);
                            currentSequence.LinescanAnalysisDialog.SetDwellTime(currentSequence.Frames.elementAt(0).DwellTime);
                            currentSequence.LinescanAnalysisDialog.SetScanlinePeriod(currentSequence.Frames.elementAt(0).ScanlinePeriod);
                            currentSequence.LinescanAnalysisDialog.SetNumberOfLines(currentSequence.Frames.elementAt(0).LinesPerFrame);
                            currentSequence.LinescanAnalysisDialog.SetPixelsPerLine(currentSequence.Frames.elementAt(0).PixelsPerLine);
                            currentSequence.LinescanAnalysisDialog.SetSequenceNumber(sequenceSelection.getSelectedIndex() + 1);
                            currentSequence.LinescanAnalysisDialog.SetLinescanTraceInformation(currentSequence.LinescanType, currentSequence.LinescanStartPixelX, currentSequence.LinescanStopPixelX, currentSequence.LinescanPixelY, currentSequence.LinescanFreehandPixelX, currentSequence.LinescanFreehandPixelY);
                            currentSequence.LinescanAnalysisDialog.SetDirectoryAndFileName(currentSequence.Directory, currentSequence.Frames.elementAt(0).Filename[0]);
                            if (data.isVersion5dot0orGreater()) {
                                currentSequence.LinescanAnalysisDialog.SetVoltageRecordingDataFiles(currentSequence.LinescanVoltageRecordingDataFile, currentSequence.LinescanVoltageRecordingParameterFile);
                            }
                            else {
                                currentSequence.LinescanAnalysisDialog.SetTriggerSyncDataFiles(currentSequence.LinescanTriggerSyncDataFile, currentSequence.LinescanTriggerSyncSettingsFile);
                            }
                            // If functions have been previously created for this sequence, read them.
                            currentSequence.LinescanAnalysisDialog.ReadProfileFunctions();
                            currentSequence.LinescanAnalysisDialog.PreparePlotWindows();
                            currentSequence.LinescanAnalysisDialog.DrawLinescanTrace();
                            if (currentSequence.PVProfiles) {
                                // Profiles were created in Prairie View, so get them into the linescan analysis dialog
                                for (int index = 0; index < currentSequence.PVProfilesChannel.size(); index++) {
                                    currentSequence.LinescanAnalysisDialog.SetPrairieViewCreatedProfile(index, currentSequence.PVProfilesChannel.elementAt(index), currentSequence.PVProfilesPosition.elementAt(index), currentSequence.PVProfilesWidth.elementAt(index), currentSequence.PVProfilesColor.elementAt(index));
                                }
                            }
                            // If profiles have been previously created for this sequence, read them.
                            currentSequence.LinescanAnalysisDialog.ReadProfileSettings();
                            if (currentSequence.PVProfiles) {
                                currentSequence.LinescanAnalysisDialog.UpdateProfiles();
                            }
                        }
                        else
                            currentSequence.LinescanAnalysisDialog.toFront();
                    }
                } catch (Throwable t) {
                try {
                        FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
                        PrintStream logStream = new PrintStream(logFile);
                        t.printStackTrace(logStream);
                        logStream.flush();
                        logStream.close();
                        logFile.flush();
                        logFile.close();
                        IJ.showMessage("Prairie ShowImageWindow", "Error: " + t.toString());
                } catch (IOException exception) {}
            }
        }

	public void mouseReleased(MouseEvent e) {
            IJ.showMessage("Mouse released");
        }     
        
        public void imageOpened(ImagePlus imp) {}
        
	public void imageClosed(ImagePlus imp) {
            int currentSequenceNum = sequenceSelection.getSelectedIndex();
            if (imp.getTitle().startsWith(WindowI1))
                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1 = null;
            else if (imp.getTitle().startsWith(WindowI2))
                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2 = null;
            else if (imp.getTitle().startsWith(WindowI3))
                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3 = null;
            else if (imp.getTitle().startsWith(WindowI4))
                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4 = null;
            else
                data.Sequences.elementAt(currentSequenceNum).Window = null;
        }
        
        public boolean blockImageUpdatedMethod = false;
        
        public void imageUpdated(ImagePlus imp) {
            if (imp == null) return;
            if (blockImageUpdatedMethod) return;
            blockImageUpdatedMethod = true;
            //if (currentSequence.Window == null) return;
            int currentSequenceNum = sequenceSelection.getSelectedIndex();
            //int currentFrameNum = frameSelection.getSelectedIndex();
            //IJ.showStatus("frame number = " + currentFrameNum);
            if (currentSequence.Window != null || (data.isMatrix() && data.Sequences.elementAt(0).Window != null)) {
                if (data.isMatrix()) {
                    int slice;
                    int frame;
                    if (imp.getTitle().startsWith(WindowI1)) {
                        if (data.Sequences.elementAt(0).SingleChannelWindow1 != null) {
                            slice = data.Sequences.elementAt(0).SingleChannelWindow1.getImagePlus().getSlice() - 1;
                            frame = data.Sequences.elementAt(0).SingleChannelWindow1.getImagePlus().getFrame() - 1;
                            //imp.setTitle(WindowI1 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(0).SingleChannelWindow1.getImagePlus().getChannel() - 1] + WindowNameExtension);
                            imp.setTitle(WindowI1 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[0] + WindowNameExtension);
                        }
                        else {
                            slice = data.Sequences.elementAt(0).Window.getImagePlus().getSlice() - 1;
                            frame = data.Sequences.elementAt(0).Window.getImagePlus().getFrame() - 1;
                        }
                    }
                    else if (imp.getTitle().startsWith(WindowI2)) {
                        if (data.Sequences.elementAt(0).SingleChannelWindow2 != null) {
                            slice = data.Sequences.elementAt(0).SingleChannelWindow2.getImagePlus().getSlice() - 1;
                            frame = data.Sequences.elementAt(0).SingleChannelWindow2.getImagePlus().getFrame() - 1;
                            //imp.setTitle(WindowI2 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(0).SingleChannelWindow2.getImagePlus().getChannel() - 1] + WindowNameExtension);
                            imp.setTitle(WindowI2 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[1] + WindowNameExtension);
                        }
                        else {
                            slice = data.Sequences.elementAt(0).Window.getImagePlus().getSlice() - 1;
                            frame = data.Sequences.elementAt(0).Window.getImagePlus().getFrame() - 1;
                        }
                    }
                    else if (imp.getTitle().startsWith(WindowI3)) {
                        if (data.Sequences.elementAt(0).SingleChannelWindow3 != null) {
                            slice = data.Sequences.elementAt(0).SingleChannelWindow3.getImagePlus().getSlice() - 1;
                            frame = data.Sequences.elementAt(0).SingleChannelWindow3.getImagePlus().getFrame() - 1;
                            //imp.setTitle(WindowI3 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(0).SingleChannelWindow3.getImagePlus().getChannel() - 1] + WindowNameExtension);
                            imp.setTitle(WindowI3 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[2] + WindowNameExtension);
                        }
                        else {
                            slice = data.Sequences.elementAt(0).Window.getImagePlus().getSlice() - 1;
                            frame = data.Sequences.elementAt(0).Window.getImagePlus().getFrame() - 1;
                      }
                    }
                    else if (imp.getTitle().startsWith(WindowI4)) {
                        if (data.Sequences.elementAt(0).SingleChannelWindow4 != null) {
                            slice = data.Sequences.elementAt(0).SingleChannelWindow4.getImagePlus().getSlice() - 1;
                            frame = data.Sequences.elementAt(0).SingleChannelWindow4.getImagePlus().getFrame() - 1;
                            //imp.setTitle(WindowI4 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(0).SingleChannelWindow4.getImagePlus().getChannel() - 1] + WindowNameExtension);
                            imp.setTitle(WindowI4 + " " + data.Sequences.elementAt(0).Frames.elementAt(0).ChannelName[3] + WindowNameExtension);
                        }
                        else {
                            slice = data.Sequences.elementAt(0).Window.getImagePlus().getSlice() - 1;
                            frame = data.Sequences.elementAt(0).Window.getImagePlus().getFrame() - 1;
                        }
                    }
                    else {
                        slice = data.Sequences.elementAt(0).Window.getImagePlus().getSlice() - 1;
                        frame = data.Sequences.elementAt(0).Window.getImagePlus().getFrame() - 1;
                    }
                    if (frame != sequenceSelection.getSelectedIndex()) {
                        sequenceSelection.select(frame);
                        currentSequence = data.Sequences.elementAt(frame);
                        LoadFrame(false);
                    }
                    if (slice != frameSelection.getSelectedIndex()) {
                        frameSelection.select(slice);
                        currentFrame = currentSequence.Frames.elementAt(slice);
                        LoadFrame(false);
                    }
                    if ((currentSequence.ChannelCount() > 1) && ((frame != sequenceSelection.getSelectedIndex()) || (slice != frameSelection.getSelectedIndex()))) {
                        if (data.Sequences.elementAt(0).SingleChannelWindow1 != null) {
                            int channel = data.Sequences.elementAt(0).SingleChannelWindow1.getImagePlus().getChannel();
                            data.Sequences.elementAt(0).SingleChannelWindow1.getImagePlus().setPosition(channel, slice + 1, frame + 1);
                        }
                        if (data.Sequences.elementAt(0).SingleChannelWindow2 != null) {
                            int channel = data.Sequences.elementAt(0).SingleChannelWindow2.getImagePlus().getChannel();
                            data.Sequences.elementAt(0).SingleChannelWindow2.getImagePlus().setPosition(channel, slice + 1, frame + 1);
                        }
                        if (currentSequence.ChannelCount() > 2) {
                            if (data.Sequences.elementAt(0).SingleChannelWindow3 != null) {
                                int channel = data.Sequences.elementAt(0).SingleChannelWindow3.getImagePlus().getChannel();
                                data.Sequences.elementAt(0).SingleChannelWindow3.getImagePlus().setPosition(channel, slice + 1, frame + 1);
                            }
                        }
                        if (currentSequence.ChannelCount() > 3) {
                            if (data.Sequences.elementAt(0).SingleChannelWindow4 != null) {
                                int channel = data.Sequences.elementAt(0).SingleChannelWindow4.getImagePlus().getChannel();
                                data.Sequences.elementAt(0).SingleChannelWindow4.getImagePlus().setPosition(channel, slice + 1, frame + 1);
                            }
                        }
                    }
                } else if (currentSequence.isZSeries) {
                    int slice;
                    if (imp.getTitle().startsWith(WindowI1)) {
                        if (currentSequence.SingleChannelWindow1 != null) {
                            slice = currentSequence.SingleChannelWindow1.getImagePlus().getSlice() - 1;
                            //imp.setTitle(WindowI1 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().getChannel() - 1] + WindowNameExtension);
                            imp.setTitle(WindowI1 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[0] + WindowNameExtension);
                        }
                        else {
                            slice = currentSequence.Window.getImagePlus().getSlice() - 1;
                        }
                    }
                    else if (imp.getTitle().startsWith(WindowI2)) {
                        if (currentSequence.SingleChannelWindow2 != null) {
                            slice = currentSequence.SingleChannelWindow2.getImagePlus().getSlice() - 1;
                            //imp.setTitle(WindowI2 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().getChannel() - 1] + WindowNameExtension);
                            imp.setTitle(WindowI2 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[1] + WindowNameExtension);
                        }
                        else {
                            slice = currentSequence.Window.getImagePlus().getSlice() - 1;
                        }
                    }
                    else if (imp.getTitle().startsWith(WindowI3)) {
                        if (currentSequence.SingleChannelWindow3 != null) {
                            slice = currentSequence.SingleChannelWindow3.getImagePlus().getSlice() - 1;
                            //imp.setTitle(WindowI3 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().getChannel() - 1] + WindowNameExtension);
                            imp.setTitle(WindowI3 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[2] + WindowNameExtension);
                        }
                        else {
                            slice = currentSequence.Window.getImagePlus().getSlice() - 1;
                        }
                    }
                    else if (imp.getTitle().startsWith(WindowI4)) {
                        if (currentSequence.SingleChannelWindow4 != null) {
                            slice = currentSequence.SingleChannelWindow4.getImagePlus().getSlice() - 1;
                            //imp.setTitle(WindowI4 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().getChannel() - 1] + WindowNameExtension);
                            imp.setTitle(WindowI4 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[3] + WindowNameExtension);
                        }
                        else {
                            slice = currentSequence.Window.getImagePlus().getSlice() - 1;
                        }
                    }
                    else {
                        slice = currentSequence.Window.getImagePlus().getSlice() - 1;
                    }
                    //IJ.showStatus("sequenceCount = " + sequenceCount + "    slice = " + slice);
                    if (slice != frameSelection.getSelectedIndex()) {
                        //IJ.showMessage("imageUpdated() index = " + (slice + 1));
                        currentFrame.Index = slice + 1;
                        frameSelection.select(slice);
                        //LoadFrame(false);
                        if (currentSequence.ChannelCount() > 1) {
                            if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1 != null) {
                                //int channel = data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().getChannel();
                                int channel = 1;
                                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().setPosition(1, 1, slice + 1);
                                //data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().setPosition(channel, slice + 1, 1);
                            }
                            if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2 != null) {
                                //int channel = data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().getChannel();
                                int channel = 1;
                                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().setPosition(1, 1, slice + 1);
                                //data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().setPosition(channel, slice + 1, 1);
                            }
                            if (currentSequence.ChannelCount() > 2) {
                                if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3 != null) {
                                    //int channel = data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().getChannel();
                                    int channel = 1;
                                    data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().setPosition(1, 1, slice + 1);
                                    //data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().setPosition(channel, slice + 1, 1);
                                }
                            }
                            if (currentSequence.ChannelCount() > 3) {
                                if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4 != null) {
                                    //int channel = data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().getChannel();
                                    int channel = 1;
                                    data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().setPosition(1, 1, slice + 1);
                                    //data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().setPosition(channel, slice + 1, 1);
                                }
                            }
                        }
                        LoadFrame(false);
                    }
                } else {
                    int frame;
                    if (imp.getTitle().startsWith(WindowI1)) {
                        if (currentSequence.SingleChannelWindow1 != null) {
                            frame = currentSequence.SingleChannelWindow1.getImagePlus().getFrame() - 1;
                            //imp.setTitle(WindowI1 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().getChannel() - 1] + WindowNameExtension);
                        }
                        else
                            frame = currentSequence.Window.getImagePlus().getFrame() - 1;
                    }
                    else if (imp.getTitle().startsWith(WindowI2)) {
                        if (currentSequence.SingleChannelWindow2 != null) {
                            frame = currentSequence.SingleChannelWindow2.getImagePlus().getFrame() - 1;
                            //imp.setTitle(WindowI2 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().getChannel() - 1] + WindowNameExtension);
                        }
                        else
                            frame = currentSequence.Window.getImagePlus().getFrame() - 1;
                    }
                    else if (imp.getTitle().startsWith(WindowI3)) {
                        if (currentSequence.SingleChannelWindow3 != null) {
                            frame = currentSequence.SingleChannelWindow3.getImagePlus().getFrame() - 1;
                            //imp.setTitle(WindowI3 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().getChannel() - 1] + WindowNameExtension);
                        }
                        else
                            frame = currentSequence.Window.getImagePlus().getFrame() - 1;
                    }
                    else if (imp.getTitle().startsWith(WindowI4)) {
                        if (currentSequence.SingleChannelWindow4 != null) {
                            frame = currentSequence.SingleChannelWindow4.getImagePlus().getFrame() - 1;
                            //imp.setTitle(WindowI4 + " " + data.Sequences.elementAt(currentSequenceNum).Frames.elementAt(0).ChannelName[data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().getChannel() - 1] + WindowNameExtension);
                        }
                        else
                            frame = currentSequence.Window.getImagePlus().getFrame() - 1;
                    }
                    else
                        frame = currentSequence.Window.getImagePlus().getFrame() - 1;
                    if (frame != frameSelection.getSelectedIndex()) {
                        currentFrame.Index = frame + 1;
                        frameSelection.select(frame);
                        LoadFrame(false);
                        if (currentSequence.ChannelCount() > 1) {
                            if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1 != null) {
                                //int channel = data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().getChannel();
                                int channel = 1;
                                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().setPosition(channel, 1, frame + 1);
                            }
                            if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2 != null) {
                                //int channel = data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().getChannel();
                                int channel = 1;
                                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().setPosition(channel, 1, frame + 1);
                            }
                            if (currentSequence.ChannelCount() > 2) {
                                if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3 != null) {
                                    //int channel = data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().getChannel();
                                    int channel = 1;
                                    data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().setPosition(channel, 1, frame + 1);
                                }
                            }
                            if (currentSequence.ChannelCount() > 3) {
                                if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4 != null) {
                                    //int channel = data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().getChannel();
                                    int channel = 1;
                                    data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().setPosition(channel, 1, frame + 1);
                                }
                            }
                        }
                    }
                 }
            }
                
            blockImageUpdatedMethod = false;
                    
	}

	private void LoadFrame(Boolean justUpdateMetaData) {
            int currentSequenceNum = sequenceSelection.getSelectedIndex();
            int currentFrameNum = frameSelection.getSelectedIndex();
            Calibration imageCalib = new Calibration();
            imageCalib.setUnit("micron");
            imageCalib.pixelWidth = currentFrame.NumMicronsPerPixelX();
            if (currentSequence.isLinescan)
                imageCalib.pixelHeight = currentFrame.ScanlinePeriod;
            else
                imageCalib.pixelHeight = currentFrame.NumMicronsPerPixelY();
            //IJ.showStatus("frame number = " + currentFrameNum);
            if (currentSequence.isZSeries)
                imageCalib.pixelDepth = currentSequence.ZSeriesStepSize;
            if (data.isMatrix()) {
                if (data.Sequences.elementAt(0).Window != null)
                    data.Sequences.elementAt(0).Window.getImagePlus().setCalibration(imageCalib);
                if (currentSequence.ChannelCount() > 1) {
                    if (data.Sequences.elementAt(0).SingleChannelWindow1 != null)
                        data.Sequences.elementAt(0).SingleChannelWindow1.getImagePlus().setCalibration(imageCalib);
                    if (data.Sequences.elementAt(0).SingleChannelWindow2 != null)
                        data.Sequences.elementAt(0).SingleChannelWindow2.getImagePlus().setCalibration(imageCalib);
                }
                if (currentSequence.ChannelCount() > 2) {
                    if (data.Sequences.elementAt(0).SingleChannelWindow3 != null)
                        data.Sequences.elementAt(0).SingleChannelWindow3.getImagePlus().setCalibration(imageCalib);
                }
                if (currentSequence.ChannelCount() > 3) {
                    if (data.Sequences.elementAt(0).SingleChannelWindow4 != null)
                        data.Sequences.elementAt(0).SingleChannelWindow4.getImagePlus().setCalibration(imageCalib);
                }
            } else {
                if (data.Sequences.elementAt(currentSequenceNum).Window != null)
                    data.Sequences.elementAt(currentSequenceNum).Window.getImagePlus().setCalibration(imageCalib);
                if (data.Sequences.elementAt(currentSequenceNum).ChannelCount() > 1) {
                    if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1 != null)
                        data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().setCalibration(imageCalib);
                    if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2 != null)
                        data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().setCalibration(imageCalib);
                }
                if (currentSequence.ChannelCount() > 2) {
                    if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3 != null)
                        data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().setCalibration(imageCalib);
                }
                if (currentSequence.ChannelCount() > 3) {
                    if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4 != null)
                        data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().setCalibration(imageCalib);
                }
          }

            metadata.setText("");
            if (!currentSequence.isMosaic)
                metadata.append("Sequence Absolute Start Time: " + currentSequence.AbsoluteTime() + "\n");
            metadata.append("Prairie View Version: " + data.Version + "\n");
            metadata.append("Acquired: " + data.AcquireDateTime + "\n");
            // Display the warning message here (at the start of the meta data) and also display it at the bottom
            if ((currentFrame.ValidData == false) || (currentFrame.LastGoodFrame > 0)) {
                if (currentFrame.ValidData == false) {
                    metadata.append("\n" + "This data sequence in invalid!" + "\n");
                    metadata.append("At some unknown point or points in the sequence acquisition," + "\n");
                    metadata.append("Prairie View missed (dropped) data that was being acquired." + "\n");
                    metadata.append("This resulted in inconsistent image data that cannot be" + "\n");
                    metadata.append("trusted to match the recorded image timestamps." + "\n" + "\n");
                }
                if (currentFrame.LastGoodFrame > 0) {
                    if (data.isVersion5dot0orGreater()) {
                        metadata.append("\n" + "This data sequence is valid only up to frame " + currentFrame.LastGoodFrame + "!" + "\n");
                    }
                    else {
                        metadata.append("\n" + "This data sequence is valid only up to frame " + (currentFrame.LastGoodFrame / currentFrame.RastersPerFrame) + "!" + "\n");
                    }
                    metadata.append("After this frame in the sequence, Prairie View" + "\n");
                    metadata.append("missed (dropped) data that was being acquired." + "\n");
                    metadata.append("This resulted in inconsistent image data that cannot be" + "\n");
                    metadata.append("trusted to match the recorded image timestamps after" + "\n");
                    metadata.append("this frame." + "\n" + "\n");
                }
            }
            if (!currentSequence.isMosaic)
                metadata.append("Frame Relative Start Time: " + currentFrame.RelativeTime() + "\n");
            if (currentFrame.SystemTypeFound)
                metadata.append("System Type: " + currentFrame.SystemType() + "\n");
            else
                metadata.append("System Type: " + currentFrame.ActiveMode() + "\n");
            if (currentSequence.isPointscan) {
                metadata.append("Point Scan Galvos: " + currentSequence.PointScanGalvos + "\n");
                metadata.append("Point Scan Dwell Time: " + currentSequence.PointScanDwellTime + " us\n");
                metadata.append("Point Scan Sampling Rate: " + ((1 / currentSequence.PointScanDwellTime) * 1000.0) + " KHz\n");
                if ((currentSequence.PointScanGalvoType == currentSequence.PointScanGalvoImaging) || (currentSequence.PointScanGalvoType == currentSequence.PointScanGalvoImagingUncaging)) {
                    metadata.append("Point Scan Imaging Galvos Position: " + currentSequence.PointScanImagingX + "," + currentSequence.PointScanImagingY + "\n");
                }
                if ((currentSequence.PointScanGalvoType == currentSequence.PointScanGalvoUncaging) || (currentSequence.PointScanGalvoType == currentSequence.PointScanGalvoImagingUncaging)) {
                    metadata.append("Point Scan Uncaging Galvos Position: " + currentSequence.PointScanUncagingX + "," + currentSequence.PointScanUncagingY + "\n");
                }
            }
            metadata.append("Rasters per Frame: " + currentFrame.RastersPerFrame + "\n");
            metadata.append("Pixels per Line: " + currentFrame.PixelsPerLine + "\n");
            metadata.append("Lines per Frame: " + currentFrame.LinesPerFrame + "\n");
            if ((currentFrame.ActiveMode != ModeSFC) && (currentFrame.ActiveMode != ModeCamera))
                metadata.append("Dwell Time: " + currentFrame.DwellTime + " us\n");
            metadata.append("Objective: " + currentFrame.ObjectiveLens + "\n");
            if (currentFrame.ObjectiveLensNA != null) metadata.append("Objective NA: " + currentFrame.ObjectiveLensNA + "\n");
            if (currentFrame.ObjectiveLensMag != null) metadata.append("Objective Magnification: " + currentFrame.ObjectiveLensMag + "\n");
            if ((currentFrame.ActiveMode != ModeSFC) && (currentFrame.ActiveMode != ModeCamera))
                metadata.append("Binning Mode: " + currentFrame.BinningMode() + "\n");
            metadata.append("Frame Averaging: " + currentFrame.FrameAveraging + "\n");
            if ((currentFrame.ActiveMode != ModeSFC) && (currentFrame.ActiveMode != ModeCamera)) {
                if (!currentSequence.isMosaic) {
                    metadata.append("Frame Period: " + currentFrame.FramePeriod + "\n");
                    metadata.append("Scanline Period: " + currentFrame.ScanlinePeriod() + "\n");
                }
                metadata.append("Optical Zoom: " + currentFrame.OpticalZoom() + "\n");
            }
            metadata.append("X Microns per Pixel: " + currentFrame.MicronsPerPixelX() + "\n");
            if (!currentSequence.isLinescan) {
                metadata.append("Y Microns per Pixel: " + currentFrame.MicronsPerPixelY() + "\n");
                metadata.append("Field of View (FOV): " + currentFrame.FieldOfView() + "\n");
            }
            if ((currentFrame.ActiveMode != ModeSFC) && (currentFrame.ActiveMode != ModeCamera))
                metadata.append("Scan Rotation: " + currentFrame.Rotation + "\n");
            if (!currentSequence.isMosaic)
                metadata.append("Position: " + currentFrame.Position() + "\n");
            for (int index = 0; index < 11; index++) {
                if (currentFrame.LaserPower[index] != null)
                    metadata.append("Laser " + (index + 1) + " (" + data.LaserNames[index] + ") " + " Power: " + currentFrame.LaserPower[index] + "\n");
            }
            if ((currentFrame.ActiveMode != ModeSFC) && (currentFrame.ActiveMode != ModeCamera)) {
                for (int index = 0; index < 8; index++) {
                    if (currentFrame.PMTGain[index] != null)
                        metadata.append("PMT " + (index + 1) + " HV: " + currentFrame.PMTGain[index] + "\n");
            }
            }
            for (int index = 0; index < 8; index++) {
                if (currentFrame.PreAmpGain[index] != null) {
                    metadata.append("Channel" + (index + 1) + " Preamplifier Gain: " + currentFrame.PreAmpGain[index] + "\n");
                    if (currentFrame.PreAmpOffset[index] != null) metadata.append("Channel" + (index + 1) + " Preamplifier Offset: " + currentFrame.PreAmpOffset[index] + "\n");
                    if (currentFrame.PreAmpFilter[index] != null) metadata.append("Channel" + (index + 1) + " Preamplifier Filter: " + currentFrame.PreAmpFilter[index] + "\n");  // omitting for now since filters are currently only stored in the configration file
                }
            }
            for (int index = 0; index < 4; index++) {
                if (currentFrame.LaserWavelength[index] > 10) {
                    metadata.append("Laser " + (index + 1) + " Wavelength: " + currentFrame.LaserWavelength[index] + " at " + currentFrame.TwoPhotonLaserPower[index] + "\n");
                }
            }
            if (data.Notes.length() > 0) metadata.append("Notes: " + data.Notes + "\n");
            if (currentFrame.ActiveMode == ModeSFC) {
                if (currentFrame.SFCExposureTime != null )
                    metadata.append("SFC Exposure Time: " + currentFrame.SFCExposureTime + "\n");
                if (currentFrame.SFCExposureMode != null )
                    metadata.append("SFC Exposure Mode: " + currentFrame.SFCExposureMode + "\n");
                if (currentFrame.SFCEmissionFilter != null )
                    metadata.append("SFC Emission Filter: " + currentFrame.SFCEmissionFilter + "\n");
                if (currentFrame.SFCAperture != null )
                    metadata.append("SFC Aperture: " + currentFrame.SFCAperture + "\n");
                if (currentFrame.SFCGain != null )
                    metadata.append("SFC Gain: " + currentFrame.SFCGain + "\n");
                if (currentFrame.SFCGainMultFactor != null )
                    metadata.append("SFC Gain Multiplication Factor: " + currentFrame.SFCGainMultFactor + "\n");
                    metadata.append("SFC Binning Factor: " + currentFrame.SFCBinFactor() + "\n");
                if (currentFrame.SFCChannel1Lasers != null )
                    metadata.append("SFC Channel 1 Lasers: " + currentFrame.SFCChannel1Lasers + "\n");
                if (currentFrame.SFCChannel2Lasers != null )
                    metadata.append("SFC Channel 2 Lasers: " + currentFrame.SFCChannel2Lasers + "\n");
                if (currentFrame.SFCChannel3Lasers != null )
                    metadata.append("SFC Channel 3 Lasers: " + currentFrame.SFCChannel3Lasers + "\n");
                if (currentFrame.SFCChannel4Lasers != null )
                    metadata.append("SFC Channel 4 Lasers: " + currentFrame.SFCChannel4Lasers + "\n");
           }
            if (currentFrame.ActiveMode == ModeCamera) {
                if (currentFrame.CameraExposureTime != null )
                    metadata.append("Camera Exposure Time: " + currentFrame.CameraExposureTime + "\n");
                if (currentFrame.CameraExposureMode != null )
                    metadata.append("Camera Exposure Mode: " + currentFrame.CameraExposureMode + "\n");
                if (currentFrame.CameraGain != null )
                    metadata.append("Camera Gain: " + currentFrame.CameraGain + "\n");
                if (currentFrame.CameraGainMultFactor != null )
                    metadata.append("Camera Gain Multiplication Factor: " + currentFrame.CameraGainMultFactor + "\n");
                metadata.append("Camera Binning Factor: " + currentFrame.CameraBinFactor() + "\n");
            }
            //*TJK++ 2/13/2012 Added Confocal paramters
            if (currentFrame.ConfocalChannel123DichroicLabel != null)
                metadata.append("Confocal Channel 1 2/3 Dichroic: " + currentFrame.ConfocalChannel123DichroicLabel + "\n");
            if (currentFrame.ConfocalChannel23DichroicLabel != null)
                metadata.append("Confocal Channel 2/3 Dichroic: " + currentFrame.ConfocalChannel23DichroicLabel + "\n");
            if (currentFrame.ConfocalChannel1FilterLabel != null)
                metadata.append("Confocal Channel 1 Filter: " + currentFrame.ConfocalChannel1FilterLabel + "\n");
            if (currentFrame.ConfocalChannel2FilterLabel != null)
                metadata.append("Confocal Channel 2 Filter: " + currentFrame.ConfocalChannel2FilterLabel + "\n");
            if (currentFrame.ConfocalChannel3FilterLabel != null)
                metadata.append("Confocal Channel 3 Filter: " + currentFrame.ConfocalChannel3FilterLabel + "\n");
            if (currentFrame.ConfocalPinholeLabel != null)
                metadata.append("Confocal Pinhole: " + currentFrame.ConfocalPinholeLabel + "\n");

            if ((currentFrame.ValidData == false) || (currentFrame.LastGoodFrame > 0)) {
                if (currentFrame.ValidData == false) {
                    metadata.append("\n" + "This data sequence in invalid!" + "\n");
                    metadata.append("At some unknown point or points in the sequence acquisition," + "\n");
                    metadata.append("Prairie View missed (dropped) data that was being acquired." + "\n");
                    metadata.append("This resulted in inconsistent image data that cannot be" + "\n");
                    metadata.append("trusted to match the recorded image timestamps." + "\n" + "\n");
                }
                if (currentFrame.LastGoodFrame > 0) {
                    if (data.isVersion5dot0orGreater()) {
                        metadata.append("\n" + "This data sequence is valid only up to frame " + currentFrame.LastGoodFrame + "!" + "\n");
                    }
                    else {
                        metadata.append("\n" + "This data sequence is valid only up to frame " + (currentFrame.LastGoodFrame / currentFrame.RastersPerFrame) + "!" + "\n");
                    }
                    metadata.append("After this frame in the sequence, Prairie View" + "\n");
                    metadata.append("missed (dropped) data that was being acquired." + "\n");
                    metadata.append("This resulted in inconsistent image data that cannot be" + "\n");
                    metadata.append("trusted to match the recorded image timestamps after" + "\n");
                    metadata.append("this frame." + "\n" + "\n");
                }
            }
            
            // Set the meta data display so it is at the beginning.
            metadata.setCaretPosition(0);
            
            if (justUpdateMetaData) return;
            if (currentSequence.Window != null || (data.isMatrix() && data.Sequences.elementAt(0).Window != null)) {
                if (currentSequence.ChannelCount() > 1) {
                    if (data.isMatrix()) {
                        if (data.Sequences.elementAt(0).Window != null) {
                            StackWindow window = (StackWindow) data.Sequences.elementAt(0).Window;
                            window.setPosition(window.getImagePlus().getChannel(), currentFrame.Index, currentSequence.Index);
                        }
                        if (data.Sequences.elementAt(0).SingleChannelWindow1 != null) {
                            StackWindow window1 = (StackWindow) data.Sequences.elementAt(0).SingleChannelWindow1;
                            window1.setPosition(window1.getImagePlus().getChannel(), currentFrame.Index, currentSequence.Index);
                        }
                        if (data.Sequences.elementAt(0).SingleChannelWindow2 != null) {
                            StackWindow window2 = (StackWindow) data.Sequences.elementAt(0).SingleChannelWindow2;
                            window2.setPosition(window2.getImagePlus().getChannel(), currentFrame.Index, currentSequence.Index);
                        }
                       if (currentSequence.ChannelCount() > 2) {
                            if (data.Sequences.elementAt(0).SingleChannelWindow3 != null) {
                                StackWindow window3 = (StackWindow) currentSequence.SingleChannelWindow3;
                                window3.setPosition(window3.getImagePlus().getChannel(), currentFrame.Index, currentSequence.Index);
                            }
                        }
                        if (currentSequence.ChannelCount() > 3) {
                            if (data.Sequences.elementAt(0).SingleChannelWindow4 != null) {
                                StackWindow window4 = (StackWindow) currentSequence.SingleChannelWindow4;
                                window4.setPosition(window4.getImagePlus().getChannel(), currentFrame.Index, currentSequence.Index);
                            }
                        }
                    }
                    else if (currentSequence.isZSeries) {
                        if (currentSequence.Window != null) {
                            //currentSequence.Window.getImagePlus().setSlice(currentFrame.Index);
                            currentSequence.Window.getImagePlus().setPosition(data.Sequences.elementAt(currentSequenceNum).Window.getImagePlus().getChannel(), currentFrame.Index, 1);    
                        }
                        if (currentSequence.SingleChannelWindow1 != null) {
                            StackWindow window1 = (StackWindow) currentSequence.SingleChannelWindow1;
                            //window1.setPosition(1, currentFrame.Index, 1);
                            window1.getImagePlus().setSlice(currentFrame.Index);
                        }
                        if (currentSequence.SingleChannelWindow2 != null) {
                            StackWindow window2 = (StackWindow) currentSequence.SingleChannelWindow2;
                            //window2.setPosition(1, currentFrame.Index, 1);
                            window2.getImagePlus().setSlice(currentFrame.Index);
                        }
                        if (currentSequence.ChannelCount() > 2) {
                            if (currentSequence.SingleChannelWindow3 != null) {
                                StackWindow window3 = (StackWindow) currentSequence.SingleChannelWindow3;
                                window3.setPosition(1, currentFrame.Index, 1);
                                //window3.getImagePlus().setSlice(currentFrame.Index);
                            }
                        }
                        if (currentSequence.ChannelCount() > 3) {
                            if (currentSequence.SingleChannelWindow4 != null) {
                                StackWindow window4 = (StackWindow) currentSequence.SingleChannelWindow4;
                                window4.setPosition(1, currentFrame.Index, 1);
                                //window4.getImagePlus().setSlice(currentFrame.Index);
                            }
                        }
                    }
                    else {
                        if (data.Sequences.elementAt(currentSequenceNum).Window != null) {
                            data.Sequences.elementAt(currentSequenceNum).Window.getImagePlus().setPosition(data.Sequences.elementAt(currentSequenceNum).Window.getImagePlus().getChannel(), 1, currentFrame.Index);
                        }
                        if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1 != null) {
                            data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().setPosition(data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow1.getImagePlus().getChannel(), 1, currentFrame.Index);
                        }
                        if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2 != null) {
                            data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().setPosition(data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow2.getImagePlus().getChannel(), 1, currentFrame.Index);
                        }
//					currentSequence.Window.getImagePlus().setPosition(currentSequence.Window.getImagePlus().getChannel(), 1, currentFrame.Index);
//                                      currentSequence.SingleChannelWindow1.getImagePlus().setPosition(currentSequence.SingleChannelWindow1.getImagePlus().getChannel(), 1, currentFrame.Index);
//                                      currentSequence.SingleChannelWindow2.getImagePlus().setPosition(currentSequence.SingleChannelWindow2.getImagePlus().getChannel(), 1, currentFrame.Index);
                        if (currentSequence.ChannelCount() > 2) {
//                                            currentSequence.SingleChannelWindow3.getImagePlus().setPosition(currentSequence.SingleChannelWindow3.getImagePlus().getChannel(), 1, currentFrame.Index);
                            if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3 != null) {
                                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().setPosition(data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow3.getImagePlus().getChannel(), 1, currentFrame.Index);
                            }
                        }
                        if (currentSequence.ChannelCount() > 3) {
//                                            currentSequence.SingleChannelWindow4.getImagePlus().setPosition(currentSequence.SingleChannelWindow4.getImagePlus().getChannel(), 1, currentFrame.Index);
                            if (data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4 != null) {
                                data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().setPosition(data.Sequences.elementAt(currentSequenceNum).SingleChannelWindow4.getImagePlus().getChannel(), 1, currentFrame.Index);
                            }
                        }
                    }
                } else {
                    if (data.isMatrix()) {
                        StackWindow window = (StackWindow) data.Sequences.elementAt(0).Window;
                        window.setPosition(window.getImagePlus().getChannel(), currentFrame.Index, currentSequence.Index);
                    } if (currentSequence.isZSeries) {
                        currentSequence.Window.getImagePlus().setSlice(currentFrame.Index);
                    } else {
                        currentSequence.Window.getImagePlus().setSlice(currentFrame.Index);
                    }
                }
            }
	}

	public void processWindowEvent(WindowEvent e) {
            super.processWindowEvent(e);
            if (e.getID()==WindowEvent.WINDOW_CLOSING) {
                    instance = null;	
            }
	}

        enum MosaicOverlap {
            CopyPixels,
            BrightestPixel,
            AveragePixel;
        }
        
        public void ProcessMosaic(MosaicOverlap overlapProcessing) {
            
            // Make sure this is a mosaic data set.
            if (!data.Sequences.elementAt(0).isMosaic) return;
        
            // If the mosaic has already been rendered, then return;
            if (data.Sequences.elementAt(0).mosaicRendered) return;
            
            // Next, make sure that either the number of images in the 
            // x, y, or both x and y is greater than one (1).
            if ((data.Sequences.elementAt(0).MosaicNumXImages <= 1) && (data.Sequences.elementAt(0).MosaicNumYImages <= 1))
                return;
            
            // Determine the total number of images in the data set
            // to determine if the appropriate criteria are met for generating
            // the mosaic image(s).
            
            int totalDataSetImages= 0;
            for (int index = 0; index < data.Sequences.size(); index++) {
                totalDataSetImages += (data.Sequences.elementAt(index).Frames.size() * data.Sequences.elementAt(index).ChannelCount());
            }
            
            // Make sure that the number of "sequences" is equal to the
            // number of images in x multiplied by the number of images in y
            
            // Take the total number of images and divide by the product of the number
            // of images in one mosaic (numXImages * numYImages * numZImages).  If the
            // remainder is not 0, then this is not a purely timelapse mosaic data
            // set.
            
            if ((totalDataSetImages % (data.Sequences.elementAt(0).MosaicNumXImages * data.Sequences.elementAt(0).MosaicNumYImages * data.Sequences.elementAt(0).MosaicNumZImages)) != 0) return;
            
            // Compute the total number of sequences in this data set.
            int numMosaicSequences = totalDataSetImages / (data.Sequences.elementAt(0).MosaicNumXImages * data.Sequences.elementAt(0).MosaicNumYImages * data.Sequences.elementAt(0).MosaicNumZImages * data.Sequences.elementAt(0).ChannelCount());
            
            // Make sure that there is the same number of images in the Z
            // dimension for each x,y location in the mosaic.
            int numZImages = data.Sequences.elementAt(0).MosaicNumZImages;
            boolean numZImagesEqual = true;
            for (int index = 1; index < data.Sequences.size() - 1; index++) {
                if (data.Sequences.elementAt(index).MosaicNumZImages != numZImages)
                    numZImagesEqual = false;
            }
            if (!numZImagesEqual) return;
            
            // The basic criteria for creating the mosaic has been met.
            
            // Compute the number of pixels in the mosaic images.
            int xRes = data.Sequences.elementAt(0).Frames.elementAt(0).PixelsPerLine;
            int numXOverlapPixels = (int)((((double)data.Sequences.elementAt(0).MosaicOverlapPercentage / 100.0) * (double)xRes) + 0.5);
            int numXPixels = xRes + ((data.Sequences.elementAt(0).MosaicNumXImages - 1) * (xRes - numXOverlapPixels));
            int yRes = data.Sequences.elementAt(0).Frames.elementAt(0).LinesPerFrame;
            int numYOverlapPixels = (int)((((double)data.Sequences.elementAt(0).MosaicOverlapPercentage / 100.0) * (double)yRes) + 0.5);
            int numYPixels = yRes + ((data.Sequences.elementAt(0).MosaicNumYImages - 1) * (yRes - numYOverlapPixels));
            
            // Create the ImageStack that will contain each of the mosaic "slices"
            ImageStack mosaicStack = new ImageStack(numXPixels, numYPixels);
            
            // These parameters define where the pxiel data from the individual images
            // will be placed in the mosaic images.
            int xPixelLocation = 0;
            int yPixelLocation = 0;
            
            int numXImages = data.Sequences.elementAt(0).MosaicNumXImages;
            int numYImages = data.Sequences.elementAt(0).MosaicNumYImages;
            numZImages = data.Sequences.elementAt(0).MosaicNumZImages;
            int numChans = data.Sequences.elementAt(0).Frames.elementAt(0).ChannelCount();
            int imageCount = 0;
            int totalImages = numXImages * numYImages * numZImages * numChans;
            int sourcePixelColumn[] = new int[data.Sequences.elementAt(0).Frames.elementAt(0).LinesPerFrame];
            int imageHeight = data.Sequences.elementAt(0).Frames.elementAt(0).LinesPerFrame;
            int chanIndex = 0;
            float srcPixVal;
            float destPixVal;
            float sampleCount;
                             
            // Create four mosaic images, one for each potential channel
            ImagePlus[] mosaicImage1 = new ImagePlus[numZImages];
            ImagePlus[] mosaicImage2 = new ImagePlus[numZImages];
            ImagePlus[] mosaicImage3 = new ImagePlus[numZImages];
            ImagePlus[] mosaicImage4 = new ImagePlus[numZImages];
            for (int index = 0; index < numZImages; index++) {
                mosaicImage1[index] = IJ.createImage("mosaicImage1", "16-bit Black", numXPixels, numYPixels, 1);
                if (numChans > 1)
                    mosaicImage2[index] = IJ.createImage("mosaicImage2", "16-bit Black", numXPixels, numYPixels, 1);
                if (numChans > 2)
                    mosaicImage3[index] = IJ.createImage("mosaicImage3", "16-bit Black", numXPixels, numYPixels, 1);
                if (numChans > 3)
                    mosaicImage4[index] = IJ.createImage("mosaicImage4", "16-bit Black", numXPixels, numYPixels, 1);
            }
            
            // Create one mosaic image to use for the 'blending' of the mosaic images
            ImagePlus mosaicImageSamples = IJ.createImage("mosaicImage1", "16-bit Black", numXPixels, numYPixels, 1);
            
            int percentComplete = 0;
            
            for (int seqIndex = 0; seqIndex < numMosaicSequences; seqIndex++) {
                
                for (int zIndex = 0; zIndex <= numZImages - 1; zIndex++) {

                    // Initialize the various images

                    for (int intI = 0; intI < numXPixels; intI++) {
                        for (int intJ = 0; intJ < numYPixels; intJ++) {
    //                        mosaicImage1.getProcessor().putPixel(intI, intJ, 0);
    //                        mosaicImage2.getProcessor().putPixel(intI, intJ, 0);
    //                        mosaicImage3.getProcessor().putPixel(intI, intJ, 0);
    //                        mosaicImage4.getProcessor().putPixel(intI, intJ, 0);

                            mosaicImageSamples.getProcessor().putPixel(intI, intJ, 0);
                        }
                    }

                    // Starting the mosaic image creation for a new plane, reset the x and y pixel location controls
                    xPixelLocation = 0;
                    yPixelLocation = 0;

                    for (int yIndex = 0; yIndex <= numYImages - 1; yIndex++) {

                        // Starting a new 'row' of images for the mosaic, reset the x pixel location
                        xPixelLocation = 0;

                        for (int xIndex = 0; xIndex <= numXImages - 1; xIndex++) {

                            for (chanIndex = 0; chanIndex <=  numChans - 1; chanIndex++) {

                                // Update the total number of images processed and inform the operator
                                // via the status message.
                                imageCount++;
                                percentComplete = (int)(((double)imageCount / (double)totalDataSetImages) * 100.0);
                                IJ.showStatus("Processing image " + imageCount + " of " + totalDataSetImages + " (" + percentComplete + "%)");
                                
                                // Read the appropriate image
                                ImagePlus ip = new ImagePlus(data.Directory + data.Sequences.elementAt((seqIndex * totalImages) + (xIndex + (yIndex * numXImages))).Frames.elementAt(zIndex).Filename[chanIndex]);

                                switch (overlapProcessing) {
                                    case CopyPixels:
                                        // Copy the image pixels to the appropriate location in the 
                                        // destination image.  Copy the 'column' by 'column'.
                                        for (int intI = 0; intI < ip.getWidth(); intI++) {
                                            ip.getProcessor().getColumn(intI, 0, sourcePixelColumn, imageHeight);

                                            switch (chanIndex) {
                                                case 0:
                                                    mosaicImage1[zIndex].getProcessor().putColumn(xPixelLocation, yPixelLocation, sourcePixelColumn, imageHeight);
                                                    break;
                                                case 1:
                                                    mosaicImage2[zIndex].getProcessor().putColumn(xPixelLocation, yPixelLocation, sourcePixelColumn, imageHeight);
                                                    break;
                                                case 2:
                                                    mosaicImage3[zIndex].getProcessor().putColumn(xPixelLocation, yPixelLocation, sourcePixelColumn, imageHeight);
                                                    break;
                                                case 3:
                                                    mosaicImage4[zIndex].getProcessor().putColumn(xPixelLocation, yPixelLocation, sourcePixelColumn, imageHeight);
                                                    break;
                                                default:
                                                    break;
                                            }
                                            xPixelLocation++;
                                        }
                                        break;
                                    case BrightestPixel:
                                        for (int intI = 0; intI < ip.getWidth(); intI++) {
                                            for (int intJ = 0; intJ < ip.getHeight(); intJ++) {
                                                srcPixVal = ip.getProcessor().getPixelValue(intI, intJ);

                                                switch (chanIndex) {
                                                    case 0:
                                                        destPixVal =  mosaicImage1[zIndex].getProcessor().getPixel(xPixelLocation, yPixelLocation + intJ);
                                                        if (srcPixVal > destPixVal)
                                                            mosaicImage1[zIndex].getProcessor().putPixel(xPixelLocation, yPixelLocation + intJ, (int)(srcPixVal));
                                                        break;
                                                    case 1:
                                                        destPixVal =  mosaicImage2[zIndex].getProcessor().getPixel(xPixelLocation, yPixelLocation + intJ);
                                                        if (srcPixVal > destPixVal)
                                                            mosaicImage2[zIndex].getProcessor().putPixel(xPixelLocation, yPixelLocation + intJ, (int)(srcPixVal));
                                                        break;
                                                    case 2:
                                                        destPixVal =  mosaicImage3[zIndex].getProcessor().getPixel(xPixelLocation, yPixelLocation + intJ);
                                                        if (srcPixVal > destPixVal)
                                                            mosaicImage3[zIndex].getProcessor().putPixel(xPixelLocation, yPixelLocation + intJ, (int)(srcPixVal));
                                                        break;
                                                    case 3:
                                                        destPixVal =  mosaicImage4[zIndex].getProcessor().getPixel(xPixelLocation, yPixelLocation + intJ);
                                                        if (srcPixVal > destPixVal)
                                                            mosaicImage4[zIndex].getProcessor().putPixel(xPixelLocation, yPixelLocation + intJ, (int)(srcPixVal));
                                                        break;
                                                    default:
                                                        break;
                                                }
                                            }
                                            xPixelLocation++;
                                        }
                                        break;
                                    case AveragePixel:
                                        for (int intI = 0; intI < ip.getWidth(); intI++) {
                                            for (int intJ = 0; intJ < ip.getHeight(); intJ++) {
                                                srcPixVal = ip.getProcessor().getPixelValue(intI, intJ);

                                                if (chanIndex == 0) {
                                                    sampleCount =  mosaicImageSamples.getProcessor().getPixel(xPixelLocation, yPixelLocation + intJ);
                                                    mosaicImageSamples.getProcessor().putPixel(xPixelLocation, yPixelLocation + intJ, (int)(sampleCount + 1));
                                                }

                                                switch (chanIndex) {
                                                    case 0:
                                                        destPixVal =  mosaicImage1[zIndex].getProcessor().getPixel(xPixelLocation, yPixelLocation + intJ);
                                                        mosaicImage1[zIndex].getProcessor().putPixel(xPixelLocation, yPixelLocation + intJ, (int)(srcPixVal + destPixVal));
                                                        break;
                                                    case 1:
                                                        destPixVal =  mosaicImage2[zIndex].getProcessor().getPixel(xPixelLocation, yPixelLocation + intJ);
                                                        mosaicImage2[zIndex].getProcessor().putPixel(xPixelLocation, yPixelLocation + intJ, (int)(srcPixVal + destPixVal));
                                                        break;
                                                    case 2:
                                                        destPixVal =  mosaicImage3[zIndex].getProcessor().getPixel(xPixelLocation, yPixelLocation + intJ);
                                                        mosaicImage3[zIndex].getProcessor().putPixel(xPixelLocation, yPixelLocation + intJ, (int)(srcPixVal + destPixVal));
                                                        break;
                                                    case 3:
                                                        destPixVal =  mosaicImage4[zIndex].getProcessor().getPixel(xPixelLocation, yPixelLocation + intJ);
                                                        mosaicImage4[zIndex].getProcessor().putPixel(xPixelLocation, yPixelLocation + intJ, (int)(srcPixVal + destPixVal));
                                                        break;
                                                    default:
                                                        break;
                                                }
                                            }
                                            xPixelLocation++;
                                        }
                                        break;
                                }

                                if (numChans > 1) {
                                    // Since we are processing images from different channels before
                                    // advancing to the next physical location, move the xPixelLocation
                                    // value 'back' by the image x resolution
                                    if (chanIndex < (numChans - 1))
                                            xPixelLocation -= xRes;
                                }
                            }

                            // Move the xPixelLocation value 'back' by the 'overlap' amount
                            xPixelLocation -= numXOverlapPixels;
                        }

                        // Move the yPixelLocation value
                        yPixelLocation += (yRes - numYOverlapPixels);
                    }

                    switch (overlapProcessing) {
                        case AveragePixel:
                            // Re-process the mosaic images by dividing the pixel intensity
                            // at each location by the corresponding location in the 
                            // mosaicImageSamples instance.  These values should be either
                            // 1, 2, or 4 depending upon how many different images contributed
                            // to the pixel value (i.e. how many images overlap to create any
                            // given pixel).
                            float pixVal;
                            float divisor;
                            int result;
                            for (int intI = 0; intI < numXPixels; intI++) {
                                for (int intJ = 0; intJ < numYPixels; intJ++) {
                                    divisor = mosaicImageSamples.getProcessor().getPixel(intI, intJ);

                                    pixVal = mosaicImage1[zIndex].getProcessor().getPixel(intI, intJ);
                                    result = (int)(pixVal / divisor);
                                    mosaicImage1[zIndex].getProcessor().putPixel(intI, intJ, result);

                                    if (numChans > 1) {
                                        pixVal = mosaicImage2[zIndex].getProcessor().getPixel(intI, intJ);
                                        result = (int)(pixVal / divisor);
                                        mosaicImage2[zIndex].getProcessor().putPixel(intI, intJ, result);
                                    }
                                    if (numChans > 2) {
                                        pixVal = mosaicImage3[zIndex].getProcessor().getPixel(intI, intJ);
                                        result = (int)(pixVal / divisor);
                                        mosaicImage3[zIndex].getProcessor().putPixel(intI, intJ, result);
                                    }
                                    if (numChans > 3) {
                                        pixVal = mosaicImage4[zIndex].getProcessor().getPixel(intI, intJ);
                                        result = (int)(pixVal / divisor);
                                        mosaicImage4[zIndex].getProcessor().putPixel(intI, intJ, result);
                                    }
                                }
                            }
                            break;
                    }

                    // Add the mosaic images to the appropriate image stacks.
                    mosaicStack.addSlice(mosaicImage1[zIndex].getProcessor());
                    if (numChans > 1)
                        mosaicStack.addSlice(mosaicImage2[zIndex].getProcessor());
                    if (numChans > 2)
                        mosaicStack.addSlice(mosaicImage3[zIndex].getProcessor());
                    if (numChans > 3)
                        mosaicStack.addSlice(mosaicImage4[zIndex].getProcessor());

                    for (int channelIndex = 0; channelIndex < numChans; channelIndex++) {
                        String currentName = data.Sequences.elementAt(0).Frames.elementAt(0).Filename[channelIndex];
                        String currentNameNoExtension = currentName.substring(0, currentName.length() - 10);
                        // Replace the "CycleNNNNN" segment of the string with the corresponding
                        // "CycleNNNNN" where NNNNN is based upon the value (seqIndex + 1)
                        int cycleIndex = currentNameNoExtension.indexOf("_Cycle");
                        String oldCycle = currentNameNoExtension.substring(cycleIndex, cycleIndex+ 11);
                        String newCycle = "_Cycle" + String.format("%05d", (seqIndex + 1));
                        String currentNameNewCycle = currentNameNoExtension.replaceFirst(oldCycle, newCycle);
                        String fileNameNoDirectory;
                        if ((zIndex == 0) && (seqIndex == 0))
                            fileNameNoDirectory = currentNameNewCycle + "Mosaic_" + String.format("%06d", (zIndex + 1)) + ".tif";
                        else {
                            // When the first 'plane' mosaic image was created, the 'filename' property was set to the 
                            // file name with 'Mosaic' in it, so for all subsequent planes, I only need to change the
                            // number, since the 'Mosaic' text already exists.
                            fileNameNoDirectory = currentNameNewCycle + String.format("%06d", (zIndex + 1)) + ".tif";    
                        }
                        String fileName = data.Directory + fileNameNoDirectory;
                        data.Sequences.elementAt(seqIndex).Frames.elementAt(zIndex).Filename[channelIndex] = fileNameNoDirectory;
                        data.Sequences.elementAt(seqIndex).Frames.elementAt(zIndex).PixelsPerLine = numXPixels;
                        data.Sequences.elementAt(seqIndex).Frames.elementAt(zIndex).LinesPerFrame = numYPixels;
                        switch (channelIndex) {
                            case 0:
                                IJ.save(mosaicImage1[zIndex], fileName);
                                break;
                            case 1:
                                IJ.save(mosaicImage2[zIndex], fileName);
                                break;
                            case 2:
                                IJ.save(mosaicImage3[zIndex], fileName);
                                break;
                            case 3:
                                IJ.save(mosaicImage4[zIndex], fileName);
                                break;
                        //

                        }
                    }
                }

                data.Sequences.elementAt(seqIndex).mosaicRendered = true;

                // Display the image stack
    //            ImagePlus mosaicIP = new ImagePlus("Mosaic", mosaicStack);
    //            mosaicIP.setOpenAsHyperStack(true);
    //            mosaicIP.setDimensions(numChans, numZImages, 1);
    //            mosaicIP.show();
            }
            
            // Remove the extra "sequences" from the sequence list and also
            // from the sequenceSelection control
            for (int index = data.Sequences.size() - 1; index >= numMosaicSequences; index--) {
                data.Sequences.removeElementAt(index);
                sequenceSelection.remove(index);
            }
        }

        private void load() {
            OpenDialog od = new OpenDialog("Open Image Series Metadata", "");
            String directory = od.getDirectory();
            String name = od.getFileName();
            if (name==null)
                    return;
            loadFile(directory, name);
        }
               
	private void loadFile(String directory, String name) {
            Vector<Prairie_Frame> linescanSegments;
            //Integer zDevice = 0;  //*MJF+4 3/26/15 #2751 commented
            //Double zPos1 = 0.0;
            //Double zPos2 = 1.0;
            //String zPos1Str = "0.0";
            //String zPos2Str = "1.0";
            int frameIndex = 0;
            if (name == null)
                    return;
            sequenceSelection.removeAll();
            metadata.setText("");
            //Prairie_Frame globalFrameData = null;  //*MJF+1 3/26/15 #2751
            Prairie_Frame dataSetFrameData = null;
            currentFile.setText("Current File: " + directory + name);
            IJ.showStatus("Parsing: " + directory + name);
            
            linescanSegments = new Vector<Prairie_Frame>();
            
                try {
			DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
		        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
            		Document doc = docBuilder.parse(new File(directory + name));

			if (doc.getDocumentElement().getNodeName().equals("PVScan")) {
				Node pvscan = doc.getElementsByTagName("PVScan").item(0);
				data = new  Prairie_DataSet();
				data.Directory = directory;

				Node version = pvscan.getAttributes().getNamedItem("version");
				if (version == null) {
                                    data.Version = "Unknown";
                                    data.versionFirstValue = 0;
                                    data.versionSecondValue = 0;
                                    data.versionThirdValue = 0;
                                    data.versionFourthValue = 0;
                                }
                                else{
                                    data.versionFirstValue = 0;
                                    data.versionSecondValue = 0;
                                    data.versionThirdValue = 0;
                                    data.versionFourthValue = 0;
                                    data.Version = version.getNodeValue();
                                    String[] versionParts = data.Version.split("\\.");
                                    if (versionParts.length >= 1)
                                        data.versionFirstValue = Integer.parseInt(versionParts[0]);
                                    if (versionParts.length >= 2)
                                        data.versionSecondValue = Integer.parseInt(versionParts[1]);
                                    if (versionParts.length >= 3)
                                        data.versionThirdValue = Integer.parseInt(versionParts[2]);
                                    if (versionParts.length >= 4)
                                        data.versionFourthValue = Integer.parseInt(versionParts[3]);
                                }
                                
				data.Notes = pvscan.getAttributes().getNamedItem("notes").getNodeValue();
				data.AcquireDateTime = pvscan.getAttributes().getNamedItem("date").getNodeValue();
                                
                                NodeList sequences = pvscan.getChildNodes();
                                for(int i = 0; i < sequences.getLength(); i++) {
					Node sequence = sequences.item(i);
                                        if (sequence.getNodeName().equals("SystemConfiguration")) {
                                            NodeList frames = sequence.getChildNodes();
                                            for(int j = 0; j < frames.getLength(); j++) {
                                                Node frame = frames.item(j);
                                                if (frame.getNodeName().equals("Lasers")) {
                                                    // Read the laser names
                                                    NodeList lasers =  frame.getChildNodes();
                                                    for(int m = 0; m < lasers.getLength(); m++) {
                                                        Node laser = lasers.item(m);
                                                        if (laser.getNodeName().equals("Laser")) {
                                                            String laserName = laser.getAttributes().getNamedItem("name").getNodeValue();
                                                            String index = laser.getAttributes().getNamedItem("index").getNodeValue();
                                                            data.LaserNames[Integer.parseInt(index)] = laserName;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else if (sequence.getNodeName().equals("PVStateShard")) {
                                            // Starting with version 5.0.32.31 an option was added to allow for a smaller
                                            // .xml file to be generated.  When this option is selected, the complete PVStateShard is
                                            // not saved within each individual image in the file.  Rather, it is saved at three
                                            // different levels: data set, sequence and frame, and only recorded if it differs from
                                            // the level above (e.g. positionCurrent_ZAxis when a Z-series is acquired)
                                                                                       
                                            dataSetFrameData = new Prairie_Frame(0);
                                            
                                            dataSetFrameData.LoadPVStateShard(sequence);  //*MJF 3/26/15 #2751 using shared code
                                        }
                                        else if (sequence.getNodeName().equals("Sequence")) {
                                                linescanSegments.clear();
						sequenceSelection.add("Sequence " + (sequenceSelection.getItemCount() + 1));
						Prairie_Sequence sequenceData = new Prairie_Sequence((sequenceSelection.getItemCount()));
                                                sequenceData.Directory = directory;
                                                sequenceData.Filename = name.substring(0, name.lastIndexOf("."));
						if (sequence.getAttributes().getNamedItem("type").getNodeValue().contains("Linescan")) sequenceData.isLinescan = true;
                                                if (sequence.getAttributes().getNamedItem("type").getNodeValue().contains("Point Scan")) sequenceData.isPointscan = true;
						if (sequence.getAttributes().getNamedItem("type").getNodeValue().contains("ZSeries")) sequenceData.isZSeries = true;
						if (sequence.getAttributes().getNamedItem("bidirectionalZ") != null) {
                                                    data.isBiDirectionalZSeriesFlag = true;
                                                    if (sequence.getAttributes().getNamedItem("bidirectionalZ").getNodeValue().contains("True")) data.isBiDirectionalZSeries = true;
						}
						else{
                                                    data.isBiDirectionalZSeriesFlag = false;
                                                    data.isBiDirectionalZSeries = false;
                                                }
                                                if (sequence.getAttributes().getNamedItem("xYStageGridDefined") != null) {
                                                    sequenceData.isMosaic = Boolean.parseBoolean(sequence.getAttributes().getNamedItem("xYStageGridDefined").getNodeValue());
                                                    if (sequenceData.isMosaic) {
                                                        sequenceData.MosaicNumXImages = Integer.parseInt(sequence.getAttributes().getNamedItem("xYStageGridNumXPositions").getNodeValue());
                                                        sequenceData.MosaicNumYImages = Integer.parseInt(sequence.getAttributes().getNamedItem("xYStageGridNumYPositions").getNodeValue());
                                                        sequenceData.MosaicOverlapPercentage = Double.parseDouble(sequence.getAttributes().getNamedItem("xYStageGridOverlapPercentage").getNodeValue());
                                                        sequenceData.MosaicOverlapXInMicrons = Double.parseDouble(sequence.getAttributes().getNamedItem("xYStageGridXOverlap").getNodeValue());
                                                        sequenceData.MosaicOverlapYInMicrons = Double.parseDouble(sequence.getAttributes().getNamedItem("xYStageGridYOverlap").getNodeValue());
                                                    }
                                                }
                                                Prairie_Frame sequenceFrameData = null;  //*MJF 3/26/15 #2751
                                                NodeList frames = sequence.getChildNodes();
                                                for(int j = 0; j < frames.getLength(); j++) {
                                                        Node frame = frames.item(j);
                                                        if (frame.getNodeName().equals("PVPointScan")) {
                                                            // Read the Point Scan parameters
                                                            if ((data.versionFirstValue >= 5) && (data.versionSecondValue >= 2)) {
                                                                sequenceData.PointScanDataFileName = directory + frame.getAttributes().getNamedItem("Data").getNodeValue();
                                                                sequenceData.PointScanGalvos = "Imaging";
                                                                sequenceData.PointScanImagingX = Double.parseDouble(frame.getAttributes().getNamedItem("ImagingX").getNodeValue()) * dataSetFrameData.PixelsPerLine;
                                                                sequenceData.PointScanImagingY = Double.parseDouble(frame.getAttributes().getNamedItem("ImagingY").getNodeValue()) * dataSetFrameData.LinesPerFrame;
                                                                if (frame.getAttributes().getNamedItem("UncagingX") != null) {
                                                                    sequenceData.PointScanGalvos = "Both";
                                                                    sequenceData.PointScanUncagingX = Double.parseDouble(frame.getAttributes().getNamedItem("UncagingX").getNodeValue()) * dataSetFrameData.PixelsPerLine;
                                                                    sequenceData.PointScanUncagingY = Double.parseDouble(frame.getAttributes().getNamedItem("UncagingY").getNodeValue()) * dataSetFrameData.LinesPerFrame;
                                                                    // temporarily set these values to 0 since the values be stored in version 5.2 are uncaging galvo
                                                                    // voltages, not a 0-1 scale for a pixel location.  This can be removed as soon as the problem
                                                                    // in the .xml file is corrected.
                                                                    sequenceData.PointScanUncagingX = 0.0;
                                                                    sequenceData.PointScanUncagingY = 0.0;
                                                                    IJ.showMessage("The values saved in the .xml file fo the location of the uncaging galvos\nis a voltage value and does not allow the program to determine the\ncorresponding pixel location.\n\nSo the display of the uncaging galvo PointScan locations is not correct.");
                                                                }
                                                            } else {
                                                                sequenceData.PointScanGalvos = frame.getAttributes().getNamedItem("PointWith").getNodeValue();
                                                                if (sequenceData.PointScanGalvos.equals("Imaging"))
                                                                    sequenceData.PointScanGalvoType = sequenceData.PointScanGalvoImaging;
                                                                else if (sequenceData.PointScanGalvos.equals("Uncaging"))
                                                                    sequenceData.PointScanGalvoType = sequenceData.PointScanGalvoUncaging;
                                                                else if (sequenceData.PointScanGalvos.equals("Both"))
                                                                    sequenceData.PointScanGalvoType = sequenceData.PointScanGalvoImagingUncaging;
                                                                sequenceData.PointScanDwellTime = Double.parseDouble(frame.getAttributes().getNamedItem("dwellTime").getNodeValue());
                                                                sequenceData.PointScanDataFileName = directory + frame.getAttributes().getNamedItem("Data").getNodeValue();
                                                                NodeList nodes = frame.getChildNodes();
                                                                for(int k = 0; k < nodes.getLength(); k++) {
                                                                    Node node = nodes.item(k);
                                                                    if (node.getNodeName().equals("ImagingPosition")) {
                                                                        sequenceData.PointScanImagingX = Double.parseDouble(node.getAttributes().getNamedItem("X").getNodeValue());
                                                                        sequenceData.PointScanImagingY = Double.parseDouble(node.getAttributes().getNamedItem("Y").getNodeValue());
                                                                    }
                                                                    if (node.getNodeName().equals("UncagingPosition")) {
                                                                        sequenceData.PointScanUncagingX = Double.parseDouble(node.getAttributes().getNamedItem("X").getNodeValue());
                                                                        sequenceData.PointScanUncagingY = Double.parseDouble(node.getAttributes().getNamedItem("Y").getNodeValue());
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else if (frame.getNodeName().equals("PVLinescanDefinition")) {
                                                            // Read the Linescan parameters
                                                            sequenceData.LinescanTypeString = frame.getAttributes().getNamedItem("mode").getNodeValue();
                                                            if (sequenceData.LinescanTypeString.equals("straightLine"))
                                                                sequenceData.LinescanType = LinescanTypeLine;
                                                            else if (sequenceData.LinescanTypeString.equals("freeHand"))
                                                                sequenceData.LinescanType = LinescanTypeFreehand;
                                                            else if (sequenceData.LinescanTypeString.equals("spiral"))
                                                                sequenceData.LinescanType = LinescanTypeSpiral;
                                                            else if (sequenceData.LinescanTypeString.equals("lissajous"))
                                                                sequenceData.LinescanType = LinescanTypeLissajous;
                                                            else if (sequenceData.LinescanTypeString.equals("circle"))
                                                                sequenceData.LinescanType = LinescanTypeCircle;
                                                            // Read the parameters related to the specific linescan type
                                                            NodeList nodes = frame.getChildNodes();
                                                            for(int k = 0; k < nodes.getLength(); k++) {
                                                                Node node = nodes.item(k);
                                                                if (node.getNodeName().equals("Line")) {
                                                                    if (sequenceData.LinescanType == LinescanTypeLine) {
                                                                        sequenceData.LinescanPixelY = Double.parseDouble(node.getAttributes().getNamedItem("startPixelY").getNodeValue());
                                                                        sequenceData.LinescanStartPixelX = Double.parseDouble(node.getAttributes().getNamedItem("startPixelX").getNodeValue());
                                                                        sequenceData.LinescanStopPixelX = Double.parseDouble(node.getAttributes().getNamedItem("stopPixelX").getNodeValue());
                                                                    }
                                                                    sequenceData.LinescanLength = Double.parseDouble(node.getAttributes().getNamedItem("lineLength").getNodeValue());
                                                                }
                                                                if (node.getNodeName().equals("Freehand")) {
                                                                    sequenceData.LinescanFreehandPixelX.addElement(Double.parseDouble(node.getAttributes().getNamedItem("x").getNodeValue()));
                                                                    sequenceData.LinescanFreehandPixelY.addElement(Double.parseDouble(node.getAttributes().getNamedItem("y").getNodeValue()));
                                                                }
                                                                if (node.getNodeName().equals("LineScanProfiles")) {
                                                                    // Read the profile definitions that were created in Prairie View
                                                                    NodeList pvProfiles =  node.getChildNodes();
                                                                    for(int m = 0; m < pvProfiles.getLength(); m++) {
                                                                        Node pvProfile = pvProfiles.item(m);
                                                                        if (pvProfile.getNodeName().equals("Profile")) {
                                                                            sequenceData.PVProfiles = true;
                                                                            sequenceData.PVProfilesIndex.add(m);
                                                                            sequenceData.PVProfilesChannel.add(Integer.parseInt(pvProfile.getAttributes().getNamedItem("channel").getNodeValue()) - 1);
                                                                            if (pvProfile.getAttributes().getNamedItem("x0") != null) {  //*MJF+6 4/27/15 #2854
                                                                                int x0, x1;
                                                                                x0 = Integer.parseInt(pvProfile.getAttributes().getNamedItem("x0").getNodeValue());
                                                                                x1 = Integer.parseInt(pvProfile.getAttributes().getNamedItem("x1").getNodeValue());
                                                                                sequenceData.PVProfilesPosition.add(x0 + (x1 - x0) / 2 + 1);
                                                                                sequenceData.PVProfilesWidth.add(x1 - x0 + 1);
                                                                            } else {
                                                                                sequenceData.PVProfilesPosition.add(Integer.parseInt(pvProfile.getAttributes().getNamedItem("pos").getNodeValue()));
                                                                                sequenceData.PVProfilesWidth.add(Integer.parseInt(pvProfile.getAttributes().getNamedItem("width").getNodeValue()));
                                                                            }  //*MJF 4/27/15 #2854
                                                                            if (pvProfile.getAttributes().getNamedItem("color") != null) {
                                                                                sequenceData.PVProfilesColor.add(Integer.parseInt(pvProfile.getAttributes().getNamedItem("color").getNodeValue()));
                                                                            }
                                                                            else {
                                                                                sequenceData.PVProfilesColor.add(0xff0000);  // Initialize to red since the color is not defined
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else if (frame.getNodeName().equals("VoltageRecording")) {
                                                            //IJ.showMessage("voltage recording");
                                                            sequenceData.LinescanVoltageRecordingDataFile = frame.getAttributes().getNamedItem("dataFile").getNodeValue();
                                                            sequenceData.LinescanVoltageRecordingParameterFile = frame.getAttributes().getNamedItem("configurationFile").getNodeValue();
                                                            //IJ.showMessage("voltage recording data = " + sequenceData.LinescanVoltageRecordingDataFile + "   parameters = " + sequenceData.LinescanVoltageRecordingParameterFile);
                                                        }
                                                        else if (frame.getNodeName().equals("VoltageOutput")) {
                                                            //IJ.showMessage("voltage output");
                                                            sequenceData.LinescanVoltageOutputFile = frame.getAttributes().getNamedItem("filename").getNodeValue();
                                                            //IJ.showMessage("voltage outpt file = " + sequenceData.LinescanVoltageOutputFile);
                                                        }
                                                        else if (frame.getNodeName().equals("PVStateShard")) {  //*MJF++ 3/26/15 #2751
                                                            // Starting with version 5.0.32.31 an option was added to allow for a smaller
                                                            // .xml file to be generated.  When this option is selected, the complete PVStateShard is
                                                            // not saved within each individual image in the file.  Rather, it is saved at three
                                                            // different levels: data set, sequence and frame, and only recorded if it differs from
                                                            // the level above (e.g. positionCurrent_ZAxis when a Z-series is acquired)
                                            
                                                            if (dataSetFrameData != null)
                                                                sequenceFrameData = new Prairie_Frame(0, dataSetFrameData);
                                                            else 
                                                                sequenceFrameData = new Prairie_Frame(0);

                                                            sequenceFrameData.LoadPVStateShard(frame);  //*MJF 3/26/15 #2751 using shared code
                                                        }
                                                        else if (frame.getNodeName().equals("Frame")) {
								frameIndex = Integer.parseInt(frame.getAttributes().getNamedItem("index").getNodeValue());
                                                                Prairie_Frame frameData;
								if (sequenceFrameData != null) {
                                                                    // This is a "short" xml file with the global PVStateShard section
                                                                    // and only "modified" values in the PVStateShard saved with each individual image.
                                                                    frameData = new Prairie_Frame(frameIndex, sequenceFrameData);
                                                                } else if (dataSetFrameData != null) {  //*MJF+1 12/7/15
                                                                    frameData = new Prairie_Frame(frameIndex, dataSetFrameData);
                                                                } else {
                                                                    // This is the original xml file format with a complete PVStateShard
                                                                    // saved with each individual image.
                                                                    frameData = new Prairie_Frame(frameIndex);
                                                                }
                                                                frameData.AbsoluteTime = Double.toString(roundDouble(Double.parseDouble(frame.getAttributes().getNamedItem("absoluteTime").getNodeValue()), 4));
								frameData.RelativeTime = Double.toString(roundDouble(Double.parseDouble(frame.getAttributes().getNamedItem("relativeTime").getNodeValue()), 4));
                                                                int channelIndex = 0;
								NodeList nodes = frame.getChildNodes();
								for(int k = 0; k < nodes.getLength(); k++) {
									Node node = nodes.item(k);
									if (node.getNodeName().equals("File")) {
                                                                            int channel = Integer.parseInt(node.getAttributes().getNamedItem("channel").getNodeValue());
                                                                            if (channel == 1)
                                                                                frameData.Channel1Present = true;
                                                                            else if (channel == 2)
                                                                                frameData.Channel2Present = true;
                                                                            else if (channel == 3)
                                                                                frameData.Channel3Present = true;
                                                                            else if (channel == 4)
                                                                                frameData.Channel4Present = true;
                                                                            //frameData.ChannelName[channel - 1] = node.getAttributes().getNamedItem("channelName").getNodeValue();
                                                                            frameData.ChannelName[channelIndex] = node.getAttributes().getNamedItem("channelName").getNodeValue();
                                                                            frameData.ChannelNumberName[channelIndex] = "Ch" + channel;
                                                                            String filename = node.getAttributes().getNamedItem("filename").getNodeValue();
                                                                            File image = new File(directory + filename);
                                                                            //if (image.exists()) frameData.Filename[channel - 1] = filename;
                                                                            if (image.exists()) frameData.Filename[channelIndex++] = filename;
                                                                        } else if(node.getNodeName().equals("ExtraParameters")) {
                                                                            if (node.getAttributes().getNamedItem("lastGoodFrame") != null){
                                                                                frameData.LastGoodFrame = Integer.parseInt(node.getAttributes().getNamedItem("lastGoodFrame").getNodeValue());
                                                                            }
                                                                            if (node.getAttributes().getNamedItem("validData") != null){
                                                                                frameData.ValidData = Boolean.parseBoolean(node.getAttributes().getNamedItem("validData").getNodeValue());
                                                                            }
                                                                            //IJ.showMessage("lastGoodFrame = " + frameData.LastGoodFrame + "    valiData = " + frameData.ValidData);
                                                                        } else if(node.getNodeName().equals("PVStateShard")) {
                                                                            frameData.LoadPVStateShard(node);  //*MJF++ 3/26/15 #2751 using shared code
									}
                                                                 }
                                                                 if (sequenceData.isLinescan) {
                                                                    // If this is linescan data, keep track of the separate "frames"
                                                                    // within the sequence.  This means that the data for a single linescan
                                                                    // is spread across multiple files.  After the sequence has finished
                                                                    // being read, use this data to create a single "concatenated" image.
                                                                    linescanSegments.addElement(frameData);
                                                                    if (frameIndex == 1) {
                                                                        while (frameIndex > sequenceData.Frames.size())
                                                                            sequenceData.Frames.addElement(new Prairie_Frame(0));
                                                                        sequenceData.Frames.setElementAt(frameData, frameIndex - 1);
                                                                    }
                                                                 }
                                                                 else {
                                                                    while (frameIndex > sequenceData.Frames.size())
                                                                        sequenceData.Frames.addElement(new Prairie_Frame(0));
                                                                    sequenceData.Frames.setElementAt(frameData, frameIndex - 1);
                                                                 }
                                                        }
                                                        // If this is a Z-series, get the values of the Z position for the first two images
                                                        // so that the Z step size can be determined.
                                                        /*if (sequenceData.isZSeries) {  //*MJF+8 3/26/15 #2751 commented, moved out of loop
                                                            if (frameIndex == 2) {
                                                                String[] zPos1Components = zPos1Str.split(",");
                                                                String[] zPos2Components = zPos2Str.split(",");
                                                                zPos1 = Double.parseDouble(zPos1Components[zDevice]);
                                                                zPos2 = Double.parseDouble(zPos2Components[zDevice]);
                                                                sequenceData.ZSeriesStepSize = Math.abs(zPos2 - zPos1);
                                                            }
                                                        }*/		
                                                }
                                                // End of the "sequence"
                                                if (sequenceData.isZSeries && sequenceData.Frames.size()>= 2) {  //*MJF+11 3/26/15 #2751
                                                    String[] zPos1Components = sequenceData.Frames.elementAt(0).PositionCurrentZ.split(",");
                                                    String[] zPos2Components = sequenceData.Frames.elementAt(1).PositionCurrentZ.split(",");
                                                    int iZDeviceCount = Math.min(zPos1Components.length, zPos2Components.length);
                                                    double zPos1 = 0.0;
                                                    double zPos2 = 0.0;
                                                    for (int iZDevice = 0; iZDevice < iZDeviceCount; ++iZDevice) {
                                                        zPos1 += Double.parseDouble(zPos1Components[iZDevice].trim());
                                                        zPos2 += Double.parseDouble(zPos2Components[iZDevice].trim());
                                                    }
                                                    sequenceData.ZSeriesStepSize = Math.abs(zPos2 - zPos1);
                                                }
                                                if (sequenceData.isLinescan) {
                                                    // First, check if "Profiles" were brought in that had been created
                                                    // in Prairie View.  If so, then make sure that the proper index
                                                    // for the associated channel numbers is set.
                                                    if (sequenceData.PVProfiles) {
                                                        int[] channelIndex = {0, 0, 0, 0};
                                                        if (sequenceData.Frames.elementAt(0).Channel1Present)
                                                            channelIndex[0] = 0;
                                                        if (sequenceData.Frames.elementAt(0).Channel2Present) {
                                                            if (sequenceData.Frames.elementAt(0).Channel1Present)
                                                                channelIndex[1] = 1;
                                                            else
                                                                channelIndex[1] = 0;
                                                        }
                                                        if (sequenceData.Frames.elementAt(0).Channel3Present) {
                                                            if (sequenceData.Frames.elementAt(0).Channel1Present) {
                                                                if (sequenceData.Frames.elementAt(0).Channel2Present)
                                                                    channelIndex[2]  = 2;
                                                                else
                                                                    channelIndex[2] = 1;
                                                            }
                                                            else if (sequenceData.Frames.elementAt(0).Channel2Present)
                                                                channelIndex[2] = 1;
                                                            else
                                                                channelIndex[2] = 0;
                                                        }
                                                        if (sequenceData.Frames.elementAt(0).Channel4Present) {
                                                            if (sequenceData.Frames.elementAt(0).Channel1Present) {
                                                                if (sequenceData.Frames.elementAt(0).Channel2Present) {
                                                                    if (sequenceData.Frames.elementAt(0).Channel3Present)
                                                                        channelIndex[3] = 3;
                                                                    else
                                                                        channelIndex[3] = 2;
                                                                }
                                                            }
                                                            else if (sequenceData.Frames.elementAt(0).Channel2Present) {
                                                                if (sequenceData.Frames.elementAt(0).Channel3Present)
                                                                    channelIndex[3] = 2;
                                                                else
                                                                    channelIndex[3] = 1;
                                                            }
                                                            else if (sequenceData.Frames.elementAt(0).Channel3Present)
                                                                channelIndex[3] = 1;
                                                            else
                                                                channelIndex[3] = 0;
                                                        }
                                                        for (int index = 0; index < sequenceData.PVProfilesChannel.size(); index++) {
                                                            int newChannelIndex = channelIndex[sequenceData.PVProfilesChannel.elementAt(index)];
                                                            sequenceData.PVProfilesChannel.set(index, newChannelIndex);
                                                        }
                                                    }
                                                    
                                                    if (linescanSegments.size() > 1) {
                                                        // There is more than one linescan segment
                                                        // Read and concatenate the linescan segments and create a single image, for
                                                        // each channel in the "sequence".
                                                        Vector<File> segmentFiles = new Vector<File>(linescanSegments.size());
                                                        Vector<ImagePlus> segmentImagePlus = new Vector<ImagePlus>(linescanSegments.size());
                                                        int imageWidth = 0;
                                                        int imageHeight = 0;
                                                        // Generate the name of the 'source' image and create the concatenated image for each channel.
                                                        for (int channelIndex = 0; channelIndex < sequenceData.Frames.elementAt(0).ChannelCount(); channelIndex++) {
                                                            String origName = linescanSegments.elementAt(0).Filename[channelIndex];
                                                            int cycleIndex = origName.indexOf("Cycle");
                                                            int cycleIndexNextUnderscore = origName.indexOf("_", cycleIndex);
                                                            sequenceData.LinescanSourceImage[channelIndex] = origName.substring(0, cycleIndexNextUnderscore + 1);
                                                            sequenceData.LinescanSourceImage[channelIndex] = sequenceData.LinescanSourceImage[channelIndex].concat(linescanSegments.elementAt(0).ChannelNumberName[channelIndex] + "Source.tif");
                                                            sequenceData.LinescanSourceImage[channelIndex] = sequenceData.LinescanSourceImage[channelIndex].replaceFirst("_Cycle", "-Cycle");
                                                            segmentFiles.clear();
                                                            segmentImagePlus.clear();
                                                            imageWidth = 0;
                                                            imageHeight = 0;
                                                            for (int segmentCount = 0; segmentCount < linescanSegments.size(); segmentCount++) {
                                                                //IJ.showMessage("file = " + directory + linescanSegments.elementAt(segmentCount).Filename[0]);
                                                                segmentFiles.addElement(new File(directory + linescanSegments.elementAt(segmentCount).Filename[channelIndex]));
                                                                ImagePlus ip = new ImagePlus();
                                                                ip = IJ.openImage(directory + linescanSegments.elementAt(segmentCount).Filename[channelIndex]);
                                                                imageWidth = ip.getWidth();
                                                                imageHeight += ip.getHeight();
                                                                segmentImagePlus.addElement(ip);
                                                            }
                                                            ImagePlus compositeImage = IJ.createImage("compImage", "16-bit Black", imageWidth, imageHeight, 1);
                                                            int sourcePixelRow[] = new int[imageWidth];
                                                            int rowCount = 0;
                                                            for (int segmentCount = 0; segmentCount < linescanSegments.size(); segmentCount++) {
                                                                ImagePlus ip = new ImagePlus();
                                                                ip = segmentImagePlus.elementAt(segmentCount);
                                                                for (int intI = 0; intI < ip.getHeight(); intI++) {
                                                                    ip.getProcessor().getRow(0, intI, sourcePixelRow, imageWidth);
                                                                    compositeImage.getProcessor().putRow(0, intI + rowCount, sourcePixelRow, imageWidth);
                                                                }
                                                                rowCount += ip.getHeight();
                                                            }
                                                            String currentName = linescanSegments.elementAt(0).Filename[channelIndex];
                                                            String currentNameNoExtension = currentName.substring(0, currentName.length()-4);
                                                            String fileNameNoDirectory = currentNameNoExtension + "-" + String.format("%06d", linescanSegments.size()) + ".tif";
                                                            String fileName = directory + fileNameNoDirectory;
                                                            IJ.save(compositeImage, fileName);
                                                            linescanSegments.elementAt(0).LinesPerFrame = rowCount;
                                                            linescanSegments.elementAt(0).Filename[channelIndex] = fileNameNoDirectory;
                                                            sequenceData.Frames.setElementAt(linescanSegments.elementAt(0), 0);
                                                            origName = sequenceData.LinescanSourceImage[channelIndex];
                                                            int index = origName.indexOf("-Cycle") + 12;
                                                            sequenceData.LinescanTriggerSyncDataFile = origName.substring(0, index) + "Data_Line000001.dat";
                                                            sequenceData.LinescanTriggerSyncDataFile = sequenceData.LinescanTriggerSyncDataFile.replaceFirst("-Cycle", "_Cycle");
                                                            sequenceData.LinescanTriggerSyncSettingsFile = sequenceData.LinescanTriggerSyncDataFile.replaceFirst(".dat", ".prm");
                                                        }
                                                    }
                                                    else {
                                                        for (int channelIndex = 0; channelIndex < sequenceData.Frames.elementAt(0).ChannelCount(); channelIndex++) {
                                                            // Generate the name of the 'source' image
                                                            String origName = sequenceData.Frames.elementAt(0).Filename[channelIndex];
                                                            int cycleIndex = origName.indexOf("Cycle");
                                                            int cycleIndexNextUnderscore = origName.indexOf("_", cycleIndex);
                                                            sequenceData.LinescanSourceImage[channelIndex] = origName.substring(0, cycleIndexNextUnderscore + 1);
                                                            sequenceData.LinescanSourceImage[channelIndex] = sequenceData.LinescanSourceImage[channelIndex].concat(sequenceData.Frames.elementAt(0).ChannelNumberName[channelIndex] + "Source.tif");
                                                            sequenceData.LinescanSourceImage[channelIndex] = sequenceData.LinescanSourceImage[channelIndex].replaceFirst("_Cycle", "-Cycle");
                                                            origName = sequenceData.LinescanSourceImage[channelIndex];
                                                            int index = origName.indexOf("-Cycle") + 12;
                                                            sequenceData.LinescanTriggerSyncDataFile = origName.substring(0, index) + "Data_Line000001.dat";
                                                            sequenceData.LinescanTriggerSyncDataFile = sequenceData.LinescanTriggerSyncDataFile.replaceFirst("-Cycle", "_Cycle");
                                                            sequenceData.LinescanTriggerSyncSettingsFile = sequenceData.LinescanTriggerSyncDataFile.replaceFirst(".dat", ".prm");
                                                        }
                                                    }
                                                }
                                                if (sequenceData.isMosaic)
                                                    sequenceData.MosaicNumZImages = sequenceData.Frames.size();
                                                data.Sequences.addElement(sequenceData);
					}
                                }
                                if (data.isBiDirectionalZSeries) {
                                    /* This is bi-directional data, so every other sequence needs to be 'reversed'
                                       to improve the display of data when the operator wishes to look at the same 'slice'
                                       across all of the Z-series. */
                                    for (int i = 0; i < data.Sequences.size(); i++) {
                                        /* Need to reverse the frame order for every other 'sequence' */
                                        if ((i % 2) != 0){
                                            /* Determine the number of frames in a sequence */
                                            int frameCount = data.Sequences.elementAt(0).Frames.size();
                                            
                                            /* Get the list of frames that make up the current sequence */
                                            Prairie_Sequence tempSequence = new Prairie_Sequence(0);
                                            tempSequence = data.Sequences.elementAt(i);
                                            
                                            /* Create some temporary storage for frame data */
                                            Prairie_Frame tempFrame1 = new Prairie_Frame(0);
                                            Prairie_Frame tempFrame2 = new Prairie_Frame(1);
                                            
                                            /* Determine the number of elements that need to be swapped */
                                            int numSwaps = tempSequence.Frames.size() / 2;
                                            int numElements = tempSequence.Frames.size();
                                            
                                            for (int j = 0; j < numSwaps; j++) {
                                                tempFrame1 = tempSequence.Frames.elementAt(j);
                                                /* the 'Index' parameter must be changed as well */
                                                tempFrame1.Index = numElements - j;
                                                tempFrame2 = tempSequence.Frames.elementAt(numElements - 1 - j);
                                                /* the 'Index' parameter must be changed as well */
                                                tempFrame2.Index = j + 1;
                                                tempSequence.Frames.setElementAt(tempFrame2, j);
                                                tempSequence.Frames.setElementAt(tempFrame1, numElements - 1 - j);
                                            }
                                            
                                            /* Replace this sequence in the original data set */
                                            data.Sequences.setElementAt(tempSequence, i);
                                        }
                                    }
                                }
                                // If this is a "mosaic" data set, then perform the necessary
                                // processing to generate the mosaic image(s).
                                if (data.Sequences.elementAt(0).isMosaic) {
                                    // This is the code when this option was implemented via the
                                    // menu bar.  The menu bar was eliminated in version 3.9
//                                    if (optionsMenuItemImageStitchingProcessOverlapCopy.getState())
//                                        ProcessMosaic(MosaicOverlap.CopyPixels);
//                                    else if (optionsMenuItemImageStitchingProcessOverlapBrightest.getState())
//                                        ProcessMosaic(MosaicOverlap.BrightestPixel);
//                                    else if (optionsMenuItemImageStitchingProcessOverlapAverage.getState())
//                                        ProcessMosaic(MosaicOverlap.AveragePixel);
//                                    else
//                                        ProcessMosaic(MosaicOverlap.CopyPixels);
                                    // This is the new code (version 3.9)
                                    if (ImageStitchingOverlapOption == 0)
                                        ProcessMosaic(MosaicOverlap.CopyPixels);
                                    else if (ImageStitchingOverlapOption == 1)
                                        ProcessMosaic(MosaicOverlap.BrightestPixel);
                                    else if (ImageStitchingOverlapOption == 2)
                                        ProcessMosaic(MosaicOverlap.AveragePixel);
                                    else
                                        ProcessMosaic(MosaicOverlap.CopyPixels);
                                }
                                sequenceSelection.select(0);
				currentSequence = data.Sequences.elementAt(0);
				LoadSequence();
                                IJ.showStatus("Loaded: " + directory + name);
				return;
			}
		} catch (Throwable t) {
			try {
				FileOutputStream logFile = new FileOutputStream("Prairie_Reader.log", true);
				PrintStream logStream = new PrintStream(logFile);
				t.printStackTrace(logStream);
				logStream.flush();
				logStream.close();
				logFile.flush();
				logFile.close();
                                IJ.showMessage("Prairie Reader", "Error Parsing: " + directory + name + "\n" + "Error: " + "\n" + t.toString());
			} catch (IOException exception) {}
		}
		IJ.showStatus("Error Parsing: " + directory + name);
	}

	public static Double roundDouble(Double d, int places) {
		return Math.round(d * Math.pow(10, places)) / Math.pow(10, places);
	}

	class Prairie_DataSet {
            String Directory;
            String Version;
            int versionFirstValue;
            int versionSecondValue;
            int versionThirdValue;
            int versionFourthValue;
            String AcquireDateTime;
            String Notes;
            String[] LaserNames = {"", "", "", "", "", "", "", "", "", "", "", ""};
            Boolean isBiDirectionalZSeries = false;
            Boolean isBiDirectionalZSeriesFlag = false;
            Vector<Prairie_Sequence> Sequences;

            public Prairie_DataSet() {
                Sequences = new Vector<Prairie_Sequence>();
            }

            public Boolean isMatrix() {
                //int currentSequenceNum = sequenceSelection.getSelectedIndex();
                int currentSequenceNum = 0;
                if (Sequences.size() < 2) return false;
                if (Sequences.elementAt(currentSequenceNum).isMosaic) return false;
                if (!Sequences.elementAt(currentSequenceNum).isZSeries) return false;
                int frameCount = Sequences.elementAt(currentSequenceNum).Frames.size();
                int channelCount = Sequences.elementAt(currentSequenceNum).ChannelCount();
                for (int index = 1; index < Sequences.size(); index++) {
                        if (!Sequences.elementAt(index).isZSeries) return false;
                        if (Sequences.elementAt(index).Frames.size() != frameCount) return false;
                        if (Sequences.elementAt(index).ChannelCount() != channelCount) return false;
                }
                return true;
            }
            
            public Boolean isPreVersion4dot3dot2dot12() {
                if (versionFirstValue < 4) {
                    //IJ.showMessage("version check 1 true");
                    return true;
                }
                if ((versionFirstValue == 4) && (versionSecondValue < 3)) {
                    //IJ.showMessage("version check 2 true");
                    return true;
                }
                if ((versionFirstValue == 4) && (versionSecondValue == 3) & (versionThirdValue < 2)) {
                    //IJ.showMessage("version check 3 true");
                    return true;
                }
                if ((versionFirstValue == 4) && (versionSecondValue == 3) & (versionThirdValue == 2) && (versionFourthValue < 12)) {
                    //IJ.showMessage("version check 4 true");
                    return true;
                }
                //IJ.showMessage("version check false");
                return false;
            }
            
            public Boolean isVersion5dot0orGreater() {
                if (versionFirstValue >= 5) {
                    //IJ.showMessage("version is 5.0 or greater");
                    return true;
                }
                //IJ.showMessage("version is less than 5.0");
                return false;
            }
            
            public Boolean isVersion5dot2orGreater() {
                if (versionFirstValue >= 5) {
                    IJ.showMessage("version is 5.2 or greater");
                    return true;
                }
                if ((versionFirstValue >=5) && (versionSecondValue >=2)) {
                    IJ.showMessage("version check 5.2 true");
                    return true;
                }
                //IJ.showMessage("version is less than 5.0");
                return false;
            }
        
        }

	class Prairie_Sequence {
            String Directory;
            String Filename;
            ImageWindow Window;
            ImageWindow SingleChannelWindow1;
            ImageWindow SingleChannelWindow2;
            ImageWindow SingleChannelWindow3;
            ImageWindow SingleChannelWindow4;
            int Index;
            Boolean isZSeries = false;
            Vector<Prairie_Frame> Frames;
            Double ZSeriesStepSize = 1.0;
            Boolean isLinescan = false;
            Boolean isPointscan = false;
            String PointScanGalvos = null;
            int PointScanGalvoType = 0; // 0 = imaging, 1 = uncaging, 2 = imaging & uncaging
            int PointScanGalvoImaging = 0;
            int PointScanGalvoUncaging = 1;
            int PointScanGalvoImagingUncaging = 2;
            Double PointScanDwellTime = 1.0;
            Double PointScanImagingX = 0.0;
            Double PointScanImagingY = 0.0;
            Double PointScanUncagingX = 0.0;
            Double PointScanUncagingY = 0.0;
            String PointScanDataFileName = null;
            Plot PointScanPlotWindow = null;
            String LinescanTypeString = null;
            int LinescanType = 0; // 0 = line, 1 = freehand, 2 = spiral, 3 = lissajous
            Double LinescanStartPixelX = 0.0;
            Double LinescanStopPixelX = 1.0;
            Double LinescanPixelY = 1.0;
            Double LinescanLength = 1.0;
            Vector<Double> LinescanFreehandPixelX = new Vector<Double>();
            Vector<Double> LinescanFreehandPixelY = new Vector<Double>();
            ImageWindow LinescanSingleChannelWindow1 = null;
            ImageWindow LinescanSingleChannelWindow2 = null;
            ImageWindow LinescanSingleChannelWindow3 = null;
            ImageWindow LinescanSingleChannelWindow4 = null;
            ImageWindow LinescanCompositeWindow;
            String LinescanSourceImage[] = {null, null, null, null};
            String LinescanTriggerSyncSettingsFile = null;
            String LinescanTriggerSyncDataFile = null;
            String LinescanVoltageRecordingParameterFile = null;
            String LinescanVoltageRecordingDataFile = null;
            String LinescanVoltageOutputFile = null;
            LinescanAnalysis LinescanAnalysisDialog = null; 
            Boolean PVProfiles = false;
            Vector<Integer> PVProfilesIndex = new Vector<Integer>();
            Vector<Integer> PVProfilesChannel = new Vector<Integer>();
            Vector<Integer> PVProfilesPosition = new Vector<Integer>();
            Vector<Integer> PVProfilesWidth = new Vector<Integer>();
            Vector<Integer> PVProfilesColor = new Vector<Integer>();
            Boolean isMosaic = false;
            int MosaicNumXImages = 1;
            int MosaicNumYImages = 1;
            int MosaicNumZImages = 1;
            double MosaicOverlapPercentage = 10;
            double MosaicOverlapXInMicrons = 10.0;
            double MosaicOverlapYInMicrons = 10.0;
            Boolean mosaicRendered = false;
            
               
            public Prairie_Sequence(int index) {
                Index = index;
                Frames= new Vector<Prairie_Frame>();
            }

            public String AbsoluteTime() {
                if (Frames.size() == 0) return "Unknown";
                return Frames.elementAt(0).AbsoluteTime();
            }

            public int ChannelCount() {
                if (Frames.size() == 0) return 0;
                return Frames.elementAt(0).ChannelCount();
            }
            
	}

        static int ModeGalvo = 1;
        static int ModeAOD = 2;
        static int ModeSFC = 4;
        static int ModeCamera = 8;
        static int ModeResonantGalvo = 16;
        static int ModeFLIM = 32;
        static int ModeSpiral = 64;
        
	class Prairie_Frame {
            // IMPORTANT - If adding new parameters to this list, then they probably need to be
            // added to the "Copy Constructor" method below
            int Index;
            String[] Filename = {null, null, null, null};
            String[] ChannelName = {null, null, null, null};
            String[] ChannelNumberName = {null, null, null, null};
            boolean Channel1Present = false;
            boolean Channel2Present = false;
            boolean Channel3Present = false;
            boolean Channel4Present = false;
            String AbsoluteTime;
            String RelativeTime;
            int SystemType;
            boolean SystemTypeFound;
            int ActiveMode = ModeGalvo;
            int RastersPerFrame = 1;
            int PixelsPerLine;
            int LinesPerFrame;
            Double DwellTime;
            String ObjectiveLens;
            String ObjectiveLensNA;
            String ObjectiveLensMag;
            int BinningMode;
            String FrameAveraging;
            String FramePeriod;
            Double ScanlinePeriod; //TJK 2/15/2012 Changed from String to Double
            Double OpticalZoom;
            Double MicronsPerPixelX;
            Double MicronsPerPixelY;
            String Rotation;
            String[] PMTGain = {null, null, null, null, null, null, null, null};
            String PositionCurrentX;
            String PositionCurrentY;
            String PositionCurrentZ;
            String[] LaserPower = {null, null, null, null, null, null, null, null, null, null, null, null}; //TJK 2/14/2012 Expanded to 12 entries
            String[] PreAmpGain = {null, null, null, null, null, null, null, null}; //TJK 2/13/2012 Added four entries for eight total
            String[] PreAmpOffset = {null, null, null, null, null, null, null, null}; //TJK 2/13/2012 Added four entries for eight total
            String[] PreAmpFilter = {null, null, null, null, null, null, null, null}; //TJK 2/13/2012 Added four entries for eight total
            int[] LaserWavelength = {0, 0, 0, 0};
            String[] TwoPhotonLaserPower = {null, null, null, null};
            int BitDepth = 12;
            //int ZDevice = 0;  //*MJF 3/26/15 #2751 commented
            String SFCExposureTime = null;
            String SFCExposureMode = null;
            String SFCEmissionFilter = null;
            String SFCAperture = null;
            String SFCGain = null;
            String SFCGainMultFactor = null;
            int SFCBinFactor = 1;
            String SFCChannel1Lasers = null;
            String SFCChannel2Lasers = null;
            String SFCChannel3Lasers = null;
            String SFCChannel4Lasers = null;
            int CameraBinFactor = 1;
            String CameraExposureTime = null;
            String CameraExposureMode = null;
            String CameraGain = null;
            String CameraGainMultFactor = null;
            String ConfocalChannel123DichroicLabel = null; //*TJK 2/13/2012 Added Confocal strings
            String ConfocalChannel23DichroicLabel = null;
            String ConfocalChannel1FilterLabel = null;
            String ConfocalChannel2FilterLabel = null;
            String ConfocalChannel3FilterLabel = null;
            String ConfocalPinholeLabel = null;
            int MosaicGridIndex = 1;
            int MosaicGridXIndex = 1;
            int MosaicGridYIndex = 1;
            int MosaicGridZIndex = 0;
            int LastGoodFrame = 0;
            Boolean ValidData = true;
            
            public Prairie_Frame(int index) {
                Index = index;
            }

            // This is the "Copy Constructor"
            public Prairie_Frame(int index, Prairie_Frame masterCopy) {
                Index = index;
                this.Filename[0] = masterCopy.Filename[0];
                this.Filename[1] = masterCopy.Filename[1];
                this.Filename[2] = masterCopy.Filename[2];
                this.Filename[3] = masterCopy.Filename[3];
                this.ChannelName[0] = masterCopy.ChannelName[0];
                this.ChannelName[1] = masterCopy.ChannelName[1];
                this.ChannelName[2] = masterCopy.ChannelName[2];
                this.ChannelName[3] = masterCopy.ChannelName[3];
                this.ChannelNumberName[0] = masterCopy.ChannelNumberName[0];
                this.ChannelNumberName[1] = masterCopy.ChannelNumberName[1];
                this.ChannelNumberName[2] = masterCopy.ChannelNumberName[2];
                this.ChannelNumberName[3] = masterCopy.ChannelNumberName[3];
                this.Channel1Present = masterCopy.Channel1Present;
                this.Channel2Present = masterCopy.Channel2Present;
                this.Channel3Present = masterCopy.Channel3Present;
                this.Channel4Present = masterCopy.Channel4Present;
                this.AbsoluteTime = masterCopy.AbsoluteTime;
                this.RelativeTime = masterCopy.RelativeTime;
                this.SystemType = masterCopy.SystemType;
                this.SystemTypeFound = masterCopy.SystemTypeFound;
                this.ActiveMode = masterCopy.ActiveMode;
                this.RastersPerFrame = masterCopy.RastersPerFrame;
                this.PixelsPerLine = masterCopy.PixelsPerLine;
                this.LinesPerFrame = masterCopy.LinesPerFrame;
                this.DwellTime = masterCopy.DwellTime;
                this.ObjectiveLens = masterCopy.ObjectiveLens;
                this.ObjectiveLensMag = masterCopy.ObjectiveLensMag;
                this.ObjectiveLensNA = masterCopy.ObjectiveLensNA;
                this.BinningMode = masterCopy.BinningMode;
                this.FrameAveraging = masterCopy.FrameAveraging;
                this.FramePeriod = masterCopy.FramePeriod;
                this.ScanlinePeriod = masterCopy.ScanlinePeriod;
                this.OpticalZoom = masterCopy.OpticalZoom;
                this.MicronsPerPixelX = masterCopy.MicronsPerPixelX;
                this.MicronsPerPixelY = masterCopy.MicronsPerPixelY;
                this.Rotation = masterCopy.Rotation;
                for (int i = 0; i < 8; i++)
                    this.PMTGain[i] = masterCopy.PMTGain[i];
                this.PositionCurrentX = masterCopy.PositionCurrentX;
                this.PositionCurrentY = masterCopy.PositionCurrentY;
                this.PositionCurrentZ = masterCopy.PositionCurrentZ;
                for (int i = 0; i < 12; i++)
                    this.LaserPower[i] = masterCopy.LaserPower[i];
                for (int i = 0; i < 8; i++) {
                    this.PreAmpGain[i] = masterCopy.PreAmpGain[i];
                    this.PreAmpOffset[i] = masterCopy.PreAmpOffset[i];
                    this.PreAmpFilter[i] = masterCopy.PreAmpFilter[i];
                }
                for (int i = 0; i < 4; i++) {
                    this.LaserWavelength[i] = masterCopy.LaserWavelength[i];
                    this.TwoPhotonLaserPower[i] = masterCopy.TwoPhotonLaserPower[i];
                }
                this.BitDepth = masterCopy.BitDepth;
                //this.ZDevice = masterCopy.ZDevice;  //*MJF 3/26/15 #2751 commented
                this.SFCExposureTime = masterCopy.SFCExposureTime;
                this.SFCExposureMode = masterCopy.SFCExposureMode;
                this.SFCEmissionFilter = masterCopy.SFCEmissionFilter;
                this.SFCAperture = masterCopy.SFCAperture;
                this.SFCGain = masterCopy.SFCGain;
                this.SFCGainMultFactor = masterCopy.SFCGainMultFactor;
                this.SFCBinFactor = masterCopy.SFCBinFactor;
                this.SFCChannel1Lasers = masterCopy.SFCChannel1Lasers;
                this.SFCChannel2Lasers = masterCopy.SFCChannel2Lasers;
                this.SFCChannel3Lasers = masterCopy.SFCChannel3Lasers;
                this.SFCChannel4Lasers = masterCopy.SFCChannel4Lasers;
                this.CameraBinFactor = masterCopy.CameraBinFactor;
                this.CameraExposureTime = masterCopy.CameraExposureTime;
                this.CameraExposureMode= masterCopy.CameraExposureMode;
                this.CameraGain = masterCopy.CameraGain;
                this.CameraGainMultFactor = masterCopy.CameraGainMultFactor;
                this.ConfocalChannel123DichroicLabel = masterCopy.ConfocalChannel123DichroicLabel;
                this.ConfocalChannel23DichroicLabel = masterCopy.ConfocalChannel23DichroicLabel;
                this.ConfocalChannel1FilterLabel = masterCopy.ConfocalChannel1FilterLabel;
                this.ConfocalChannel2FilterLabel = masterCopy.ConfocalChannel2FilterLabel;
                this.ConfocalChannel3FilterLabel = masterCopy.ConfocalChannel3FilterLabel;
                this.ConfocalPinholeLabel = masterCopy.ConfocalPinholeLabel;
                this.MosaicGridIndex = masterCopy.MosaicGridIndex;
                this.MosaicGridXIndex = masterCopy.MosaicGridXIndex;
                this.MosaicGridYIndex = masterCopy.MosaicGridYIndex;
                this.MosaicGridZIndex = masterCopy.MosaicGridZIndex;
                this.LastGoodFrame = masterCopy.LastGoodFrame;
                this.ValidData = masterCopy.ValidData;
            }
            
            public void LoadPVStateShard(Node shard) {  //*MJF++ 3/26/15 #2751
                NodeList oKeys = shard.getChildNodes();
                for(int i = 0; i < oKeys.getLength(); ++i) {
                    Node oKey = oKeys.item(i);
                    // Pre-version 5.2 of Prairie View, the values were indicated with the
                    // word "Key", starting with version 5.2, the values are indicated with
                    // the word "PVStateValue".
                    if ((oKey.getNodeName().equals("Key")) || (oKey.getNodeName().equals("PVStateValue"))) {
                        String sKey = "";
                        String sValue = "";
                        sKey = oKey.getAttributes().getNamedItem("key").getNodeValue();
                        if (oKey.getAttributes().getNamedItem("value") != null)
                            sValue = oKey.getAttributes().getNamedItem("value").getNodeValue();
                        if (sKey.equals("systemType")) {
                                SystemTypeFound = true;
                                SystemType = Integer.parseInt(sValue);
                        } else if (sKey.equals("activeMode")) {
                            if ((data.versionFirstValue >= 5) && (data.versionSecondValue >= 2)) {
                                if (sValue.equals("Galvo"))
                                    ActiveMode = ModeGalvo;
                                else if (sValue.equals("AOD"))
                                    ActiveMode = ModeAOD;
                                else if (sValue.equals("SFC"))
                                    ActiveMode = ModeSFC;
                                else if (sValue.equals("Camera"))
                                    ActiveMode = ModeCamera;
                                else if (sValue.equals("ResonantGalvo"))
                                    ActiveMode = ModeResonantGalvo;
                                else if (sValue.equals("FLIM"))
                                    ActiveMode = ModeFLIM;
                                else if (sValue.equals("Spiral"))
                                    ActiveMode = ModeSpiral;
                            }
                            else
                                ActiveMode = Integer.parseInt(sValue);
                        } else if (sKey.equals("rastersPerFrame")) {
                                RastersPerFrame = Integer.parseInt(sValue);
                        } else if (sKey.equals("pixelsPerLine")) {
                                PixelsPerLine = Integer.parseInt(sValue);
                        } else if (sKey.equals("linesPerFrame")) {
                                LinesPerFrame = Integer.parseInt(sValue);
                        } else if (sKey.equals("dwellTime")) {
                                DwellTime= Double.parseDouble(sValue);
                        } else if (sKey.equals("objectiveLens")) {
                                ObjectiveLens = sValue;
                        } else if (sKey.equals("objectiveLensNA")) {
                                ObjectiveLensNA= sValue;
                        } else if (sKey.equals("objectiveLensMag")) {
                                ObjectiveLensMag = sValue + " x";
                        } else if (sKey.equals("binningMode")) {
                            if ((data.versionFirstValue >= 5) && (data.versionSecondValue >= 2)) {
                                if (sValue.equals("Averaging"))
                                    BinningMode = 0;
                                else
                                    BinningMode = 1;
                            }
                            else
                                BinningMode = Integer.parseInt(sValue);
                        } else if (sKey.equals("frameAveraging")) {
                                FrameAveraging = sValue;
                        } else if (sKey.equals("framePeriod")) {
                                FramePeriod = Double.toString(roundDouble(Double.parseDouble(sValue) * 1000,3)) + " ms";
                        } else if ((sKey.equals("scanlinePeriod")) || (sKey.equals("scanLinePeriod"))){
                                ScanlinePeriod = Double.parseDouble(sValue) * 1000.0;
                        } else if (sKey.equals("opticalZoom")) {
                                OpticalZoom = Double.parseDouble(sValue);
                        } else if (sKey.equals("micronsPerPixel_XAxis")) {
                                MicronsPerPixelX = Double.parseDouble(sValue);
                        } else if (sKey.equals("micronsPerPixel_YAxis")) {
                                MicronsPerPixelY = Double.parseDouble(sValue);
                        } else if (sKey.equals("micronsPerPixel")) {
                            NodeList oIndices = oKey.getChildNodes();
                            for(int j = 0; j < oIndices.getLength(); ++j) {
                                Node oIndex = oIndices.item(j);
                                if (oIndex.getNodeName().equals("IndexedValue")) {
                                    String sKey2 = oIndex.getAttributes().getNamedItem("index").getNodeValue();
                                    String sValue2 = oIndex.getAttributes().getNamedItem("value").getNodeValue();
                                    if (sKey2.equals("XAxis"))
                                        MicronsPerPixelX = Double.parseDouble(sValue2);
                                    else if (sKey2.equals("YAxis"))
                                        MicronsPerPixelY = Double.parseDouble(sValue2);
                                }
                            }
                        } else if (sKey.equals("rotation")) {
                                Rotation = sValue + "°";
                        } else if (sKey.startsWith("pmtGain_")) {
                                int index = Integer.parseInt(sKey.substring(sKey.lastIndexOf("_") + 1));
                                PMTGain[index] = sValue;
                        } else if (sKey.equals("pmtGain")) {
                            NodeList oIndices = oKey.getChildNodes();
                            for(int j = 0; j < oIndices.getLength(); ++j) {
                                Node oIndex = oIndices.item(j);
                                if (oIndex.getNodeName().equals("IndexedValue")) {
                                    String sKey2 = oIndex.getAttributes().getNamedItem("index").getNodeValue();
                                    String sValue2 = oIndex.getAttributes().getNamedItem("value").getNodeValue();
                                    PMTGain[Integer.parseInt(sKey2)] = sValue2;
                                }
                            }
                        } else if (sKey.equals("positionCurrent_XAxis")) {
                                PositionCurrentX = sValue;
                        } else if (sKey.equals("positionCurrent_YAxis")) {
                                PositionCurrentY = sValue;
                        } else if (sKey.equals("positionCurrent_ZAxis")) {
                                PositionCurrentZ = sValue;
                        } else if (sKey.equals("positionCurrent")) {
                            NodeList oIndices = oKey.getChildNodes();
                            for (int j = 0; j < oIndices.getLength(); ++j){
                                Node oIndex = oIndices.item(j);
                                if (oIndex.getNodeName().equals("SubindexedValues")) {
                                    String sAxis = oIndex.getAttributes().getNamedItem("index").getNodeValue();
                                    if (sAxis.equals("XAxis")) {
                                        NodeList oSubindices =  oIndex.getChildNodes();
                                        for(int k = 0; k < oSubindices.getLength(); ++k) {
                                            Node oSubindex = oSubindices.item(k);
                                            if (oSubindex.getNodeName().equals("SubindexedValue")) {
                                                String sKey2 = oSubindex.getAttributes().getNamedItem("subindex").getNodeValue();
                                                String sValue2 = oSubindex.getAttributes().getNamedItem("value").getNodeValue();
                                                PositionCurrentX = sValue2;
                                            }
                                        }
                                    }
                                    else if (sAxis.equals("YAxis")) {
                                        NodeList oSubindices =  oIndex.getChildNodes();
                                        for(int k = 0; k < oSubindices.getLength(); ++k) {
                                            Node oSubindex = oSubindices.item(k);
                                            if (oSubindex.getNodeName().equals("SubindexedValue")) {
                                                String sKey2 = oSubindex.getAttributes().getNamedItem("subindex").getNodeValue();
                                                String sValue2 = oSubindex.getAttributes().getNamedItem("value").getNodeValue();
                                                PositionCurrentY = sValue2;
                                            }
                                        }
                                    }
                                    else if (sAxis.equals("ZAxis")) {
                                        NodeList oSubindices =  oIndex.getChildNodes();
                                        for(int k = 0; k < oSubindices.getLength(); ++k) {
                                            Node oSubindex = oSubindices.item(k);
                                            if (oSubindex.getNodeName().equals("SubindexedValue")) {
                                                String sKey2 = oSubindex.getAttributes().getNamedItem("subindex").getNodeValue();
                                                String sValue2 = oSubindex.getAttributes().getNamedItem("value").getNodeValue();
                                                if (Integer.parseInt(sKey2) == 0)
                                                    PositionCurrentZ = sValue2;
                                                else
                                                    PositionCurrentZ += ", " + sValue2;
                                            }
                                        }
                                    }
                                }
                            }
                        } else if (sKey.startsWith("laserPower_")) {
                                int index = Integer.parseInt(sKey.substring(sKey.lastIndexOf("_") + 1));
                                LaserPower[index] = sValue;
                        } else if (sKey.equals("laserPower")) {
                            NodeList oIndices = oKey.getChildNodes();
                            for(int j = 0; j < oIndices.getLength(); ++j) {
                                Node oIndex = oIndices.item(j);
                                if (oIndex.getNodeName().equals("IndexedValue")) {
                                    String sKey2 = oIndex.getAttributes().getNamedItem("index").getNodeValue();
                                    String sValue2 = oIndex.getAttributes().getNamedItem("value").getNodeValue();
                                    String sDescription = oIndex.getAttributes().getNamedItem("description").getNodeValue();
                                    LaserPower[Integer.parseInt(sKey2)] = sValue2;
                                    data.LaserNames[Integer.parseInt(sKey2)] = sDescription;
                                }
                            }
                        } else if (sKey.startsWith("preAmpGain_")) {
                            int index = Integer.parseInt(sKey.substring(sKey.lastIndexOf("_") + 1));
                            PreAmpGain[index] = Double.toString(roundDouble(Double.parseDouble(sValue), 2));
                        } else if (sKey.startsWith("preAmpOffset_")) {
                            int index = Integer.parseInt(sKey.substring(sKey.lastIndexOf("_") + 1));
                            PreAmpOffset[index] = Double.toString(roundDouble(Double.parseDouble(sValue), 2));
                        } else if (sKey.startsWith("preAmpFilterBlock_")) {
                                int index = Integer.parseInt(sKey.substring(sKey.lastIndexOf("_") + 1));
                                PreAmpFilter[index] = sValue;
                        } else if (sKey.startsWith("preampGain_")) { // Starting with 5.0.32.31 the syntax was changed (preAmp -> preamp) and an additional value was added to indicate which of two possible preamps
                                int preampNum = Integer.parseInt(sKey.substring(sKey.indexOf("_") + 1, sKey.lastIndexOf("_")));
                                int index = Integer.parseInt(sKey.substring(sKey.lastIndexOf("_") + 1));
                                PreAmpGain[(preampNum * 4) + index] = Double.toString(roundDouble(Double.parseDouble(sValue), 2));
                        } else if (sKey.equals("preampGain")) {
                            NodeList oIndices = oKey.getChildNodes();
                            for (int j = 0; j < oIndices.getLength(); ++j){
                                Node oIndex = oIndices.item(j);
                                if (oIndex.getNodeName().equals("SubindexedValues")) {
                                    String sPreampKey = oIndex.getAttributes().getNamedItem("index").getNodeValue();
                                    if (sPreampKey.equals("0")) {
                                        NodeList oSubindices =  oIndex.getChildNodes();
                                        for(int k = 0; k < oSubindices.getLength(); ++k) {
                                            Node oSubindex = oSubindices.item(k);
                                            if (oSubindex.getNodeName().equals("SubindexedValue")) {
                                                String sKey2 = oSubindex.getAttributes().getNamedItem("subindex").getNodeValue();
                                                String sValue2 = oSubindex.getAttributes().getNamedItem("value").getNodeValue();
                                                PreAmpGain[Integer.parseInt(sKey2)] = sValue2;
                                            }
                                        }
                                    }
                                    else if (sPreampKey.equals("1")) {
                                        NodeList oSubindices =  oIndex.getChildNodes();
                                        for(int k = 0; k < oSubindices.getLength(); ++k) {
                                            Node oSubindex = oSubindices.item(k);
                                            if (oSubindex.getNodeName().equals("SubindexedValue")) {
                                                String sKey2 = oSubindex.getAttributes().getNamedItem("subindex").getNodeValue();
                                                String sValue2 = oSubindex.getAttributes().getNamedItem("value").getNodeValue();
                                                PreAmpGain[4 + Integer.parseInt(sKey2)] = sValue2;
                                            }
                                        }
                                    }
                                }
                            } 
                        } else if (sKey.startsWith("preampOffset_")) {
                                int preampNum = Integer.parseInt(sKey.substring(sKey.indexOf("_") + 1, sKey.lastIndexOf("_")));
                                int index = Integer.parseInt(sKey.substring(sKey.lastIndexOf("_") + 1));
                                PreAmpOffset[(preampNum * 4) + index] = Double.toString(roundDouble(Double.parseDouble(sValue), 2));
                        } else if (sKey.equals("preampOffset")) {
                            NodeList oIndices = oKey.getChildNodes();
                            for (int j = 0; j < oIndices.getLength(); ++j){
                                Node oIndex = oIndices.item(j);
                               if (oIndex.getNodeName().equals("SubindexedValues")) {
                                    String sPreampKey = oIndex.getAttributes().getNamedItem("index").getNodeValue();
                                    if (sPreampKey.equals("0")) {
                                        NodeList oSubindices =  oIndex.getChildNodes();
                                        for(int k = 0; k < oSubindices.getLength(); ++k) {
                                            Node oSubindex = oSubindices.item(k);
                                            if (oSubindex.getNodeName().equals("SubindexedValue")) {
                                                String sKey2 = oSubindex.getAttributes().getNamedItem("subindex").getNodeValue();
                                                String sValue2 = oSubindex.getAttributes().getNamedItem("value").getNodeValue();
                                                PreAmpOffset[Integer.parseInt(sKey2)] = sValue2;
                                            }
                                        }
                                    }
                                    else if (sPreampKey.equals("1")) {
                                        NodeList oSubindices =  oIndex.getChildNodes();
                                        for(int k = 0; k < oSubindices.getLength(); ++k) {
                                            Node oSubindex = oSubindices.item(k);
                                            if (oSubindex.getNodeName().equals("SubindexedValue")) {
                                                String sKey2 = oSubindex.getAttributes().getNamedItem("subindex").getNodeValue();
                                                String sValue2 = oSubindex.getAttributes().getNamedItem("value").getNodeValue();
                                                PreAmpOffset[4 + Integer.parseInt(sKey2)] = sValue2;
                                            }
                                        }
                                    }
                                }
                            } 
                        } else if (sKey.startsWith("preampFilter")) {
                                String sDescription = oKey.getAttributes().getNamedItem("description").getNodeValue();
                                PreAmpFilter[0] = "Filter: " + sValue + " (" + sDescription + ")";
                                PreAmpFilter[1] = "Filter: " + sValue + " (" + sDescription + ")";
                                PreAmpFilter[2] = "Filter: " + sValue + " (" + sDescription + ")";
                                PreAmpFilter[3] = "Filter: " + sValue + " (" + sDescription + ")";
                                PreAmpFilter[4] = "Filter: " + sValue + " (" + sDescription + ")";
                                PreAmpFilter[5] = "Filter: " + sValue + " (" + sDescription + ")";
                                PreAmpFilter[6] = "Filter: " + sValue + " (" + sDescription + ")";
                                PreAmpFilter[7] = "Filter: " + sValue + " (" + sDescription + ")";
                        } else if (sKey.startsWith("laserWavelength_")) {
                                int index = Integer.parseInt(sKey.substring(sKey.lastIndexOf("_") + 1));
                                LaserWavelength[index] = Integer.parseInt(sValue);
                        } else if (sKey.equals("laserWavelength")) {
                            NodeList oIndices = oKey.getChildNodes();
                            for(int j = 0; j < oIndices.getLength(); j++) {
                                Node oIndex = oIndices.item(j);
                                if (oIndex.getNodeName().equals("IndexedValue")) {
                                    String sKey2 = oIndex.getAttributes().getNamedItem("index").getNodeValue();
                                    String sValue2 = oIndex.getAttributes().getNamedItem("value").getNodeValue();
                                    LaserWavelength[Integer.parseInt(sKey2)] = Integer.parseInt(sValue2);
                                }
                            }
                        } else if (sKey.startsWith("twophotonLaserPower_")) {
                                int index = Integer.parseInt(sKey.substring(sKey.lastIndexOf("_") + 1));
                                TwoPhotonLaserPower[index] = Double.toString(roundDouble(Double.parseDouble(sValue), 1)) + " milliwatts";
                        }
                        else if (sKey.equals("twophotonLaserPower")) {
                            NodeList oIndices = oKey.getChildNodes();
                            for(int j = 0; j < oIndices.getLength(); j++) {
                                Node oIndex = oIndices.item(j);
                                if (oIndex.getNodeName().equals("IndexedValue")) {
                                    String sKey2 = oIndex.getAttributes().getNamedItem("index").getNodeValue();
                                    String sValue2 = oIndex.getAttributes().getNamedItem("value").getNodeValue();
                                    TwoPhotonLaserPower[Integer.parseInt(sKey2)] = Double.toString(roundDouble(Double.parseDouble(sValue2), 1)) + " milliwatts";
                                }
                            }
                        }
                        else if (sKey.startsWith("bitDepth")) {
                            BitDepth = Integer.parseInt(sValue);
                        }
                        else if (sKey.startsWith("sfc_exposureTime")) {
                            SFCExposureTime = sValue + " ms";
                        }
                        else if (sKey.startsWith("sfc_exposureMode")) {
                            SFCExposureMode = sValue;
                        }
                        else if (sKey.startsWith("sfc_emissionFilter")) {
                            SFCEmissionFilter = sValue;
                        }
                        else if (sKey.startsWith("sfc_aperture")) {
                            SFCAperture = sValue;
                        }
                        else if (sKey.startsWith("sfc_gain")) {
                            SFCGain = sValue;
                        }
                        else if (sKey.startsWith("sfc_gainMultFactor")) {
                            SFCGainMultFactor = sValue;
                        }
                        else if (sKey.startsWith("sfc_binFactor")) {
                            SFCBinFactor = Integer.parseInt(sValue);
                        }
                        else if (sKey.startsWith("sfc_channel1Lasers")) {
                            SFCChannel1Lasers = sValue;
                        }
                        else if (sKey.startsWith("sfc_channel2Lasers")) {
                            SFCChannel2Lasers = sValue;
                        }
                        else if (sKey.startsWith("sfc_channel3Lasers")) {
                            SFCChannel3Lasers = sValue;
                        }
                        else if (sKey.startsWith("sfc_channel4Lasers")) {
                            SFCChannel4Lasers = sValue;
                        }
                        else if (sKey.startsWith("camera_exposureTime")) {
                            CameraExposureTime = sValue + " ms";
                        }
                        else if (sKey.startsWith("camera_exposureMode")) {
                            CameraExposureMode = sValue;
                        }
                        else if (sKey.startsWith("camera_gain")) {
                            CameraGain = sValue;
                        }
                        else if (sKey.startsWith("camera_gainMultFactor")) {
                            CameraGainMultFactor = sValue;
                        }
                        else if (sKey.startsWith("camera_binFactor")) {
                            CameraBinFactor = Integer.parseInt(sValue);
                        }
                        else if (sKey.startsWith("confocalChannel123LabelDichroic")) {
                            ConfocalChannel123DichroicLabel = sValue;
                        }
                        else if (sKey.startsWith("confocalChannel23LabelDichroic")) {
                            ConfocalChannel23DichroicLabel = sValue;
                        }
                        else if (sKey.startsWith("confocalChannel1LabelFilter")) {
                            ConfocalChannel1FilterLabel = sValue;
                        }
                        else if (sKey.startsWith("confocalChannel2LabelFilter")) {
                            ConfocalChannel2FilterLabel = sValue;
                        }
                        else if (sKey.startsWith("confocalChannel3LabelFilter")) {
                            ConfocalChannel3FilterLabel= sValue;
                        }
                        else if (sKey.startsWith("confocalLabelPinhole")) {
                            ConfocalPinholeLabel = sValue;
                        } else if (sKey.equals("xYStageGridXIndex")) {
                            MosaicGridXIndex = Integer.parseInt(sValue);
                        } else if (sKey.equals("xYStageGridYIndex")) {
                            MosaicGridYIndex = Integer.parseInt(sValue);
                        }
                    }
                }
            }
            
            public int ChannelCount() {
                int count = 0;
                for (int index = 0; index < 4; index++) {
                        if (Filename[index] != null) count++;
                }
                return count;
            }

            public String AbsoluteTime() {
                return AbsoluteTime + " s";
            }

            public String RelativeTime() {
                return RelativeTime + " s";
            }

            public String SFCBinFactor() {
                int binFactor = (int)SFCBinFactor;
                return binFactor + "x" + binFactor;
            }

            public String CameraBinFactor() {
                int binFactor = (int)CameraBinFactor;
                return binFactor + "x" + binFactor;
            }

            public String SystemType() {
                if (SystemType == 0 || SystemType == 3) return "Ultima Galvo Mode";
                if (SystemType == 2) return "Ultima AOD Mode";
                if (SystemType == 1) return "PC-Oz AOD Mode";
                return "Unknown";
            }

            public String ActiveMode() {
                if (ActiveMode == 0 || ActiveMode == ModeGalvo) return "Ultima Galvo Mode";
                if (ActiveMode == ModeAOD) return "Ultima AOD Mode";
                if (ActiveMode == ModeSFC) return "SFC Mode";
                if (ActiveMode == ModeCamera) return "Camera Mode";
                if (ActiveMode == ModeResonantGalvo) return "Ultima Resonant Galvo Mode";
                if (ActiveMode == ModeFLIM) return "Ultima FLIM Mode";
                return "Unknown";
            }

            public String BinningMode() {
                if (SystemType == 0) return "Averaging";
                if (SystemType == 1) return "Summing";
                return "Unknown";
            }

            public String OpticalZoom() {
                return Double.toString(OpticalZoom) + " x";
            }

            public Double NumOpticalZoom() {
                return OpticalZoom;
            }

            public String ScanlinePeriod() {
                return ScanlinePeriod + " ms";
            }

            public String MicronsPerPixelX() {
                if (MicronsPerPixelX == null) return "Unknown";
                if ((ActiveMode == ModeGalvo) || (ActiveMode == ModeAOD) || (ActiveMode == ModeResonantGalvo) || (ActiveMode == ModeFLIM)) {
                    if (data.isPreVersion4dot3dot2dot12())
                        return Double.toString(roundDouble(MicronsPerPixelX / OpticalZoom, 4)) + " microns";
                    else
                        return Double.toString(roundDouble(MicronsPerPixelX, 4)) + " microns";
                }
                else if (ActiveMode == ModeSFC)
                    return Double.toString(roundDouble(MicronsPerPixelX * SFCBinFactor, 4)) + " microns";
                else if (ActiveMode == ModeCamera)
                    return Double.toString(roundDouble(MicronsPerPixelX * CameraBinFactor, 4)) + " microns";
                else
                    return "Unknown";
            }

            public Double NumMicronsPerPixelX() {
                if (MicronsPerPixelX == null) return 1.0;
                if ((ActiveMode == ModeGalvo) || (ActiveMode == ModeAOD) || (ActiveMode == ModeResonantGalvo) || (ActiveMode == ModeFLIM)) {
                    if (data.isPreVersion4dot3dot2dot12())
                        return (MicronsPerPixelX / OpticalZoom);
                    else
                        return MicronsPerPixelX;
                }
                else if (ActiveMode == ModeSFC)
                    return (MicronsPerPixelX * SFCBinFactor);
                else if (ActiveMode == ModeCamera)
                    return (MicronsPerPixelX * CameraBinFactor);
                else
                    return 1.0;
            }

            public String MicronsPerPixelY() {
                if (MicronsPerPixelY == null) return "Unknown";
                if ((ActiveMode == ModeGalvo) || (ActiveMode == ModeAOD) || (ActiveMode == ModeResonantGalvo) || (ActiveMode == ModeFLIM)) {
                    if (data.isPreVersion4dot3dot2dot12())
                        return Double.toString(roundDouble(MicronsPerPixelY / OpticalZoom, 4)) + " microns";
                    else
                        return Double.toString(roundDouble(MicronsPerPixelY, 4)) + " microns";
                }
                else if (ActiveMode == ModeSFC)
                    return Double.toString(roundDouble(MicronsPerPixelY * SFCBinFactor, 4)) + " microns";
                else if (ActiveMode == ModeCamera)
                    return Double.toString(roundDouble(MicronsPerPixelY * CameraBinFactor, 4)) + " microns";
                else
                    return "Unknown";
            }

            public Double NumMicronsPerPixelY() {
                if (MicronsPerPixelY == null) return 1.0;
                if ((ActiveMode == ModeGalvo) || (ActiveMode == ModeAOD) || (ActiveMode == ModeResonantGalvo) || (ActiveMode == ModeFLIM)){
                    if (data.isPreVersion4dot3dot2dot12())
                        return (MicronsPerPixelY / OpticalZoom);
                    else
                        return MicronsPerPixelY;
                }
                else if (ActiveMode == ModeSFC)
                    return (MicronsPerPixelY * SFCBinFactor);
                else if (ActiveMode == ModeCamera)
                    return (MicronsPerPixelY * CameraBinFactor);
                else
                    return 1.0;
            }

            public Integer NumBitDepth() {
                return BitDepth;
            }

            /*public Integer NumZDevice() {  //*MJF+2 3/26/15 #2751 commented
                return ZDevice;
            }*/

            public String FieldOfView() {
                String fovX;
                String fovY;
                if (MicronsPerPixelX == null || MicronsPerPixelY == null) return "Unknown";
                if ((ActiveMode == ModeGalvo) || (ActiveMode == ModeAOD) || (ActiveMode == ModeResonantGalvo) || (ActiveMode == ModeFLIM)) {
                    if (data.isPreVersion4dot3dot2dot12()) {
                        fovX = Double.toString(roundDouble(MicronsPerPixelX / OpticalZoom * PixelsPerLine, 3));
                        fovY = Double.toString(roundDouble(MicronsPerPixelY / OpticalZoom * LinesPerFrame, 3));
                        return fovX + " x " + fovY + " microns";
                    }
                    else {
                        fovX = Double.toString(roundDouble(MicronsPerPixelX * PixelsPerLine, 3));
                        fovY = Double.toString(roundDouble(MicronsPerPixelY * LinesPerFrame, 3));
                        return fovX + " x " + fovY + " microns";
                    }
                }
                else if (ActiveMode == ModeSFC) {
                    fovX = Double.toString(roundDouble(MicronsPerPixelX * SFCBinFactor * PixelsPerLine, 3));
                    fovY = Double.toString(roundDouble(MicronsPerPixelY * SFCBinFactor * LinesPerFrame, 3));
                    return fovX + " x " + fovY + " microns";
               }
                else if (ActiveMode == ModeCamera) {
                    fovX = Double.toString(roundDouble(MicronsPerPixelX * CameraBinFactor * PixelsPerLine, 3));
                    fovY = Double.toString(roundDouble(MicronsPerPixelY * CameraBinFactor * LinesPerFrame, 3));
                    return fovX + " x " + fovY + " microns";
                }
                else 
                    return "Unknown";
            }

            public String Position() {
                return "{x = " + PositionCurrentX + ", y = " + PositionCurrentY + ", z = " + PositionCurrentZ + "}";
            }

            public String Summary() {
               return "t:" + RelativeTime + " z:" + PositionCurrentZ;
            }
	}
}



//***************************************************************************************************
//
// All of the code that follows are the various class files from ini4j.jar
//
// To be able to succesfully include these files here, all of the 'public' class/interface definitions
// had to be removed.  Also, the following classes had sections commented out to allow for a 
// successful compile:
//      BasicRegistryKey
//      RegEscapeTool
//      BasicRegistry
//      TypeValuesPair
//      RegBuilder
//
//
//***************************************************************************************************

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;
//
//import org.ini4j.spi.Warnings;

//import java.io.Serializable;
//
//import java.util.ArrayList;
//import java.util.Collection;
//import java.util.HashSet;
//import java.util.LinkedHashMap;
//import java.util.List;
//import java.util.Map;
//import java.util.Map.Entry;
//import java.util.Set;

class BasicMultiMap<K, V> implements MultiMap<K, V>, Serializable
{
    private static final long serialVersionUID = 4716749660560043989L;
    private final Map<K, java.util.List<V>> _impl;

    public BasicMultiMap()
    {
        this(new LinkedHashMap<K, java.util.List<V>>());
    }

    public BasicMultiMap(Map<K, java.util.List<V>> impl)
    {
        _impl = impl;
    }

    @Override public java.util.List<V> getAll(Object key)
    {
        return _impl.get(key);
    }

    @Override public boolean isEmpty()
    {
        return _impl.isEmpty();
    }

    @Override public void add(K key, V value)
    {
        getList(key, true).add(value);
    }

    @Override public void add(K key, V value, int index)
    {
        getList(key, true).add(index, value);
    }

    @Override public void clear()
    {
        _impl.clear();
    }

    @Override public boolean containsKey(Object key)
    {
        return _impl.containsKey(key);
    }

    @Override public boolean containsValue(Object value)
    {
        boolean ret = false;

        for (java.util.List<V> all : _impl.values())
        {
            if (all.contains(value))
            {
                ret = true;

                break;
            }
        }

        return ret;
    }

    @Override public Set<Entry<K, V>> entrySet()
    {
        Set<Entry<K, V>> ret = new HashSet<Entry<K, V>>();

        for (K key : keySet())
        {
            ret.add(new ShadowEntry(key));
        }

        return ret;
    }

    @Override public V get(Object key)
    {
        java.util.List<V> values = getList(key, false);

        return (values == null) ? null : values.get(values.size() - 1);
    }

    @Override public V get(Object key, int index)
    {
        java.util.List<V> values = getList(key, false);

        return (values == null) ? null : values.get(index);
    }

    @Override public Set<K> keySet()
    {
        return _impl.keySet();
    }

    @Override public int length(Object key)
    {
        java.util.List<V> values = getList(key, false);

        return (values == null) ? 0 : values.size();
    }

    @Override public V put(K key, V value)
    {
        V ret = null;
        java.util.List<V> values = getList(key, true);

        if (values.isEmpty())
        {
            values.add(value);
        }
        else
        {
            ret = values.set(values.size() - 1, value);
        }

        return ret;
    }

    @Override public V put(K key, V value, int index)
    {
        return getList(key, false).set(index, value);
    }

    @SuppressWarnings(Warnings.UNCHECKED)
    @Override public void putAll(Map<? extends K, ? extends V> map)
    {
        if (map instanceof MultiMap)
        {
            MultiMap<K, V> mm = (MultiMap<K, V>) map;

            for (Object key : mm.keySet())
            {
                putAll((K) key, mm.getAll(key));
            }
        }
        else
        {
            for (K key : map.keySet())
            {
                put(key, map.get(key));
            }
        }
    }

    @Override public java.util.List<V> putAll(K key, java.util.List<V> values)
    {
        java.util.List<V> ret = _impl.get(key);

        _impl.put(key, new ArrayList<V>(values));

        return ret;
    }

    @Override public V remove(Object key)
    {
        java.util.List<V> prev = _impl.remove(key);

        return (prev == null) ? null : prev.get(0);
    }

    @Override public V remove(Object key, int index)
    {
        V ret = null;
        java.util.List<V> values = getList(key, false);

        if (values != null)
        {
            ret = values.remove(index);
            if (values.isEmpty())
            {
                _impl.remove(key);
            }
        }

        return ret;
    }

    @Override public int size()
    {
        return _impl.size();
    }

    @Override public String toString()
    {
        return _impl.toString();
    }

    @Override public Collection<V> values()
    {
        java.util.List<V> all = new ArrayList<V>(_impl.size());

        for (java.util.List<V> values : _impl.values())
        {
            all.addAll(values);
        }

        return all;
    }

    @SuppressWarnings(Warnings.UNCHECKED)
    private java.util.List<V> getList(Object key, boolean create)
    {
        java.util.List<V> values = _impl.get(key);

        if ((values == null) && create)
        {
            values = new ArrayList<V>();
            _impl.put((K) key, values);
        }

        return values;
    }

    class ShadowEntry implements Map.Entry<K, V>
    {
        private final K _key;

        ShadowEntry(K key)
        {
            _key = key;
        }

        @Override public K getKey()
        {
            return _key;
        }

        @Override public V getValue()
        {
            return get(_key);
        }

        @Override public V setValue(V value)
        {
            return put(_key, value);
        }
    }
}


/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import org.ini4j.spi.BeanAccess;
//import org.ini4j.spi.BeanTool;
//import org.ini4j.spi.Warnings;

//import java.lang.reflect.Array;
//
//import java.util.regex.Matcher;
//import java.util.regex.Pattern;

class BasicOptionMap extends CommonMultiMap<String, String> implements OptionMap
{
    private static final char SUBST_CHAR = '$';
    private static final String SYSTEM_PROPERTY_PREFIX = "@prop/";
    private static final String ENVIRONMENT_PREFIX = "@env/";
    private static final int SYSTEM_PROPERTY_PREFIX_LEN = SYSTEM_PROPERTY_PREFIX.length();
    private static final int ENVIRONMENT_PREFIX_LEN = ENVIRONMENT_PREFIX.length();
    private static final Pattern EXPRESSION = Pattern.compile("(?<!\\\\)\\$\\{(([^\\[\\}]+)(\\[([0-9]+)\\])?)\\}");
    private static final int G_OPTION = 2;
    private static final int G_INDEX = 4;
    private static final long serialVersionUID = 325469712293707584L;
    private BeanAccess _defaultBeanAccess;
    private final boolean _propertyFirstUpper;

    public BasicOptionMap()
    {
        this(false);
    }

    public BasicOptionMap(boolean propertyFirstUpper)
    {
        _propertyFirstUpper = propertyFirstUpper;
    }

    @Override
    @SuppressWarnings(Warnings.UNCHECKED)
    public <T> T getAll(Object key, Class<T> clazz)
    {
        requireArray(clazz);
        T value;

        value = (T) Array.newInstance(clazz.getComponentType(), length(key));
        for (int i = 0; i < length(key); i++)
        {
            Array.set(value, i, BeanTool.getInstance().parse(get(key, i), clazz.getComponentType()));
        }

        return value;
    }

    @Override public void add(String key, Object value)
    {
        super.add(key, ((value == null) || (value instanceof String)) ? (String) value : String.valueOf(value));
    }

    @Override public void add(String key, Object value, int index)
    {
        super.add(key, ((value == null) || (value instanceof String)) ? (String) value : String.valueOf(value), index);
    }

    @Override public <T> T as(Class<T> clazz)
    {
        return BeanTool.getInstance().proxy(clazz, getDefaultBeanAccess());
    }

    @Override public <T> T as(Class<T> clazz, String keyPrefix)
    {
        return BeanTool.getInstance().proxy(clazz, newBeanAccess(keyPrefix));
    }

    @Override public String fetch(Object key)
    {
        int len = length(key);

        return (len == 0) ? null : fetch(key, len - 1);
    }

    @Override public String fetch(Object key, String defaultValue)
    {
        String str = get(key);

        return (str == null) ? defaultValue : str;
    }

    @Override public String fetch(Object key, int index)
    {
        String value = get(key, index);

        if ((value != null) && (value.indexOf(SUBST_CHAR) >= 0))
        {
            StringBuilder buffer = new StringBuilder(value);

            resolve(buffer);
            value = buffer.toString();
        }

        return value;
    }

    @Override public <T> T fetch(Object key, Class<T> clazz)
    {
        return BeanTool.getInstance().parse(fetch(key), clazz);
    }

    @Override public <T> T fetch(Object key, Class<T> clazz, T defaultValue)
    {
        String str = fetch(key);

        return (str == null) ? defaultValue : BeanTool.getInstance().parse(str, clazz);
    }

    @Override public <T> T fetch(Object key, int index, Class<T> clazz)
    {
        return BeanTool.getInstance().parse(fetch(key, index), clazz);
    }

    @Override
    @SuppressWarnings(Warnings.UNCHECKED)
    public <T> T fetchAll(Object key, Class<T> clazz)
    {
        requireArray(clazz);
        T value;

        value = (T) Array.newInstance(clazz.getComponentType(), length(key));
        for (int i = 0; i < length(key); i++)
        {
            Array.set(value, i, BeanTool.getInstance().parse(fetch(key, i), clazz.getComponentType()));
        }

        return value;
    }

    @Override public void from(Object bean)
    {
        BeanTool.getInstance().inject(getDefaultBeanAccess(), bean);
    }

    @Override public void from(Object bean, String keyPrefix)
    {
        BeanTool.getInstance().inject(newBeanAccess(keyPrefix), bean);
    }

    @Override public <T> T get(Object key, Class<T> clazz)
    {
        return BeanTool.getInstance().parse(get(key), clazz);
    }

    @Override public String get(Object key, String defaultValue)
    {
        String str = get(key);

        return (str == null) ? defaultValue : str;
    }

    @Override public <T> T get(Object key, Class<T> clazz, T defaultValue)
    {
        String str = get(key);

        return (str == null) ? defaultValue : BeanTool.getInstance().parse(str, clazz);
    }

    @Override public <T> T get(Object key, int index, Class<T> clazz)
    {
        return BeanTool.getInstance().parse(get(key, index), clazz);
    }

    @Override public String put(String key, Object value)
    {
        return super.put(key, ((value == null) || (value instanceof String)) ? (String) value : String.valueOf(value));
    }

    @Override public String put(String key, Object value, int index)
    {
        return super.put(key, ((value == null) || (value instanceof String)) ? (String) value : String.valueOf(value), index);
    }

    @Override public void putAll(String key, Object value)
    {
        if (value != null)
        {
            requireArray(value.getClass());
        }

        remove(key);
        if (value != null)
        {
            int n = Array.getLength(value);

            for (int i = 0; i < n; i++)
            {
                add(key, Array.get(value, i));
            }
        }
    }

    @Override public void to(Object bean)
    {
        BeanTool.getInstance().inject(bean, getDefaultBeanAccess());
    }

    @Override public void to(Object bean, String keyPrefix)
    {
        BeanTool.getInstance().inject(bean, newBeanAccess(keyPrefix));
    }

    synchronized BeanAccess getDefaultBeanAccess()
    {
        if (_defaultBeanAccess == null)
        {
            _defaultBeanAccess = newBeanAccess();
        }

        return _defaultBeanAccess;
    }

    boolean isPropertyFirstUpper()
    {
        return _propertyFirstUpper;
    }

    BeanAccess newBeanAccess()
    {
        return new Access();
    }

    BeanAccess newBeanAccess(String propertyNamePrefix)
    {
        return new Access(propertyNamePrefix);
    }

    void resolve(StringBuilder buffer)
    {
        Matcher m = EXPRESSION.matcher(buffer);

        while (m.find())
        {
            String name = m.group(G_OPTION);
            int index = (m.group(G_INDEX) == null) ? -1 : Integer.parseInt(m.group(G_INDEX));
            String value;

            if (name.startsWith(ENVIRONMENT_PREFIX))
            {
                value = Config.getEnvironment(name.substring(ENVIRONMENT_PREFIX_LEN));
            }
            else if (name.startsWith(SYSTEM_PROPERTY_PREFIX))
            {
                value = Config.getSystemProperty(name.substring(SYSTEM_PROPERTY_PREFIX_LEN));
            }
            else
            {
                value = (index == -1) ? fetch(name) : fetch(name, index);
            }

            if (value != null)
            {
                buffer.replace(m.start(), m.end(), value);
                m.reset(buffer);
            }
        }
    }

    private void requireArray(Class clazz)
    {
        if (!clazz.isArray())
        {
            throw new IllegalArgumentException("Array required");
        }
    }

    class Access implements BeanAccess
    {
        private final String _prefix;

        Access()
        {
            this(null);
        }

        Access(String prefix)
        {
            _prefix = prefix;
        }

        @Override public void propAdd(String propertyName, String value)
        {
            add(transform(propertyName), value);
        }

        @Override public String propDel(String propertyName)
        {
            return remove(transform(propertyName));
        }

        @Override public String propGet(String propertyName)
        {
            return fetch(transform(propertyName));
        }

        @Override public String propGet(String propertyName, int index)
        {
            return fetch(transform(propertyName), index);
        }

        @Override public int propLength(String propertyName)
        {
            return length(transform(propertyName));
        }

        @Override public String propSet(String propertyName, String value)
        {
            return put(transform(propertyName), value);
        }

        @Override public String propSet(String propertyName, String value, int index)
        {
            return put(transform(propertyName), value, index);
        }

        private String transform(String orig)
        {
            String ret = orig;

            if (((_prefix != null) || isPropertyFirstUpper()) && (orig != null))
            {
                StringBuilder buff = new StringBuilder();

                if (_prefix != null)
                {
                    buff.append(_prefix);
                }

                if (isPropertyFirstUpper())
                {
                    buff.append(Character.toUpperCase(orig.charAt(0)));
                    buff.append(orig.substring(1));
                }
                else
                {
                    buff.append(orig);
                }

                ret = buff.toString();
            }

            return ret;
        }
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;
//
//import org.ini4j.spi.AbstractBeanInvocationHandler;
//import org.ini4j.spi.BeanTool;
//import org.ini4j.spi.IniHandler;

//import java.lang.reflect.Array;
//import java.lang.reflect.Proxy;
//
//import java.util.regex.Matcher;
//import java.util.regex.Pattern;

class BasicProfile extends CommonMultiMap<String, Profile.Section> implements Profile
{
    private static final String SECTION_SYSTEM_PROPERTIES = "@prop";
    private static final String SECTION_ENVIRONMENT = "@env";
    private static final Pattern EXPRESSION = Pattern.compile(
            "(?<!\\\\)\\$\\{(([^\\[\\}]+)(\\[([0-9]+)\\])?/)?([^\\[^/\\}]+)(\\[(([0-9]+))\\])?\\}");
    private static final int G_SECTION = 2;
    private static final int G_SECTION_IDX = 4;
    private static final int G_OPTION = 5;
    private static final int G_OPTION_IDX = 7;
    private static final long serialVersionUID = -1817521505004015256L;
    private String _comment;
    private final boolean _propertyFirstUpper;
    private final boolean _treeMode;

    public BasicProfile()
    {
        this(false, false);
    }

    public BasicProfile(boolean treeMode, boolean propertyFirstUpper)
    {
        _treeMode = treeMode;
        _propertyFirstUpper = propertyFirstUpper;
    }

    @Override public String getComment()
    {
        return _comment;
    }

    @Override public void setComment(String value)
    {
        _comment = value;
    }

    @Override public Section add(String name)
    {
        if (isTreeMode())
        {
            int idx = name.lastIndexOf(getPathSeparator());

            if (idx > 0)
            {
                String parent = name.substring(0, idx);

                if (!containsKey(parent))
                {
                    add(parent);
                }
            }
        }

        Section section = newSection(name);

        add(name, section);

        return section;
    }

    @Override public void add(String section, String option, Object value)
    {
        getOrAdd(section).add(option, value);
    }

    @Override public <T> T as(Class<T> clazz)
    {
        return as(clazz, null);
    }

    @Override public <T> T as(Class<T> clazz, String prefix)
    {
        return clazz.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[] { clazz },
                    new BeanInvocationHandler(prefix)));
    }

    @Override public String fetch(Object sectionName, Object optionName)
    {
        Section sec = get(sectionName);

        return (sec == null) ? null : sec.fetch(optionName);
    }

    @Override public <T> T fetch(Object sectionName, Object optionName, Class<T> clazz)
    {
        Section sec = get(sectionName);

        return (sec == null) ? BeanTool.getInstance().zero(clazz) : sec.fetch(optionName, clazz);
    }

    @Override public String get(Object sectionName, Object optionName)
    {
        Section sec = get(sectionName);

        return (sec == null) ? null : sec.get(optionName);
    }

    @Override public <T> T get(Object sectionName, Object optionName, Class<T> clazz)
    {
        Section sec = get(sectionName);

        return (sec == null) ? BeanTool.getInstance().zero(clazz) : sec.get(optionName, clazz);
    }

    @Override public String put(String sectionName, String optionName, Object value)
    {
        return getOrAdd(sectionName).put(optionName, value);
    }

    @Override public Section remove(Section section)
    {
        return remove((Object) section.getName());
    }

    @Override public boolean remove(Object sectionName, Object optionName)
    {
        Section sec = get(sectionName);

		if (sec == null) {
			return false;
		}
		if (sec.containsKey(optionName)) {
			sec.remove(optionName);
			return true;
		}
		return false;
        //return (sec == null) ? null : sec.remove(optionName);
    }

    boolean isTreeMode()
    {
        return _treeMode;
    }

    char getPathSeparator()
    {
        return PATH_SEPARATOR;
    }

    boolean isPropertyFirstUpper()
    {
        return _propertyFirstUpper;
    }

    Section newSection(String name)
    {
        return new BasicProfileSection(this, name);
    }

    void resolve(StringBuilder buffer, Section owner)
    {
        Matcher m = EXPRESSION.matcher(buffer);

        while (m.find())
        {
            String sectionName = m.group(G_SECTION);
            String optionName = m.group(G_OPTION);
            int optionIndex = parseOptionIndex(m);
            Section section = parseSection(m, owner);
            String value = null;

            if (SECTION_ENVIRONMENT.equals(sectionName))
            {
                value = Config.getEnvironment(optionName);
            }
            else if (SECTION_SYSTEM_PROPERTIES.equals(sectionName))
            {
                value = Config.getSystemProperty(optionName);
            }
            else if (section != null)
            {
                value = (optionIndex == -1) ? section.fetch(optionName) : section.fetch(optionName, optionIndex);
            }

            if (value != null)
            {
                buffer.replace(m.start(), m.end(), value);
                m.reset(buffer);
            }
        }
    }

    void store(IniHandler formatter)
    {
        formatter.startIni();
        store(formatter, getComment());
        for (Ini.Section s : values())
        {
            store(formatter, s);
        }

        formatter.endIni();
    }

    void store(IniHandler formatter, Section s)
    {
        store(formatter, getComment(s.getName()));
        formatter.startSection(s.getName());
        for (String name : s.keySet())
        {
            store(formatter, s, name);
        }

        formatter.endSection();
    }

    void store(IniHandler formatter, String comment)
    {
        formatter.handleComment(comment);
    }

    void store(IniHandler formatter, Section section, String option)
    {
        store(formatter, section.getComment(option));
        int n = section.length(option);

        for (int i = 0; i < n; i++)
        {
            store(formatter, section, option, i);
        }
    }

    void store(IniHandler formatter, Section section, String option, int index)
    {
        formatter.handleOption(option, section.get(option, index));
    }

    private Section getOrAdd(String sectionName)
    {
        Section section = get(sectionName);

        return ((section == null)) ? add(sectionName) : section;
    }

    private int parseOptionIndex(Matcher m)
    {
        return (m.group(G_OPTION_IDX) == null) ? -1 : Integer.parseInt(m.group(G_OPTION_IDX));
    }

    private Section parseSection(Matcher m, Section owner)
    {
        String sectionName = m.group(G_SECTION);
        int sectionIndex = parseSectionIndex(m);

        return (sectionName == null) ? owner : ((sectionIndex == -1) ? get(sectionName) : get(sectionName, sectionIndex));
    }

    private int parseSectionIndex(Matcher m)
    {
        return (m.group(G_SECTION_IDX) == null) ? -1 : Integer.parseInt(m.group(G_SECTION_IDX));
    }

    private final class BeanInvocationHandler extends AbstractBeanInvocationHandler
    {
        private final String _prefix;

        private BeanInvocationHandler(String prefix)
        {
            _prefix = prefix;
        }

        @Override protected Object getPropertySpi(String property, Class<?> clazz)
        {
            String key = transform(property);
            Object o = null;

            if (containsKey(key))
            {
                if (clazz.isArray())
                {
                    o = Array.newInstance(clazz.getComponentType(), length(key));
                    for (int i = 0; i < length(key); i++)
                    {
                        Array.set(o, i, get(key, i).as(clazz.getComponentType()));
                    }
                }
                else
                {
                    o = get(key).as(clazz);
                }
            }

            return o;
        }

        @Override protected void setPropertySpi(String property, Object value, Class<?> clazz)
        {
            String key = transform(property);

            remove(key);
            if (value != null)
            {
                if (clazz.isArray())
                {
                    for (int i = 0; i < Array.getLength(value); i++)
                    {
                        Section sec = add(key);

                        sec.from(Array.get(value, i));
                    }
                }
                else
                {
                    Section sec = add(key);

                    sec.from(value);
                }
            }
        }

        @Override protected boolean hasPropertySpi(String property)
        {
            return containsKey(transform(property));
        }

        String transform(String property)
        {
            String ret = (_prefix == null) ? property : (_prefix + property);

            if (isPropertyFirstUpper())
            {
                StringBuilder buff = new StringBuilder();

                buff.append(Character.toUpperCase(property.charAt(0)));
                buff.append(property.substring(1));
                ret = buff.toString();
            }

            return ret;
        }
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.util.ArrayList;
//import java.util.List;
//import java.util.regex.Pattern;

class BasicProfileSection extends BasicOptionMap implements Profile.Section
{
    private static final long serialVersionUID = 985800697957194374L;
    private static final String[] EMPTY_STRING_ARRAY = {};
    private static final char REGEXP_ESCAPE_CHAR = '\\';
    private final Pattern _childPattern;
    private final String _name;
    private final BasicProfile _profile;

    protected BasicProfileSection(BasicProfile profile, String name)
    {
        _profile = profile;
        _name = name;
        _childPattern = newChildPattern(name);
    }

    @Override public Profile.Section getChild(String key)
    {
        return _profile.get(childName(key));
    }

    @Override public String getName()
    {
        return _name;
    }

    @Override public Profile.Section getParent()
    {
        Profile.Section ret = null;
        int idx = _name.lastIndexOf(_profile.getPathSeparator());

        if (idx >= 0)
        {
            String name = _name.substring(0, idx);

            ret = _profile.get(name);
        }

        return ret;
    }

    @Override public String getSimpleName()
    {
        int idx = _name.lastIndexOf(_profile.getPathSeparator());

        return (idx < 0) ? _name : _name.substring(idx + 1);
    }

    @Override public Profile.Section addChild(String key)
    {
        String name = childName(key);

        return _profile.add(name);
    }

    @Override public String[] childrenNames()
    {
        java.util.List<String> names = new ArrayList<String>();

        for (String key : _profile.keySet())
        {
            if (_childPattern.matcher(key).matches())
            {
                names.add(key.substring(_name.length() + 1));
            }
        }

        return names.toArray(EMPTY_STRING_ARRAY);
    }

    @Override public Profile.Section lookup(String... parts)
    {
        StringBuilder buff = new StringBuilder();

        for (String part : parts)
        {
            if (buff.length() != 0)
            {
                buff.append(_profile.getPathSeparator());
            }

            buff.append(part);
        }

        return _profile.get(childName(buff.toString()));
    }

    @Override public void removeChild(String key)
    {
        String name = childName(key);

        _profile.remove(name);
    }

    @Override boolean isPropertyFirstUpper()
    {
        return _profile.isPropertyFirstUpper();
    }

    @Override void resolve(StringBuilder buffer)
    {
        _profile.resolve(buffer, this);
    }

    private String childName(String key)
    {
        StringBuilder buff = new StringBuilder(_name);

        buff.append(_profile.getPathSeparator());
        buff.append(key);

        return buff.toString();
    }

    private Pattern newChildPattern(String name)
    {
        StringBuilder buff = new StringBuilder();

        buff.append('^');
        buff.append(Pattern.quote(name));
        buff.append(REGEXP_ESCAPE_CHAR);
        buff.append(_profile.getPathSeparator());
        buff.append("[^");
        buff.append(REGEXP_ESCAPE_CHAR);
        buff.append(_profile.getPathSeparator());
        buff.append("]+$");

        return Pattern.compile(buff.toString());
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;
//
//import org.ini4j.Profile.Section;

//import org.ini4j.spi.IniHandler;
//import org.ini4j.spi.RegEscapeTool;
//import org.ini4j.spi.TypeValuesPair;

class BasicRegistry extends BasicProfile implements Registry
{
    private static final long serialVersionUID = -6432826330714504802L;
    private String _version;

    public BasicRegistry()
    {
        _version = VERSION;
    }

    @Override public String getVersion()
    {
        return _version;
    }

    @Override public void setVersion(String value)
    {
        _version = value;
    }

    @Override public Key add(String name)
    {
        return (Key) super.add(name);
    }

    @Override public Key get(Object key)
    {
        return (Key) super.get(key);
    }

    @Override public Key get(Object key, int index)
    {
        return (Key) super.get(key, index);
    }

    @Override public Key put(String key, Section value)
    {
        return (Key) super.put(key, value);
    }

    @Override public Key put(String key, Section value, int index)
    {
        return (Key) super.put(key, value, index);
    }

    @Override public Key remove(Section section)
    {
        return (Key) super.remove(section);
    }

    @Override public Key remove(Object key)
    {
        return (Key) super.remove(key);
    }

    @Override public Key remove(Object key, int index)
    {
        return (Key) super.remove(key, index);
    }

//    @Override Key newSection(String name)
//    {
//        return new BasicRegistryKey(this, name);
//    }

    @Override void store(IniHandler formatter, Section section, String option)
    {
        store(formatter, section.getComment(option));
        Type type = ((Key) section).getType(option, Type.REG_SZ);
        String rawName = option.equals(Key.DEFAULT_NAME) ? option : RegEscapeTool.getInstance().quote(option);
        String[] values = new String[section.length(option)];

        for (int i = 0; i < values.length; i++)
        {
            values[i] = section.get(option, i);
        }

//        String rawValue = RegEscapeTool.getInstance().encode(new TypeValuesPair(type, values));
//
//        formatter.handleOption(rawName, rawValue);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;
//
//import org.ini4j.Registry.Key;

//class BasicRegistryKey extends BasicProfileSection implements Registry.Key
//{
//    private static final long serialVersionUID = -1390060044244350928L;
//    private static final String META_TYPE = "type";
//
//    public BasicRegistryKey(BasicRegistry registry, String name)
//    {
//        super(registry, name);
//    }
//
//    @Override public Key getChild(String key)
//    {
//        return (Key) super.getChild(key);
//    }
//
//    @Override public Key getParent()
//    {
//        return (Key) super.getParent();
//    }
//
//    @Override public Registry.Type getType(Object key)
//    {
//        return (Registry.Type) getMeta(META_TYPE, key);
//    }
//
//    @Override public Registry.Type getType(Object key, Registry.Type defaultType)
//    {
//        Registry.Type type = getType(key);
//
//        return (type == null) ? defaultType : type;
//    }
//
//    @Override public Key addChild(String key)
//    {
//        return (Key) super.addChild(key);
//    }
//
//    @Override public Key lookup(String... path)
//    {
//        return (Key) super.lookup(path);
//    }
//
//    @Override public Registry.Type putType(String key, Registry.Type type)
//    {
//        return (Registry.Type) putMeta(META_TYPE, key, type);
//    }
//
//    @Override public Registry.Type removeType(Object key)
//    {
//        return (Registry.Type) removeMeta(META_TYPE, key);
//    }
//}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.util.Map;

interface CommentedMap<K, V> extends Map<K, V>
{
    String getComment(Object key);

    String putComment(K key, String comment);

    String removeComment(Object key);
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.util.Map;
//import java.util.SortedMap;
//import java.util.TreeMap;

class CommonMultiMap<K, V> extends BasicMultiMap<K, V> implements CommentedMap<K, V>
{
    private static final long serialVersionUID = 3012579878005541746L;
    private static final String SEPARATOR = ";#;";
    private static final String FIRST_CATEGORY = "";
    private static final String LAST_CATEGORY = "zzzzzzzzzzzzzzzzzzzzzz";
    private static final String META_COMMENT = "comment";
    private SortedMap<String, Object> _meta;

    @Override public String getComment(Object key)
    {
        return (String) getMeta(META_COMMENT, key);
    }

    @Override public void clear()
    {
        super.clear();
        if (_meta != null)
        {
            _meta.clear();
        }
    }

    @SuppressWarnings("unchecked")
    @Override public void putAll(Map<? extends K, ? extends V> map)
    {
        super.putAll(map);
        if (map instanceof CommonMultiMap)
        {
            Map<String, String> meta = ((CommonMultiMap) map)._meta;

            if (meta != null)
            {
                meta().putAll(meta);
            }
        }
    }

    @Override public String putComment(K key, String comment)
    {
        return (String) putMeta(META_COMMENT, key, comment);
    }

    @Override public V remove(Object key)
    {
        V ret = super.remove(key);

        removeMeta(key);

        return ret;
    }

    @Override public V remove(Object key, int index)
    {
        V ret = super.remove(key, index);

        if (length(key) == 0)
        {
            removeMeta(key);
        }

        return ret;
    }

    @Override public String removeComment(Object key)
    {
        return (String) removeMeta(META_COMMENT, key);
    }

    Object getMeta(String category, Object key)
    {
        return (_meta == null) ? null : _meta.get(makeKey(category, key));
    }

    Object putMeta(String category, K key, Object value)
    {
        return meta().put(makeKey(category, key), value);
    }

    void removeMeta(Object key)
    {
        if (_meta != null)
        {
            _meta.subMap(makeKey(FIRST_CATEGORY, key), makeKey(LAST_CATEGORY, key)).clear();
        }
    }

    Object removeMeta(String category, Object key)
    {
        return (_meta == null) ? null : _meta.remove(makeKey(category, key));
    }

    private String makeKey(String category, Object key)
    {
        StringBuilder buff = new StringBuilder();

        buff.append(String.valueOf(key));
        buff.append(SEPARATOR);
        buff.append(category);

        return buff.toString();
    }

    private Map<String, Object> meta()
    {
        if (_meta == null)
        {
            _meta = new TreeMap<String, Object>();
        }

        return _meta;
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.io.Serializable;
//
//import java.nio.charset.Charset;

@SuppressWarnings("PMD.ExcessivePublicCount")
class Config implements Cloneable, Serializable
{
    public static final String KEY_PREFIX = "org.ini4j.config.";
    public static final String PROP_EMPTY_OPTION = "emptyOption";
    public static final String PROP_EMPTY_SECTION = "emptySection";
    public static final String PROP_GLOBAL_SECTION = "globalSection";
    public static final String PROP_GLOBAL_SECTION_NAME = "globalSectionName";
    public static final String PROP_INCLUDE = "include";
    public static final String PROP_LOWER_CASE_OPTION = "lowerCaseOption";
    public static final String PROP_LOWER_CASE_SECTION = "lowerCaseSection";
    public static final String PROP_MULTI_OPTION = "multiOption";
    public static final String PROP_MULTI_SECTION = "multiSection";
    public static final String PROP_STRICT_OPERATOR = "strictOperator";
    public static final String PROP_UNNAMED_SECTION = "unnamedSection";
    public static final String PROP_ESCAPE = "escape";
    public static final String PROP_ESCAPE_NEWLINE = "escapeNewline";
    public static final String PROP_PATH_SEPARATOR = "pathSeparator";
    public static final String PROP_TREE = "tree";
    public static final String PROP_PROPERTY_FIRST_UPPER = "propertyFirstUpper";
    public static final String PROP_FILE_ENCODING = "fileEncoding";
    public static final String PROP_LINE_SEPARATOR = "lineSeparator";
    public static final String PROP_COMMENT = "comment";
    public static final String PROP_HEADER_COMMENT = "headerComment";
    public static final boolean DEFAULT_EMPTY_OPTION = false;
    public static final boolean DEFAULT_EMPTY_SECTION = false;
    public static final boolean DEFAULT_GLOBAL_SECTION = false;
    public static final String DEFAULT_GLOBAL_SECTION_NAME = "?";
    public static final boolean DEFAULT_INCLUDE = false;
    public static final boolean DEFAULT_LOWER_CASE_OPTION = false;
    public static final boolean DEFAULT_LOWER_CASE_SECTION = false;
    public static final boolean DEFAULT_MULTI_OPTION = true;
    public static final boolean DEFAULT_MULTI_SECTION = false;
    public static final boolean DEFAULT_STRICT_OPERATOR = false;
    public static final boolean DEFAULT_UNNAMED_SECTION = false;
    public static final boolean DEFAULT_ESCAPE = true;
    public static final boolean DEFAULT_ESCAPE_NEWLINE = true;
    public static final boolean DEFAULT_TREE = true;
    public static final boolean DEFAULT_PROPERTY_FIRST_UPPER = false;
    public static final boolean DEFAULT_COMMENT = true;
    public static final boolean DEFAULT_HEADER_COMMENT = true;
    public static final char DEFAULT_PATH_SEPARATOR = '/';
    public static final String DEFAULT_LINE_SEPARATOR = getSystemProperty("line.separator", "\n");
    public static final Charset DEFAULT_FILE_ENCODING = Charset.forName("UTF-8");
    private static final Config GLOBAL = new Config();
    private static final long serialVersionUID = 2865793267410367814L;
    private boolean _comment;
    private boolean _emptyOption;
    private boolean _emptySection;
    private boolean _escape;
    private boolean _escapeNewline;
    private Charset _fileEncoding;
    private boolean _globalSection;
    private String _globalSectionName;
    private boolean _headerComment;
    private boolean _include;
    private String _lineSeparator;
    private boolean _lowerCaseOption;
    private boolean _lowerCaseSection;
    private boolean _multiOption;
    private boolean _multiSection;
    private char _pathSeparator;
    private boolean _propertyFirstUpper;
    private boolean _strictOperator;
    private boolean _tree;
    private boolean _unnamedSection;

    public Config()
    {
        reset();
    }

    public static String getEnvironment(String name)
    {
        return getEnvironment(name, null);
    }

    public static String getEnvironment(String name, String defaultValue)
    {
        String value;

        try
        {
            value = System.getenv(name);
        }
        catch (SecurityException x)
        {
            value = null;
        }

        return (value == null) ? defaultValue : value;
    }

    public static Config getGlobal()
    {
        return GLOBAL;
    }

    public static String getSystemProperty(String name)
    {
        return getSystemProperty(name, null);
    }

    public static String getSystemProperty(String name, String defaultValue)
    {
        String value;

        try
        {
            value = System.getProperty(name);
        }
        catch (SecurityException x)
        {
            value = null;
        }

        return (value == null) ? defaultValue : value;
    }

    public void setComment(boolean value)
    {
        _comment = value;
    }

    public boolean isEscape()
    {
        return _escape;
    }

    public boolean isEscapeNewline()
    {
        return _escapeNewline;
    }

    public boolean isInclude()
    {
        return _include;
    }

    public boolean isTree()
    {
        return _tree;
    }

    public void setEmptyOption(boolean value)
    {
        _emptyOption = value;
    }

    public void setEmptySection(boolean value)
    {
        _emptySection = value;
    }

    public void setEscape(boolean value)
    {
        _escape = value;
    }

    public void setEscapeNewline(boolean value)
    {
        _escapeNewline = value;
    }

    public Charset getFileEncoding()
    {
        return _fileEncoding;
    }

    public void setFileEncoding(Charset value)
    {
        _fileEncoding = value;
    }

    public void setGlobalSection(boolean value)
    {
        _globalSection = value;
    }

    public String getGlobalSectionName()
    {
        return _globalSectionName;
    }

    public void setGlobalSectionName(String value)
    {
        _globalSectionName = value;
    }

    public void setHeaderComment(boolean value)
    {
        _headerComment = value;
    }

    public void setInclude(boolean value)
    {
        _include = value;
    }

    public String getLineSeparator()
    {
        return _lineSeparator;
    }

    public void setLineSeparator(String value)
    {
        _lineSeparator = value;
    }

    public void setLowerCaseOption(boolean value)
    {
        _lowerCaseOption = value;
    }

    public void setLowerCaseSection(boolean value)
    {
        _lowerCaseSection = value;
    }

    public void setMultiOption(boolean value)
    {
        _multiOption = value;
    }

    public void setMultiSection(boolean value)
    {
        _multiSection = value;
    }

    public boolean isEmptyOption()
    {
        return _emptyOption;
    }

    public boolean isEmptySection()
    {
        return _emptySection;
    }

    public boolean isGlobalSection()
    {
        return _globalSection;
    }

    public boolean isLowerCaseOption()
    {
        return _lowerCaseOption;
    }

    public boolean isLowerCaseSection()
    {
        return _lowerCaseSection;
    }

    public boolean isMultiOption()
    {
        return _multiOption;
    }

    public boolean isMultiSection()
    {
        return _multiSection;
    }

    public boolean isUnnamedSection()
    {
        return _unnamedSection;
    }

    public char getPathSeparator()
    {
        return _pathSeparator;
    }

    public void setPathSeparator(char value)
    {
        _pathSeparator = value;
    }

    public void setPropertyFirstUpper(boolean value)
    {
        _propertyFirstUpper = value;
    }

    public boolean isPropertyFirstUpper()
    {
        return _propertyFirstUpper;
    }

    public boolean isStrictOperator()
    {
        return _strictOperator;
    }

    public void setStrictOperator(boolean value)
    {
        _strictOperator = value;
    }

    public boolean isComment()
    {
        return _comment;
    }

    public boolean isHeaderComment()
    {
        return _headerComment;
    }

    public void setTree(boolean value)
    {
        _tree = value;
    }

    public void setUnnamedSection(boolean value)
    {
        _unnamedSection = value;
    }

    @Override public Config clone()
    {
        try
        {
            return (Config) super.clone();
        }
        catch (CloneNotSupportedException x)
        {
            throw new AssertionError(x);
        }
    }

    public final void reset()
    {
        _emptyOption = getBoolean(PROP_EMPTY_OPTION, DEFAULT_EMPTY_OPTION);
        _emptySection = getBoolean(PROP_EMPTY_SECTION, DEFAULT_EMPTY_SECTION);
        _globalSection = getBoolean(PROP_GLOBAL_SECTION, DEFAULT_GLOBAL_SECTION);
        _globalSectionName = getString(PROP_GLOBAL_SECTION_NAME, DEFAULT_GLOBAL_SECTION_NAME);
        _include = getBoolean(PROP_INCLUDE, DEFAULT_INCLUDE);
        _lowerCaseOption = getBoolean(PROP_LOWER_CASE_OPTION, DEFAULT_LOWER_CASE_OPTION);
        _lowerCaseSection = getBoolean(PROP_LOWER_CASE_SECTION, DEFAULT_LOWER_CASE_SECTION);
        _multiOption = getBoolean(PROP_MULTI_OPTION, DEFAULT_MULTI_OPTION);
        _multiSection = getBoolean(PROP_MULTI_SECTION, DEFAULT_MULTI_SECTION);
        _strictOperator = getBoolean(PROP_STRICT_OPERATOR, DEFAULT_STRICT_OPERATOR);
        _unnamedSection = getBoolean(PROP_UNNAMED_SECTION, DEFAULT_UNNAMED_SECTION);
        _escape = getBoolean(PROP_ESCAPE, DEFAULT_ESCAPE);
        _escapeNewline = getBoolean(PROP_ESCAPE_NEWLINE, DEFAULT_ESCAPE_NEWLINE);
        _pathSeparator = getChar(PROP_PATH_SEPARATOR, DEFAULT_PATH_SEPARATOR);
        _tree = getBoolean(PROP_TREE, DEFAULT_TREE);
        _propertyFirstUpper = getBoolean(PROP_PROPERTY_FIRST_UPPER, DEFAULT_PROPERTY_FIRST_UPPER);
        _lineSeparator = getString(PROP_LINE_SEPARATOR, DEFAULT_LINE_SEPARATOR);
        _fileEncoding = getCharset(PROP_FILE_ENCODING, DEFAULT_FILE_ENCODING);
        _comment = getBoolean(PROP_COMMENT, DEFAULT_COMMENT);
        _headerComment = getBoolean(PROP_HEADER_COMMENT, DEFAULT_HEADER_COMMENT);
    }

    private boolean getBoolean(String name, boolean defaultValue)
    {
        String value = getSystemProperty(KEY_PREFIX + name);

        return (value == null) ? defaultValue : Boolean.parseBoolean(value);
    }

    private char getChar(String name, char defaultValue)
    {
        String value = getSystemProperty(KEY_PREFIX + name);

        return (value == null) ? defaultValue : value.charAt(0);
    }

    private Charset getCharset(String name, Charset defaultValue)
    {
        String value = getSystemProperty(KEY_PREFIX + name);

        return (value == null) ? defaultValue : Charset.forName(value);
    }

    private String getString(String name, String defaultValue)
    {
        return getSystemProperty(KEY_PREFIX + name, defaultValue);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;
//
//import org.ini4j.spi.IniHandler;
//import org.ini4j.spi.Warnings;

//import java.io.File;
//import java.io.FileReader;
//import java.io.FileWriter;
//import java.io.IOException;
//import java.io.InputStream;
//import java.io.OutputStream;
//import java.io.Reader;
//import java.io.Serializable;
//import java.io.Writer;
//
//import java.net.URL;
//
//import java.util.ArrayList;
//import java.util.Collections;
//import java.util.HashMap;
//import java.util.List;
//import java.util.Map;
//import java.util.regex.Matcher;
//import java.util.regex.Pattern;

class ConfigParser implements Serializable
{
    private static final long serialVersionUID = 9118857036229164353L;
    private PyIni _ini;

    @SuppressWarnings(Warnings.UNCHECKED)
    public ConfigParser()
    {
        this(Collections.EMPTY_MAP);
    }

    public ConfigParser(Map<String, String> defaults)
    {
        _ini = new PyIni(defaults);
    }

    public boolean getBoolean(String section, String option) throws NoSectionException, NoOptionException, InterpolationException
    {
        boolean ret;
        String value = get(section, option);

        if ("1".equalsIgnoreCase(value) || "yes".equalsIgnoreCase(value) || "true".equalsIgnoreCase(value) || "on".equalsIgnoreCase(value))
        {
            ret = true;
        }
        else if ("0".equalsIgnoreCase(value) || "no".equalsIgnoreCase(value) || "false".equalsIgnoreCase(value)
              || "off".equalsIgnoreCase(value))
        {
            ret = false;
        }
        else
        {
            throw new IllegalArgumentException(value);
        }

        return ret;
    }

    public double getDouble(String section, String option) throws NoSectionException, NoOptionException, InterpolationException
    {
        return Double.parseDouble(get(section, option));
    }

    public float getFloat(String section, String option) throws NoSectionException, NoOptionException, InterpolationException
    {
        return Float.parseFloat(get(section, option));
    }

    public int getInt(String section, String option) throws NoSectionException, NoOptionException, InterpolationException
    {
        return Integer.parseInt(get(section, option));
    }

    public long getLong(String section, String option) throws NoSectionException, NoOptionException, InterpolationException
    {
        return Long.parseLong(get(section, option));
    }

    public void addSection(String section) throws DuplicateSectionException
    {
        if (_ini.containsKey(section))
        {
            throw new DuplicateSectionException(section);
        }
        else if (PyIni.DEFAULT_SECTION_NAME.equalsIgnoreCase(section))
        {
            throw new IllegalArgumentException(section);
        }

        _ini.add(section);
    }

    public Map<String, String> defaults()
    {
        return _ini.getDefaults();
    }

    @SuppressWarnings(Warnings.UNCHECKED)
    public String get(String section, String option) throws NoSectionException, NoOptionException, InterpolationException
    {
        return get(section, option, false, Collections.EMPTY_MAP);
    }

    @SuppressWarnings(Warnings.UNCHECKED)
    public String get(String section, String option, boolean raw) throws NoSectionException, NoOptionException, InterpolationException
    {
        return get(section, option, raw, Collections.EMPTY_MAP);
    }

    public String get(String sectionName, String optionName, boolean raw, Map<String, String> variables) throws NoSectionException,
        NoOptionException, InterpolationException
    {
        String value = requireOption(sectionName, optionName);

        if (!raw && (value != null) && (value.indexOf(PyIni.SUBST_CHAR) >= 0))
        {
            value = _ini.fetch(sectionName, optionName, variables);
        }

        return value;
    }

    public boolean hasOption(String sectionName, String optionName)
    {
        Ini.Section section = _ini.get(sectionName);

        return (section != null) && section.containsKey(optionName);
    }

    public boolean hasSection(String sectionName)
    {
        return _ini.containsKey(sectionName);
    }

    @SuppressWarnings(Warnings.UNCHECKED)
    public java.util.List<Map.Entry<String, String>> items(String sectionName) throws NoSectionException, InterpolationMissingOptionException
    {
        return items(sectionName, false, Collections.EMPTY_MAP);
    }

    @SuppressWarnings(Warnings.UNCHECKED)
    public java.util.List<Map.Entry<String, String>> items(String sectionName, boolean raw) throws NoSectionException,
        InterpolationMissingOptionException
    {
        return items(sectionName, raw, Collections.EMPTY_MAP);
    }

    public java.util.List<Map.Entry<String, String>> items(String sectionName, boolean raw, Map<String, String> variables) throws NoSectionException,
        InterpolationMissingOptionException
    {
        Ini.Section section = requireSection(sectionName);
        Map<String, String> ret;

        if (raw)
        {
            ret = new HashMap<String, String>(section);
        }
        else
        {
            ret = new HashMap<String, String>();
            for (String key : section.keySet())
            {
                ret.put(key, _ini.fetch(section, key, variables));
            }
        }

        return new ArrayList<Map.Entry<String, String>>(ret.entrySet());
    }

    public java.util.List<String> options(String sectionName) throws NoSectionException
    {
        requireSection(sectionName);

        return new ArrayList<String>(_ini.get(sectionName).keySet());
    }

    public void read(String... filenames) throws IOException, ParsingException
    {
        for (String filename : filenames)
        {
            read(new File(filename));
        }
    }

    public void read(Reader reader) throws IOException, ParsingException
    {
        try
        {
            _ini.load(reader);
        }
        catch (InvalidFileFormatException x)
        {
            throw new ParsingException(x);
        }
    }

    public void read(URL url) throws IOException, ParsingException
    {
        try
        {
            _ini.load(url);
        }
        catch (InvalidFileFormatException x)
        {
            throw new ParsingException(x);
        }
    }

    public void read(File file) throws IOException, ParsingException
    {
        try
        {
            _ini.load(new FileReader(file));
        }
        catch (InvalidFileFormatException x)
        {
            throw new ParsingException(x);
        }
    }

    public void read(InputStream stream) throws IOException, ParsingException
    {
        try
        {
            _ini.load(stream);
        }
        catch (InvalidFileFormatException x)
        {
            throw new ParsingException(x);
        }
    }

    public boolean removeOption(String sectionName, String optionName) throws NoSectionException
    {
        Ini.Section section = requireSection(sectionName);
        boolean ret = section.containsKey(optionName);

        section.remove(optionName);

        return ret;
    }

    public boolean removeSection(String sectionName)
    {
        boolean ret = _ini.containsKey(sectionName);

        _ini.remove(sectionName);

        return ret;
    }

    public java.util.List<String> sections()
    {
        return new ArrayList<String>(_ini.keySet());
    }

    public void set(String sectionName, String optionName, Object value) throws NoSectionException
    {
        Ini.Section section = requireSection(sectionName);

        if (value == null)
        {
            section.remove(optionName);
        }
        else
        {
            section.put(optionName, value.toString());
        }
    }

    public void write(Writer writer) throws IOException
    {
        _ini.store(writer);
    }

    public void write(OutputStream stream) throws IOException
    {
        _ini.store(stream);
    }

    public void write(File file) throws IOException
    {
        _ini.store(new FileWriter(file));
    }

    protected Ini getIni()
    {
        return _ini;
    }

    private String requireOption(String sectionName, String optionName) throws NoSectionException, NoOptionException
    {
        Ini.Section section = requireSection(sectionName);
        String option = section.get(optionName);

        if (option == null)
        {
            throw new NoOptionException(optionName);
        }

        return option;
    }

    private Ini.Section requireSection(String sectionName) throws NoSectionException
    {
        Ini.Section section = _ini.get(sectionName);

        if (section == null)
        {
            throw new NoSectionException(sectionName);
        }

        return section;
    }

    public static class ConfigParserException extends Exception
    {

        /** Use serialVersionUID for interoperability. */ private static final long serialVersionUID = -6845546313519392093L;

        public ConfigParserException(String message)
        {
            super(message);
        }
    }

    public static final class DuplicateSectionException extends ConfigParserException
    {

        /** Use serialVersionUID for interoperability. */ private static final long serialVersionUID = -5244008445735700699L;

        private DuplicateSectionException(String message)
        {
            super(message);
        }
    }

    public static class InterpolationException extends ConfigParserException
    {

        /** Use serialVersionUID for interoperability. */ private static final long serialVersionUID = 8924443303158546939L;

        protected InterpolationException(String message)
        {
            super(message);
        }
    }

    public static final class InterpolationMissingOptionException extends InterpolationException
    {

        /** Use serialVersionUID for interoperability. */ private static final long serialVersionUID = 2903136975820447879L;

        private InterpolationMissingOptionException(String message)
        {
            super(message);
        }
    }

    public static final class NoOptionException extends ConfigParserException
    {

        /** Use serialVersionUID for interoperability. */ private static final long serialVersionUID = 8460082078809425858L;

        private NoOptionException(String message)
        {
            super(message);
        }
    }

    public static final class NoSectionException extends ConfigParserException
    {

        /** Use serialVersionUID for interoperability. */ private static final long serialVersionUID = 8553627727493146118L;

        private NoSectionException(String message)
        {
            super(message);
        }
    }

    public static final class ParsingException extends IOException
    {

        /** Use serialVersionUID for interoperability. */ private static final long serialVersionUID = -5395990242007205038L;

        private ParsingException(Throwable cause)
        {
            super(cause.getMessage());
            initCause(cause);
        }
    }

    static class PyIni extends Ini
    {
        private static final char SUBST_CHAR = '%';
        private static final Pattern EXPRESSION = Pattern.compile("(?<!\\\\)\\%\\(([^\\)]+)\\)");
        private static final int G_OPTION = 1;
        protected static final String DEFAULT_SECTION_NAME = "DEFAULT";
        private static final long serialVersionUID = -7152857626328996122L;
        private final Map<String, String> _defaults;
        private Ini.Section _defaultSection;

        public PyIni(Map<String, String> defaults)
        {
            _defaults = defaults;
            Config cfg = getConfig().clone();

            cfg.setEscape(false);
            cfg.setMultiOption(false);
            cfg.setMultiSection(false);
            cfg.setLowerCaseOption(true);
            cfg.setLowerCaseSection(true);
            super.setConfig(cfg);
        }

        @Override public void setConfig(Config value)
        {
            assert true;
        }

        public Map<String, String> getDefaults()
        {
            return _defaults;
        }

        @Override public Section add(String name)
        {
            Section section;

            if (DEFAULT_SECTION_NAME.equalsIgnoreCase(name))
            {
                if (_defaultSection == null)
                {
                    _defaultSection = newSection(name);
                }

                section = _defaultSection;
            }
            else
            {
                section = super.add(name);
            }

            return section;
        }

        public String fetch(String sectionName, String optionName, Map<String, String> variables) throws InterpolationMissingOptionException
        {
            return fetch(get(sectionName), optionName, variables);
        }

        protected Ini.Section getDefaultSection()
        {
            return _defaultSection;
        }

        protected String fetch(Ini.Section section, String optionName, Map<String, String> variables)
            throws InterpolationMissingOptionException
        {
            String value = section.get(optionName);

            if ((value != null) && (value.indexOf(SUBST_CHAR) >= 0))
            {
                StringBuilder buffer = new StringBuilder(value);

                resolve(buffer, section, variables);
                value = buffer.toString();
            }

            return value;
        }

        protected void resolve(StringBuilder buffer, Ini.Section owner, Map<String, String> vars) throws InterpolationMissingOptionException
        {
            Matcher m = EXPRESSION.matcher(buffer);

            while (m.find())
            {
                String optionName = m.group(G_OPTION);
                String value = owner.get(optionName);

                if (value == null)
                {
                    value = vars.get(optionName);
                }

                if (value == null)
                {
                    value = _defaults.get(optionName);
                }

                if ((value == null) && (_defaultSection != null))
                {
                    value = _defaultSection.get(optionName);
                }

                if (value == null)
                {
                    throw new InterpolationMissingOptionException(optionName);
                }

                buffer.replace(m.start(), m.end(), value);
                m.reset(buffer);
            }
        }

        @Override protected void store(IniHandler formatter)
        {
            formatter.startIni();
            if (_defaultSection != null)
            {
                store(formatter, _defaultSection);
            }

            for (Ini.Section s : values())
            {
                store(formatter, s);
            }

            formatter.endIni();
        }

        @Override protected void store(IniHandler formatter, Section section)
        {
            formatter.startSection(section.getName());
            for (String name : section.keySet())
            {
                formatter.handleOption(name, section.get(name));
            }

            formatter.endSection();
        }
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

interface Configurable
{
    Config getConfig();

    void setConfig(Config value);
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;
//
//import org.ini4j.spi.IniBuilder;
//import org.ini4j.spi.IniFormatter;
//import org.ini4j.spi.IniHandler;
//import org.ini4j.spi.IniParser;

//import java.io.File;
//import java.io.FileNotFoundException;
//import java.io.FileOutputStream;
//import java.io.IOException;
//import java.io.InputStream;
//import java.io.InputStreamReader;
//import java.io.OutputStream;
//import java.io.OutputStreamWriter;
//import java.io.Reader;
//import java.io.Writer;
//
//import java.net.URL;

class Ini extends BasicProfile implements Persistable, Configurable
{
    private static final long serialVersionUID = -6029486578113700585L;
    private Config _config;
    private File _file;

    public Ini()
    {
        _config = Config.getGlobal();
    }

    public Ini(Reader input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Ini(InputStream input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Ini(URL input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Ini(File input) throws IOException, InvalidFileFormatException
    {
        this();
        _file = input;
        load();
    }

    @Override public Config getConfig()
    {
        return _config;
    }

    @Override public void setConfig(Config value)
    {
        _config = value;
    }

    @Override public File getFile()
    {
        return _file;
    }

    @Override public void setFile(File value)
    {
        _file = value;
    }

    @Override public void load() throws IOException, InvalidFileFormatException
    {
        if (_file == null)
        {
            throw new FileNotFoundException();
        }

        load(_file);
    }

    @Override public void load(InputStream input) throws IOException, InvalidFileFormatException
    {
        load(new InputStreamReader(input, getConfig().getFileEncoding()));
    }

    @Override public void load(Reader input) throws IOException, InvalidFileFormatException
    {
        IniParser.newInstance(getConfig()).parse(input, newBuilder());
    }

    @Override public void load(File input) throws IOException, InvalidFileFormatException
    {
        load(input.toURI().toURL());
    }

    @Override public void load(URL input) throws IOException, InvalidFileFormatException
    {
        IniParser.newInstance(getConfig()).parse(input, newBuilder());
    }

    @Override public void store() throws IOException
    {
        if (_file == null)
        {
            throw new FileNotFoundException();
        }

        store(_file);
    }

    @Override public void store(OutputStream output) throws IOException
    {
        store(new OutputStreamWriter(output, getConfig().getFileEncoding()));
    }

    @Override public void store(Writer output) throws IOException
    {
        store(IniFormatter.newInstance(output, getConfig()));
    }

    @Override public void store(File output) throws IOException
    {
        OutputStream stream = new FileOutputStream(output);

        store(stream);
        stream.close();
    }

    protected IniHandler newBuilder()
    {
        return IniBuilder.newInstance(this);
    }

    @Override protected void store(IniHandler formatter, Profile.Section section)
    {
        if (getConfig().isEmptySection() || (section.size() != 0))
        {
            super.store(formatter, section);
        }
    }

    @Override protected void store(IniHandler formatter, Profile.Section section, String option, int index)
    {
        if (getConfig().isMultiOption() || (index == (section.length(option) - 1)))
        {
            super.store(formatter, section, option, index);
        }
    }

    @Override boolean isTreeMode()
    {
        return getConfig().isTree();
    }

    @Override char getPathSeparator()
    {
        return getConfig().getPathSeparator();
    }

    @Override boolean isPropertyFirstUpper()
    {
        return getConfig().isPropertyFirstUpper();
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.io.IOException;
//import java.io.InputStream;
//import java.io.Reader;
//
//import java.net.URL;
//
//import java.util.ArrayList;
//import java.util.List;
//import java.util.prefs.AbstractPreferences;
//import java.util.prefs.BackingStoreException;

class IniPreferences extends AbstractPreferences
{

    /** frequently used empty String array */
    private static final String[] EMPTY = {};

    /** underlaying <code>Ini</code> implementation */
    private final Ini _ini;

    /**
     * Constructs a new preferences node on top of <code>Ini</code> instance.
     *
     * @param ini underlaying <code>Ini</code> instance
     */
    public IniPreferences(Ini ini)
    {
        super(null, "");
        _ini = ini;
    }

    /**
     * Constructs a new preferences node based on newly loaded <code>Ini</code> instance.
     *
     * This is just a helper constructor, to make simpler constructing <code>IniPreferences</code>
     * directly from <code>Reader</code>.
     *
     * @param input the <code>Reader</code> containing <code>Ini</code> data
     * @throws IOException if an I/O error occured
     * @throws InvalidFileFormatException if <code>Ini</code> parsing error occured
     */
    public IniPreferences(Reader input) throws IOException, InvalidFileFormatException
    {
        super(null, "");
        _ini = new Ini(input);
    }

    /**
     * Constructs a new preferences node based on newly loaded <code>Ini</code> instance.
     *
     * This is just a helper constructor, to make simpler constructing <code>IniPreferences</code>
     * directly from <code>InputStream</code>.
     *
     * @param input the <code>InputStream</code> containing <code>Ini</code> data
     * @throws IOException if an I/O error occured
     * @throws InvalidFileFormatException if <code>Ini</code> parsing error occured
     */
    public IniPreferences(InputStream input) throws IOException, InvalidFileFormatException
    {
        super(null, "");
        _ini = new Ini(input);
    }

    /**
     * Constructs a new preferences node based on newly loaded <code>Ini</code> instance.
     *
     * This is just a helper constructor, to make simpler constructing <code>IniPreferences</code>
     * directly from <code>URL</code>.
     *
     * @param input the <code>URL</code> containing <code>Ini</code> data
     * @throws IOException if an I/O error occured
     * @throws InvalidFileFormatException if <code>Ini</code> parsing error occured
     */
    public IniPreferences(URL input) throws IOException, InvalidFileFormatException
    {
        super(null, "");
        _ini = new Ini(input);
    }

    /**
     * Provide access to underlaying {@link org.ini4j.Ini} implementation.
     *
     * @return <code>Ini</code> implementation
     */
    protected Ini getIni()
    {
        return _ini;
    }

    /**
     * Implements the <CODE>getSpi</CODE> method as per the specification in
     * {@link java.util.prefs.AbstractPreferences#getSpi(String)}.
     *
     * This implementation doesn't support this operation, so allways throws UnsupportedOperationException.
     *
     * @return if the value associated with the specified key at this preference node, or null if there is no association for this key, or the association cannot be determined at this time.
     * @param key key to getvalue for
     * @throws UnsupportedOperationException this implementation allways throws this exception
     */
    @Override protected String getSpi(String key) throws UnsupportedOperationException
    {
        throw new UnsupportedOperationException();
    }

    /**
     * Implements the <CODE>childrenNamesSpi</CODE> method as per the specification in
     * {@link java.util.prefs.AbstractPreferences#childrenNamesSpi()}.
     * @return an array containing the names of the children of this preference node.
     * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
     */
    @Override protected String[] childrenNamesSpi() throws BackingStoreException
    {
        java.util.List<String> names = new ArrayList<String>();

        for (String name : _ini.keySet())
        {
            if (name.indexOf(_ini.getPathSeparator()) < 0)
            {
                names.add(name);
            }
        }

        return names.toArray(EMPTY);
    }

    /**
     * Implements the <CODE>childSpi</CODE> method as per the specification in
     * {@link java.util.prefs.AbstractPreferences#childSpi(String)}.
     * @param name child name
     * @return child node
     */
    @Override protected SectionPreferences childSpi(String name)
    {
        Ini.Section sec = _ini.get(name);
        boolean isNew = sec == null;

        if (isNew)
        {
            sec = _ini.add(name);
        }

        return new SectionPreferences(this, sec, isNew);
    }

    /**
     * Implements the <CODE>flushSpi</CODE> method as per the specification in
     * {@link java.util.prefs.AbstractPreferences#flushSpi()}.
     *
     * This implementation does nothing.
     *
     * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
     */
    @Override protected void flushSpi() throws BackingStoreException
    {
        assert true;
    }

    /**
     * Implements the <CODE>keysSpi</CODE> method as per the specification in
     * {@link java.util.prefs.AbstractPreferences#keysSpi()}.
     *
     * This implementation allways return an empty array.
     *
     * @return an empty array.
     * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
     */
    @Override protected String[] keysSpi() throws BackingStoreException
    {
        return EMPTY;
    }

    /**
     * Implements the <CODE>putSpi</CODE> method as per the specification in
     * {@link java.util.prefs.AbstractPreferences#putSpi(String,String)}.
     *
     * This implementation doesn;t support this operation, so allways throws UnsupportedOperationException.
     *
     * @param key key to set value for
     * @param value new value for key
     * @throws UnsupportedOperationException this implementation allways throws this exception
     */
    @Override protected void putSpi(String key, String value) throws UnsupportedOperationException
    {
        throw new UnsupportedOperationException();
    }

    /**
     * Implements the <CODE>removeNodeSpi</CODE> method as per the specification in
     * {@link java.util.prefs.AbstractPreferences#removeNodeSpi()}.
     *
     * This implementation doesn;t support this operation, so allways throws UnsupportedOperationException.
     * @throws UnsupportedOperationException this implementation allways throws this exception
     * @throws BackingStoreException this implementation never throws this exception
     */
    @Override protected void removeNodeSpi() throws BackingStoreException, UnsupportedOperationException
    {
        throw new UnsupportedOperationException();
    }

    /**
     * Implements the <CODE>removeSpi</CODE> method as per the specification in
     * {@link java.util.prefs.AbstractPreferences#removeSpi(String)}.
     * @param key key to remove
     * @throws UnsupportedOperationException this implementation allways throws this exception
     */
    @Override protected void removeSpi(String key) throws UnsupportedOperationException
    {
        throw new UnsupportedOperationException();
    }

    /**
     * Implements the <CODE>syncSpi</CODE> method as per the specification in
     * {@link java.util.prefs.AbstractPreferences#syncSpi()}.
     *
     * This implementation does nothing.
     *
     * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
     */
    @Override protected void syncSpi() throws BackingStoreException
    {
        assert true;
    }

    protected class SectionPreferences extends AbstractPreferences
    {

        /** underlaying <code>Section</code> implementation */
        private final Ini.Section _section;

        /**
         * Constructs a new SectionPreferences instance on top of Ini.Section instance.
         *
         * @param parent parent preferences node
         * @parem section underlaying Ini.Section instance
         * @param isNew indicate is this a new node or already existing one
         */
        SectionPreferences(AbstractPreferences parent, Ini.Section section, boolean isNew)
        {
            super(parent, section.getSimpleName());
            _section = section;
            newNode = isNew;
        }

        /**
         * Implements the <CODE>flush</CODE> method as per the specification in
         * {@link java.util.prefs.Preferences#flush()}.
         *
         * This implementation just call parent's <code>flush()</code> method.
         *
         * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
         */
        @Override public void flush() throws BackingStoreException
        {
            parent().flush();
        }

        /**
         * Implements the <CODE>sync</CODE> method as per the specification in
         * {@link java.util.prefs.Preferences#sync()}.
         *
         * This implementation just call parent's <code>sync()</code> method.
         *
         * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
         */
        @Override public void sync() throws BackingStoreException
        {
            parent().sync();
        }

        /**
         * Implements the <CODE>getSpi</CODE> method as per the specification in
         * {@link java.util.prefs.AbstractPreferences#getSpi(String)}.
         * @return if the value associated with the specified key at this preference node, or null if there is no association for this key, or the association cannot be determined at this time.
         * @param key key to getvalue for
         */
        @Override protected String getSpi(String key)
        {
            return _section.fetch(key);
        }

        /**
         * Implements the <CODE>childrenNamesSpi</CODE> method as per the specification in
         * {@link java.util.prefs.AbstractPreferences#childrenNamesSpi()}.
         *
         * This implementation allways returns an empty array.
         *
         * @return an emty array.
         * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
         */
        @Override protected String[] childrenNamesSpi() throws BackingStoreException
        {
            return _section.childrenNames();
        }

        /**
         * Implements the <CODE>childSpi</CODE> method as per the specification in
         * {@link java.util.prefs.AbstractPreferences#childSpi(String)}.
         *
         * This implementation doesn't support this operation.
         *
         * @throws UnsupportedOperationException this implementation allways throws this exception
         * @param name child name
         * @return child node
         */
        @Override protected SectionPreferences childSpi(String name) throws UnsupportedOperationException
        {
            Ini.Section child = _section.getChild(name);
            boolean isNew = child == null;

            if (isNew)
            {
                child = _section.addChild(name);
            }

            return new SectionPreferences(this, child, isNew);
        }

        /**
         * Implements the <CODE>flushSpi</CODE> method as per the specification in
         * {@link java.util.prefs.AbstractPreferences#flushSpi()}.
         *
         * This implementation does nothing.
         *
         * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
         */
        @Override protected void flushSpi() throws BackingStoreException
        {
            assert true;
        }

        /**
         * Implements the <CODE>keysSpi</CODE> method as per the specification in
         * {@link java.util.prefs.AbstractPreferences#keysSpi()}.
         *
         * @return an array of the keys that have an associated value in this preference node.
         * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
         */
        @Override protected String[] keysSpi() throws BackingStoreException
        {
            return _section.keySet().toArray(EMPTY);
        }

        /**
         * Implements the <CODE>putSpi</CODE> method as per the specification in
         * {@link java.util.prefs.AbstractPreferences#putSpi(String,String)}.
         *
         * @param key key to set value for
         * @param value new value of key
         */
        @Override protected void putSpi(String key, String value)
        {
            _section.put(key, value);
        }

        /**
         * Implements the <CODE>removeNodeSpi</CODE> method as per the specification in
         * {@link java.util.prefs.AbstractPreferences#removeNodeSpi()}.
         *
         * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
         */
        @Override protected void removeNodeSpi() throws BackingStoreException
        {
            _ini.remove(_section);
        }

        /**
         * Implements the <CODE>removeSpi</CODE> method as per the specification in
         * {@link java.util.prefs.AbstractPreferences#removeSpi(String)}.
         * @param key key to remove
         */
        @Override protected void removeSpi(String key)
        {
            _section.remove(key);
        }

        /**
         * Implements the <CODE>syncSpi</CODE> method as per the specification in
         * {@link java.util.prefs.AbstractPreferences#syncSpi()}.
         *
         * This implementation does nothing.
         *
         * @throws BackingStoreException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.
         */
        @Override protected void syncSpi() throws BackingStoreException
        {
            assert true;
        }
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.io.InputStream;
//
//import java.net.URI;
//import java.net.URL;
//
//import java.util.Properties;
//import java.util.prefs.Preferences;
//import java.util.prefs.PreferencesFactory;

class IniPreferencesFactory implements PreferencesFactory
{
    public static final String PROPERTIES = "ini4j.properties";
    public static final String KEY_USER = "org.ini4j.prefs.user";
    public static final String KEY_SYSTEM = "org.ini4j.prefs.system";
    private Preferences _system;
    private Preferences _user;

    @Override public synchronized Preferences systemRoot()
    {
        if (_system == null)
        {
            _system = newIniPreferences(KEY_SYSTEM);
        }

        return _system;
    }

    @Override public synchronized Preferences userRoot()
    {
        if (_user == null)
        {
            _user = newIniPreferences(KEY_USER);
        }

        return _user;
    }

    String getIniLocation(String key)
    {
        String location = Config.getSystemProperty(key);

        if (location == null)
        {
            try
            {
                Properties props = new Properties();

                props.load(Thread.currentThread().getContextClassLoader().getResourceAsStream(PROPERTIES));
                location = props.getProperty(key);
            }
            catch (Exception x)
            {
                assert true;
            }
        }

        return location;
    }

    URL getResource(String location) throws IllegalArgumentException
    {
        try
        {
            URI uri = new URI(location);
            URL url;

            if (uri.getScheme() == null)
            {
                url = Thread.currentThread().getContextClassLoader().getResource(location);
            }
            else
            {
                url = uri.toURL();
            }

            return url;
        }
        catch (Exception x)
        {
            throw (IllegalArgumentException) new IllegalArgumentException().initCause(x);
        }
    }

    InputStream getResourceAsStream(String location) throws IllegalArgumentException
    {
        try
        {
            return getResource(location).openStream();
        }
        catch (Exception x)
        {
            throw (IllegalArgumentException) new IllegalArgumentException().initCause(x);
        }
    }

    Preferences newIniPreferences(String key)
    {
        Ini ini = new Ini();
        String location = getIniLocation(key);

        if (location != null)
        {
            try
            {
                ini.load(getResourceAsStream(location));
            }
            catch (Exception x)
            {
                throw (IllegalArgumentException) new IllegalArgumentException().initCause(x);
            }
        }

        return new IniPreferences(ini);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.io.IOException;

class InvalidFileFormatException extends IOException
{
    private static final long serialVersionUID = -4354616830804732309L;

    public InvalidFileFormatException(String message)
    {
        super(message);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.util.List;
//import java.util.Map;

interface MultiMap<K, V> extends Map<K, V>
{
    java.util.List<V> getAll(Object key);

    void add(K key, V value);

    void add(K key, V value, int index);

    V get(Object key, int index);

    int length(Object key);

    V put(K key, V value, int index);

    java.util.List<V> putAll(K key, java.util.List<V> values);

    V remove(Object key, int index);
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

interface OptionMap extends MultiMap<String, String>, CommentedMap<String, String>
{
    <T> T getAll(Object key, Class<T> clazz);

    void add(String key, Object value);

    void add(String key, Object value, int index);

    <T> T as(Class<T> clazz);

    <T> T as(Class<T> clazz, String keyPrefix);

    String fetch(Object key);

    String fetch(Object key, String defaultValue);

    String fetch(Object key, int index);

    <T> T fetch(Object key, Class<T> clazz);

    <T> T fetch(Object key, Class<T> clazz, T defaultValue);

    <T> T fetch(Object key, int index, Class<T> clazz);

    <T> T fetchAll(Object key, Class<T> clazz);

    void from(Object bean);

    void from(Object bean, String keyPrefix);

    String get(Object key, String defaultValue);

    <T> T get(Object key, Class<T> clazz);

    <T> T get(Object key, Class<T> clazz, T defaultValue);

    <T> T get(Object key, int index, Class<T> clazz);

    String put(String key, Object value);

    String put(String key, Object value, int index);

    void putAll(String key, Object value);

    void to(Object bean);

    void to(Object bean, String keyPrefix);
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;
//
//import org.ini4j.spi.OptionsBuilder;
//import org.ini4j.spi.OptionsFormatter;
//import org.ini4j.spi.OptionsHandler;
//import org.ini4j.spi.OptionsParser;

//import java.io.File;
//import java.io.FileNotFoundException;
//import java.io.FileOutputStream;
//import java.io.IOException;
//import java.io.InputStream;
//import java.io.InputStreamReader;
//import java.io.OutputStream;
//import java.io.OutputStreamWriter;
//import java.io.Reader;
//import java.io.Writer;
//
//import java.net.URL;

class Options extends BasicOptionMap implements Persistable, Configurable
{
    private static final long serialVersionUID = -1119753444859181822L;
    private String _comment;
    private Config _config;
    private File _file;

    public Options()
    {
        _config = Config.getGlobal().clone();
        _config.setEmptyOption(true);
    }

    public Options(Reader input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Options(InputStream input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Options(URL input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Options(File input) throws IOException, InvalidFileFormatException
    {
        this();
        _file = input;
        load();
    }

    public String getComment()
    {
        return _comment;
    }

    public void setComment(String value)
    {
        _comment = value;
    }

    @Override public Config getConfig()
    {
        return _config;
    }

    @Override public void setConfig(Config value)
    {
        _config = value;
    }

    @Override public File getFile()
    {
        return _file;
    }

    @Override public void setFile(File value)
    {
        _file = value;
    }

    @Override public void load() throws IOException, InvalidFileFormatException
    {
        if (_file == null)
        {
            throw new FileNotFoundException();
        }

        load(_file);
    }

    @Override public void load(InputStream input) throws IOException, InvalidFileFormatException
    {
        load(new InputStreamReader(input, getConfig().getFileEncoding()));
    }

    @Override public void load(Reader input) throws IOException, InvalidFileFormatException
    {
        OptionsParser.newInstance(getConfig()).parse(input, newBuilder());
    }

    @Override public void load(URL input) throws IOException, InvalidFileFormatException
    {
        OptionsParser.newInstance(getConfig()).parse(input, newBuilder());
    }

    @Override public void load(File input) throws IOException, InvalidFileFormatException
    {
        load(input.toURI().toURL());
    }

    @Override public void store() throws IOException
    {
        if (_file == null)
        {
            throw new FileNotFoundException();
        }

        store(_file);
    }

    @Override public void store(OutputStream output) throws IOException
    {
        store(new OutputStreamWriter(output, getConfig().getFileEncoding()));
    }

    @Override public void store(Writer output) throws IOException
    {
        store(OptionsFormatter.newInstance(output, getConfig()));
    }

    @Override public void store(File output) throws IOException
    {
        OutputStream stream = new FileOutputStream(output);

        store(stream);
        stream.close();
    }

    protected OptionsHandler newBuilder()
    {
        return OptionsBuilder.newInstance(this);
    }

    protected void store(OptionsHandler formatter) throws IOException
    {
        formatter.startOptions();
        storeComment(formatter, _comment);
        for (String name : keySet())
        {
            storeComment(formatter, getComment(name));
            int n = getConfig().isMultiOption() ? length(name) : 1;

            for (int i = 0; i < n; i++)
            {
                String value = get(name, i);

                formatter.handleOption(name, value);
            }
        }

        formatter.endOptions();
    }

    @Override boolean isPropertyFirstUpper()
    {
        return getConfig().isPropertyFirstUpper();
    }

    private void storeComment(OptionsHandler formatter, String comment)
    {
        formatter.handleComment(comment);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.io.File;
//import java.io.IOException;
//import java.io.InputStream;
//import java.io.OutputStream;
//import java.io.Reader;
//import java.io.Writer;
//
//import java.net.URL;

interface Persistable
{
    File getFile();

    void setFile(File value);

    void load() throws IOException, InvalidFileFormatException;

    void load(InputStream input) throws IOException, InvalidFileFormatException;

    void load(Reader input) throws IOException, InvalidFileFormatException;

    void load(File input) throws IOException, InvalidFileFormatException;

    void load(URL input) throws IOException, InvalidFileFormatException;

    void store() throws IOException;

    void store(OutputStream output) throws IOException;

    void store(Writer output) throws IOException;

    void store(File output) throws IOException;
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

interface Profile extends MultiMap<String, Profile.Section>, CommentedMap<String, Profile.Section>
{
    char PATH_SEPARATOR = '/';

    String getComment();

    void setComment(String value);

    Section add(String sectionName);

    void add(String sectionName, String optionName, Object value);

    <T> T as(Class<T> clazz);

    <T> T as(Class<T> clazz, String prefix);

    String fetch(Object sectionName, Object optionName);

    <T> T fetch(Object sectionName, Object optionName, Class<T> clazz);

    String get(Object sectionName, Object optionName);

    <T> T get(Object sectionName, Object optionName, Class<T> clazz);

    String put(String sectionName, String optionName, Object value);

    Section remove(Profile.Section section);

    //String remove(Object sectionName, Object optionName);
	boolean remove(Object sectionName, Object optionName);

    interface Section extends OptionMap
    {
        Section getChild(String key);

        String getName();

        Section getParent();

        String getSimpleName();

        Section addChild(String key);

        String[] childrenNames();

        Section lookup(String... path);

        void removeChild(String key);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;
//
//import org.ini4j.spi.IniFormatter;
//import org.ini4j.spi.IniHandler;
//import org.ini4j.spi.IniParser;
//import org.ini4j.spi.RegBuilder;

//import java.io.File;
//import java.io.FileNotFoundException;
//import java.io.FileOutputStream;
//import java.io.IOException;
//import java.io.InputStream;
//import java.io.InputStreamReader;
//import java.io.InterruptedIOException;
//import java.io.OutputStream;
//import java.io.OutputStreamWriter;
//import java.io.Reader;
//import java.io.Writer;
//
//import java.net.URL;

class Reg extends BasicRegistry implements Registry, Persistable, Configurable
{
    private static final long serialVersionUID = -1485602876922985912L;
    protected static final String DEFAULT_SUFFIX = ".reg";
    protected static final String TMP_PREFIX = "reg-";
    private static final int STDERR_BUFF_SIZE = 8192;
    private static final String PROP_OS_NAME = "os.name";
    private static final boolean WINDOWS = Config.getSystemProperty(PROP_OS_NAME, "Unknown").startsWith("Windows");
    private static final char CR = '\r';
    private static final char LF = '\n';
    private Config _config;
    private File _file;

    public Reg()
    {
        Config cfg = Config.getGlobal().clone();

        cfg.setEscape(false);
        cfg.setGlobalSection(false);
        cfg.setEmptyOption(true);
        cfg.setMultiOption(true);
        cfg.setStrictOperator(true);
        cfg.setEmptySection(true);
        cfg.setPathSeparator(KEY_SEPARATOR);
        cfg.setFileEncoding(FILE_ENCODING);
        cfg.setLineSeparator(LINE_SEPARATOR);
        _config = cfg;
    }

    public Reg(String registryKey) throws IOException
    {
        this();
        read(registryKey);
    }

    public Reg(File input) throws IOException, InvalidFileFormatException
    {
        this();
        _file = input;
        load();
    }

    public Reg(URL input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Reg(InputStream input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Reg(Reader input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public static boolean isWindows()
    {
        return WINDOWS;
    }

    @Override public Config getConfig()
    {
        return _config;
    }

    public void setConfig(Config value)
    {
        _config = value;
    }

    @Override public File getFile()
    {
        return _file;
    }

    @Override public void setFile(File value)
    {
        _file = value;
    }

    @Override public void load() throws IOException, InvalidFileFormatException
    {
        if (_file == null)
        {
            throw new FileNotFoundException();
        }

        load(_file);
    }

    @Override public void load(InputStream input) throws IOException, InvalidFileFormatException
    {
        load(new InputStreamReader(input, getConfig().getFileEncoding()));
    }

    @Override public void load(URL input) throws IOException, InvalidFileFormatException
    {
        load(new InputStreamReader(input.openStream(), getConfig().getFileEncoding()));
    }

    @Override public void load(Reader input) throws IOException, InvalidFileFormatException
    {
        int newline = 2;
        StringBuilder buff = new StringBuilder();

        for (int c = input.read(); c != -1; c = input.read())
        {
            if (c == LF)
            {
                newline--;
                if (newline == 0)
                {
                    break;
                }
            }
            else if ((c != CR) && (newline != 1))
            {
                buff.append((char) c);
            }
        }

        if (buff.length() == 0)
        {
            throw new InvalidFileFormatException("Missing version header");
        }

        if (!buff.toString().equals(getVersion()))
        {
            throw new InvalidFileFormatException("Unsupported version: " + buff.toString());
        }

        IniParser.newInstance(getConfig()).parse(input, newBuilder());
    }

    @Override public void load(File input) throws IOException, InvalidFileFormatException
    {
        load(input.toURI().toURL());
    }

    public void read(String registryKey) throws IOException
    {
        File tmp = createTempFile();

        try
        {
            regExport(registryKey, tmp);
            load(tmp);
        }
        finally
        {
            tmp.delete();
        }
    }

    @Override public void store() throws IOException
    {
        if (_file == null)
        {
            throw new FileNotFoundException();
        }

        store(_file);
    }

    @Override public void store(OutputStream output) throws IOException
    {
        store(new OutputStreamWriter(output, getConfig().getFileEncoding()));
    }

    @Override public void store(Writer output) throws IOException
    {
        output.write(getVersion());
        output.write(getConfig().getLineSeparator());
        output.write(getConfig().getLineSeparator());
        store(IniFormatter.newInstance(output, getConfig()));
    }

    @Override public void store(File output) throws IOException
    {
        OutputStream stream = new FileOutputStream(output);

        store(stream);
        stream.close();
    }

    public void write() throws IOException
    {
        File tmp = createTempFile();

        try
        {
            store(tmp);
            regImport(tmp);
        }
        finally
        {
            tmp.delete();
        }
    }

    protected IniHandler newBuilder()
    {
        return RegBuilder.newInstance(this);
    }

    @Override boolean isTreeMode()
    {
        return getConfig().isTree();
    }

    @Override char getPathSeparator()
    {
        return getConfig().getPathSeparator();
    }

    @Override boolean isPropertyFirstUpper()
    {
        return getConfig().isPropertyFirstUpper();
    }

    void exec(String[] args) throws IOException
    {
        Process proc = Runtime.getRuntime().exec(args);

        try
        {
            int status = proc.waitFor();

            if (status != 0)
            {
                Reader in = new InputStreamReader(proc.getErrorStream());
                char[] buff = new char[STDERR_BUFF_SIZE];
                int n = in.read(buff);

                in.close();
                throw new IOException(new String(buff, 0, n).trim());
            }
        }
        catch (InterruptedException x)
        {
            throw (IOException) (new InterruptedIOException().initCause(x));
        }
    }

    private File createTempFile() throws IOException
    {
        File ret = File.createTempFile(TMP_PREFIX, DEFAULT_SUFFIX);

        ret.deleteOnExit();

        return ret;
    }

    private void regExport(String registryKey, File file) throws IOException
    {
        requireWindows();
        exec(new String[] { "cmd", "/c", "reg", "export", registryKey, file.getAbsolutePath() });
    }

    private void regImport(File file) throws IOException
    {
        requireWindows();
        exec(new String[] { "cmd", "/c", "reg", "import", file.getAbsolutePath() });
    }

    private void requireWindows()
    {
        if (!WINDOWS)
        {
            throw new UnsupportedOperationException("Unsupported operating system or runtime environment");
        }
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;

//import java.nio.charset.Charset;
//
//import java.util.HashMap;
//import java.util.Map;

interface Registry extends Profile
{
    enum Hive
    {
        HKEY_CLASSES_ROOT,
        HKEY_CURRENT_CONFIG,
        HKEY_CURRENT_USER,
        HKEY_LOCAL_MACHINE,
        HKEY_USERS;
    }

    // TODO handle delete operations with special Type
    enum Type
    {
        REG_NONE("hex(0)"),
        REG_SZ(""),
        REG_EXPAND_SZ("hex(2)"),
        REG_BINARY("hex"),
        REG_DWORD("dword"),
        REG_DWORD_BIG_ENDIAN("hex(5)"),
        REG_LINK("hex(6)"),
        REG_MULTI_SZ("hex(7)"),
        REG_RESOURCE_LIST("hex(8)"),
        REG_FULL_RESOURCE_DESCRIPTOR("hex(9)"),
        REG_RESOURCE_REQUIREMENTS_LIST("hex(a)"),
        REG_QWORD("hex(b)");
        private static final Map<String, Type> MAPPING;

        static
        {
            MAPPING = new HashMap<String, Type>();
            for (Type t : values())
            {
                MAPPING.put(t.toString(), t);
            }
        }

        public static final char SEPARATOR_CHAR = ':';
        public static final String SEPARATOR = String.valueOf(SEPARATOR_CHAR);
        public static final char REMOVE_CHAR = '-';
        public static final String REMOVE = String.valueOf(REMOVE_CHAR);
        private final String _prefix;

        private Type(String prefix)
        {
            _prefix = prefix;
        }

        public static Type fromString(String str)
        {
            return MAPPING.get(str);
        }

        @Override public String toString()
        {
            return _prefix;
        }
    }

    char ESCAPE_CHAR = '\\';
    Charset FILE_ENCODING = Charset.forName("UnicodeLittle");
    char KEY_SEPARATOR = '\\';
    String LINE_SEPARATOR = "\r\n";
    char TYPE_SEPARATOR = ':';
    String VERSION = "Windows Registry Editor Version 5.00";

    String getVersion();

    void setVersion(String value);

    @Override Key get(Object key);

    @Override Key get(Object key, int index);

    @Override Key put(String key, Section value);

    @Override Key put(String key, Section value, int index);

    @Override Key remove(Object key);

    @Override Key remove(Object key, int index);

    interface Key extends Section
    {
        String DEFAULT_NAME = "@";

        @Override Key getChild(String key);

        @Override Key getParent();

        Type getType(Object key);

        Type getType(Object key, Type defaulType);

        @Override Key addChild(String key);

        @Override Key lookup(String... path);

        Type putType(String key, Type type);

        Type removeType(Object key);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j;
//
//import org.ini4j.spi.WinEscapeTool;

//import java.io.File;
//import java.io.IOException;
//import java.io.InputStream;
//import java.io.Reader;
//
//import java.net.URL;

class Wini extends Ini
{
    private static final long serialVersionUID = -2781377824232440728L;
    public static final char PATH_SEPARATOR = '\\';

    public Wini()
    {
        Config cfg = Config.getGlobal().clone();

        cfg.setEscape(false);
        cfg.setEscapeNewline(false);
        cfg.setGlobalSection(true);
        cfg.setEmptyOption(true);
        cfg.setMultiOption(false);
        cfg.setPathSeparator(PATH_SEPARATOR);
        setConfig(cfg);
    }

    public Wini(File input) throws IOException, InvalidFileFormatException
    {
        this();
        setFile(input);
        load();
    }

    public Wini(URL input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Wini(InputStream input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public Wini(Reader input) throws IOException, InvalidFileFormatException
    {
        this();
        load(input);
    }

    public String escape(String value)
    {
        return WinEscapeTool.getInstance().escape(value);
    }

    public String unescape(String value)
    {
        return WinEscapeTool.getInstance().unescape(value);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

//import java.beans.Introspector;
//import java.beans.PropertyChangeListener;
//import java.beans.PropertyChangeSupport;
//import java.beans.PropertyVetoException;
//import java.beans.VetoableChangeListener;
//import java.beans.VetoableChangeSupport;
//
//import java.lang.reflect.Array;
//import java.lang.reflect.InvocationHandler;
//import java.lang.reflect.Method;

abstract class AbstractBeanInvocationHandler implements InvocationHandler
{
    private static final String PROPERTY_CHANGE_LISTENER = "PropertyChangeListener";
    private static final String VETOABLE_CHANGE_LISTENER = "VetoableChangeListener";
    private static final String ADD_PREFIX = "add";
    private static final String READ_PREFIX = "get";
    private static final String REMOVE_PREFIX = "remove";
    private static final String READ_BOOLEAN_PREFIX = "is";
    private static final String WRITE_PREFIX = "set";
    private static final String HAS_PREFIX = "has";

    private static enum Prefix
    {
        READ(READ_PREFIX),
        READ_BOOLEAN(READ_BOOLEAN_PREFIX),
        WRITE(WRITE_PREFIX),
        ADD_CHANGE(ADD_PREFIX + PROPERTY_CHANGE_LISTENER),
        ADD_VETO(ADD_PREFIX + VETOABLE_CHANGE_LISTENER),
        REMOVE_CHANGE(REMOVE_PREFIX + PROPERTY_CHANGE_LISTENER),
        REMOVE_VETO(REMOVE_PREFIX + VETOABLE_CHANGE_LISTENER),
        HAS(HAS_PREFIX);
        private int _len;
        private String _value;

        private Prefix(String value)
        {
            _value = value;
            _len = value.length();
        }

        public static Prefix parse(String str)
        {
            Prefix ret = null;

            for (Prefix p : values())
            {
                if (str.startsWith(p.getValue()))
                {
                    ret = p;

                    break;
                }
            }

            return ret;
        }

        public String getTail(String input)
        {
            return Introspector.decapitalize(input.substring(_len));
        }

        public String getValue()
        {
            return _value;
        }
    }

    private PropertyChangeSupport _pcSupport;
    private Object _proxy;
    private VetoableChangeSupport _vcSupport;

    @Override public Object invoke(Object proxy, Method method, Object[] args) throws PropertyVetoException
    {
        Object ret = null;
        Prefix prefix = Prefix.parse(method.getName());

        if (prefix != null)
        {
            String tail = prefix.getTail(method.getName());

            updateProxy(proxy);
            switch (prefix)
            {

                case READ:
                    ret = getProperty(prefix.getTail(method.getName()), method.getReturnType());
                    break;

                case READ_BOOLEAN:
                    ret = getProperty(prefix.getTail(method.getName()), method.getReturnType());
                    break;

                case WRITE:
                    setProperty(tail, args[0], method.getParameterTypes()[0]);
                    break;

                case HAS:
                    ret = Boolean.valueOf(hasProperty(prefix.getTail(method.getName())));
                    break;

                case ADD_CHANGE:
                    addPropertyChangeListener((String) args[0], (PropertyChangeListener) args[1]);
                    break;

                case ADD_VETO:
                    addVetoableChangeListener((String) args[0], (VetoableChangeListener) args[1]);
                    break;

                case REMOVE_CHANGE:
                    removePropertyChangeListener((String) args[0], (PropertyChangeListener) args[1]);
                    break;

                case REMOVE_VETO:
                    removeVetoableChangeListener((String) args[0], (VetoableChangeListener) args[1]);
                    break;

                default:
                    break;
            }
        }

        return ret;
    }

    protected abstract Object getPropertySpi(String property, Class<?> clazz);

    protected abstract void setPropertySpi(String property, Object value, Class<?> clazz);

    protected abstract boolean hasPropertySpi(String property);

    protected synchronized Object getProperty(String property, Class<?> clazz)
    {
        Object o;

        try
        {
            o = getPropertySpi(property, clazz);
            if (o == null)
            {
                o = zero(clazz);
            }
            else if (clazz.isArray() && (o instanceof String[]) && !clazz.equals(String[].class))
            {
                String[] str = (String[]) o;

                o = Array.newInstance(clazz.getComponentType(), str.length);
                for (int i = 0; i < str.length; i++)
                {
                    Array.set(o, i, parse(str[i], clazz.getComponentType()));
                }
            }
            else if ((o instanceof String) && !clazz.equals(String.class))
            {
                o = parse((String) o, clazz);
            }
        }
        catch (Exception x)
        {
            o = zero(clazz);
        }

        return o;
    }

    protected synchronized void setProperty(String property, Object value, Class<?> clazz) throws PropertyVetoException
    {
        boolean pc = (_pcSupport != null) && _pcSupport.hasListeners(property);
        boolean vc = (_vcSupport != null) && _vcSupport.hasListeners(property);
        Object oldVal = null;
        Object newVal = ((value != null) && clazz.equals(String.class) && !(value instanceof String)) ? value.toString() : value;

        if (pc || vc)
        {
            oldVal = getProperty(property, clazz);
        }

        if (vc)
        {
            fireVetoableChange(property, oldVal, value);
        }

        setPropertySpi(property, newVal, clazz);
        if (pc)
        {
            firePropertyChange(property, oldVal, value);
        }
    }

    protected synchronized Object getProxy()
    {
        return _proxy;
    }

    protected synchronized void addPropertyChangeListener(String property, PropertyChangeListener listener)
    {
        if (_pcSupport == null)
        {
            _pcSupport = new PropertyChangeSupport(_proxy);
        }

        _pcSupport.addPropertyChangeListener(property, listener);
    }

    protected synchronized void addVetoableChangeListener(String property, VetoableChangeListener listener)
    {
        if (_vcSupport == null)
        {
            _vcSupport = new VetoableChangeSupport(_proxy);
        }

        _vcSupport.addVetoableChangeListener(property, listener);
    }

    protected synchronized void firePropertyChange(String property, Object oldValue, Object newValue)
    {
        if (_pcSupport != null)
        {
            _pcSupport.firePropertyChange(property, oldValue, newValue);
        }
    }

    protected synchronized void fireVetoableChange(String property, Object oldValue, Object newValue) throws PropertyVetoException
    {
        if (_vcSupport != null)
        {
            _vcSupport.fireVetoableChange(property, oldValue, newValue);
        }
    }

    protected synchronized boolean hasProperty(String property)
    {
        boolean ret;

        try
        {
            ret = hasPropertySpi(property);
        }
        catch (Exception x)
        {
            ret = false;
        }

        return ret;
    }

    protected Object parse(String value, Class<?> clazz) throws IllegalArgumentException
    {
        return BeanTool.getInstance().parse(value, clazz);
    }

    protected synchronized void removePropertyChangeListener(String property, PropertyChangeListener listener)
    {
        if (_pcSupport != null)
        {
            _pcSupport.removePropertyChangeListener(property, listener);
        }
    }

    protected synchronized void removeVetoableChangeListener(String property, VetoableChangeListener listener)
    {
        if (_vcSupport != null)
        {
            _vcSupport.removeVetoableChangeListener(property, listener);
        }
    }

    protected Object zero(Class<?> clazz)
    {
        return BeanTool.getInstance().zero(clazz);
    }

    private synchronized void updateProxy(Object value)
    {
        if (_proxy == null)
        {
            _proxy = value;
        }
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;

//import java.io.PrintWriter;

abstract class AbstractFormatter implements HandlerBase
{
    private static final char OPERATOR = '=';
    private static final char COMMENT = '#';
    private static final char SPACE = ' ';
    private Config _config = Config.getGlobal();
    private boolean _header = true;
    private PrintWriter _output;

    @Override public void handleComment(String comment)
    {
        if (getConfig().isComment() && (!_header || getConfig().isHeaderComment()) && (comment != null) && (comment.length() != 0))
        {
            for (String line : comment.split(getConfig().getLineSeparator()))
            {
                getOutput().print(COMMENT);
                getOutput().print(line);
                getOutput().print(getConfig().getLineSeparator());
            }

            if (_header)
            {
                getOutput().print(getConfig().getLineSeparator());
            }
        }

        _header = false;
    }

    @Override public void handleOption(String optionName, String optionValue)
    {
        if (getConfig().isStrictOperator())
        {
            if (getConfig().isEmptyOption() || (optionValue != null))
            {
                getOutput().print(escapeFilter(optionName));
                getOutput().print(OPERATOR);
            }

            if (optionValue != null)
            {
                getOutput().print(escapeFilter(optionValue));
            }

            if (getConfig().isEmptyOption() || (optionValue != null))
            {
                getOutput().print(getConfig().getLineSeparator());
            }
        }
        else
        {
            String value = ((optionValue == null) && getConfig().isEmptyOption()) ? "" : optionValue;

            if (value != null)
            {
                getOutput().print(escapeFilter(optionName));
                getOutput().print(SPACE);
                getOutput().print(OPERATOR);
                getOutput().print(SPACE);
                getOutput().print(escapeFilter(value));
                getOutput().print(getConfig().getLineSeparator());
            }
        }

        setHeader(false);
    }

    protected Config getConfig()
    {
        return _config;
    }

    protected void setConfig(Config value)
    {
        _config = value;
    }

    protected PrintWriter getOutput()
    {
        return _output;
    }

    protected void setOutput(PrintWriter value)
    {
        _output = value;
    }

    void setHeader(boolean value)
    {
        _header = value;
    }

    String escapeFilter(String input)
    {
        return getConfig().isEscape() ? EscapeTool.getInstance().escape(input) : input;
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;
//import org.ini4j.InvalidFileFormatException;

//import java.io.IOException;
//import java.io.InputStream;
//import java.io.Reader;
//
//import java.net.URL;
//
//import java.util.Locale;

abstract class AbstractParser
{
    private final String _comments;
    private Config _config = Config.getGlobal();
    private final String _operators;

    protected AbstractParser(String operators, String comments)
    {
        _operators = operators;
        _comments = comments;
    }

    protected Config getConfig()
    {
        return _config;
    }

    protected void setConfig(Config value)
    {
        _config = value;
    }

    protected void parseError(String line, int lineNumber) throws InvalidFileFormatException
    {
        throw new InvalidFileFormatException("parse error (at line: " + lineNumber + "): " + line);
    }

    IniSource newIniSource(InputStream input, HandlerBase handler)
    {
        return new IniSource(input, handler, _comments, getConfig());
    }

    IniSource newIniSource(Reader input, HandlerBase handler)
    {
        return new IniSource(input, handler, _comments, getConfig());
    }

    IniSource newIniSource(URL input, HandlerBase handler) throws IOException
    {
        return new IniSource(input, handler, _comments, getConfig());
    }

    void parseOptionLine(String line, HandlerBase handler, int lineNumber) throws InvalidFileFormatException
    {
        int idx = indexOfOperator(line);
        String name = null;
        String value = null;

        if (idx < 0)
        {
            if (getConfig().isEmptyOption())
            {
                name = line;
            }
            else
            {
                parseError(line, lineNumber);
            }
        }
        else
        {
            name = unescapeFilter(line.substring(0, idx)).trim();
            value = unescapeFilter(line.substring(idx + 1)).trim();
        }

        if (name.length() == 0)
        {
            parseError(line, lineNumber);
        }

        if (getConfig().isLowerCaseOption())
        {
            name = name.toLowerCase(Locale.getDefault());
        }

        handler.handleOption(name, value);
    }

    String unescapeFilter(String line)
    {
        return getConfig().isEscape() ? EscapeTool.getInstance().unescape(line) : line;
    }

    private int indexOfOperator(String line)
    {
        int idx = -1;

        for (char c : _operators.toCharArray())
        {
            int index = line.indexOf(c);

            if ((index >= 0) && ((idx == -1) || (index < idx)))
            {
                idx = index;
            }
        }

        return idx;
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.CommentedMap;
//import org.ini4j.Config;
//import org.ini4j.Ini;
//import org.ini4j.Profile;

abstract class AbstractProfileBuilder implements IniHandler
{
    private Profile.Section _currentSection;
    private boolean _header;
    private String _lastComment;

    @Override public void endIni()
    {

        // comment only .ini files....
        if ((_lastComment != null) && _header)
        {
            setHeaderComment();
        }
    }

    @Override public void endSection()
    {
        _currentSection = null;
    }

    @Override public void handleComment(String comment)
    {
        if ((_lastComment != null) && _header)
        {
            _header = false;
            setHeaderComment();
        }

        _lastComment = comment;
    }

    @Override public void handleOption(String name, String value)
    {
        _header = false;
        if (getConfig().isMultiOption())
        {
            _currentSection.add(name, value);
        }
        else
        {
            _currentSection.put(name, value);
        }

        if (_lastComment != null)
        {
            putComment(_currentSection, name);
            _lastComment = null;
        }
    }

    @Override public void startIni()
    {
        if (getConfig().isHeaderComment())
        {
            _header = true;
        }
    }

    @Override public void startSection(String sectionName)
    {
        if (getConfig().isMultiSection())
        {
            _currentSection = getProfile().add(sectionName);
        }
        else
        {
            Ini.Section s = getProfile().get(sectionName);

            _currentSection = (s == null) ? getProfile().add(sectionName) : s;
        }

        if (_lastComment != null)
        {
            if (_header)
            {
                setHeaderComment();
            }
            else
            {
                putComment(getProfile(), sectionName);
            }

            _lastComment = null;
        }

        _header = false;
    }

    abstract Config getConfig();

    abstract Profile getProfile();

    Profile.Section getCurrentSection()
    {
        return _currentSection;
    }

    private void setHeaderComment()
    {
        if (getConfig().isComment())
        {
            getProfile().setComment(_lastComment);
        }
    }

    private void putComment(CommentedMap<String, ?> map, String key)
    {
        if (getConfig().isComment())
        {
            map.putComment(key, _lastComment);
        }
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

interface BeanAccess
{
    void propAdd(String propertyName, String value);

    String propDel(String propertyName);

    String propGet(String propertyName);

    String propGet(String propertyName, int index);

    int propLength(String propertyName);

    String propSet(String propertyName, String value);

    String propSet(String propertyName, String value, int index);
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

//import java.beans.IntrospectionException;
//import java.beans.Introspector;
//import java.beans.PropertyDescriptor;
//
//import java.io.File;
//
//import java.lang.reflect.Array;
//import java.lang.reflect.Method;
//import java.lang.reflect.Proxy;
//
//import java.net.URI;
//import java.net.URL;
//
//import java.util.TimeZone;

class BeanTool
{
    private static final String PARSE_METHOD = "valueOf";
    private static final BeanTool INSTANCE = ServiceFinder.findService(BeanTool.class);

    public static final BeanTool getInstance()
    {
        return INSTANCE;
    }

    public void inject(Object bean, BeanAccess props)
    {
        for (PropertyDescriptor pd : getPropertyDescriptors(bean.getClass()))
        {
            try
            {
                Method method = pd.getWriteMethod();
                String name = pd.getName();

                if ((method != null) && (props.propLength(name) != 0))
                {
                    Object value;

                    if (pd.getPropertyType().isArray())
                    {
                        value = Array.newInstance(pd.getPropertyType().getComponentType(), props.propLength(name));
                        for (int i = 0; i < props.propLength(name); i++)
                        {
                            Array.set(value, i, parse(props.propGet(name, i), pd.getPropertyType().getComponentType()));
                        }
                    }
                    else
                    {
                        value = parse(props.propGet(name), pd.getPropertyType());
                    }

                    method.invoke(bean, value);
                }
            }
            catch (Exception x)
            {
                throw (IllegalArgumentException) (new IllegalArgumentException("Failed to set property: " + pd.getDisplayName()).initCause(
                        x));
            }
        }
    }

    public void inject(BeanAccess props, Object bean)
    {
        for (PropertyDescriptor pd : getPropertyDescriptors(bean.getClass()))
        {
            try
            {
                Method method = pd.getReadMethod();

                if ((method != null) && !"class".equals(pd.getName()))
                {
                    Object value = method.invoke(bean, (Object[]) null);

                    if (value != null)
                    {
                        if (pd.getPropertyType().isArray())
                        {
                            for (int i = 0; i < Array.getLength(value); i++)
                            {
                                Object v = Array.get(value, i);

                                if ((v != null) && !v.getClass().equals(String.class))
                                {
                                    v = v.toString();
                                }

                                props.propAdd(pd.getName(), (String) v);
                            }
                        }
                        else
                        {
                            props.propSet(pd.getName(), value.toString());
                        }
                    }
                }
            }
            catch (Exception x)
            {
                throw new IllegalArgumentException("Failed to set property: " + pd.getDisplayName(), x);
            }
        }
    }

    @SuppressWarnings("unchecked")
    public <T> T parse(String value, Class<T> clazz) throws IllegalArgumentException
    {
        if (clazz == null)
        {
            throw new IllegalArgumentException("null argument");
        }

        Object o = null;

        if (value == null)
        {
            o = zero(clazz);
        }
        else if (clazz.isPrimitive())
        {
            o = parsePrimitiveValue(value, clazz);
        }
        else
        {
            if (clazz == String.class)
            {
                o = value;
            }
            else if (clazz == Character.class)
            {
                o = new Character(value.charAt(0));
            }
            else
            {
                o = parseSpecialValue(value, clazz);
            }
        }

        return (T) o;
    }

    public <T> T proxy(Class<T> clazz, BeanAccess props)
    {
        return clazz.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[] { clazz },
                    new BeanInvocationHandler(props)));
    }

    @SuppressWarnings("unchecked")
    public <T> T zero(Class<T> clazz)
    {
        Object o = null;

        if (clazz.isPrimitive())
        {
            if (clazz == Boolean.TYPE)
            {
                o = Boolean.FALSE;
            }
            else if (clazz == Byte.TYPE)
            {
                o = Byte.valueOf((byte) 0);
            }
            else if (clazz == Character.TYPE)
            {
                o = new Character('\0');
            }
            else if (clazz == Double.TYPE)
            {
                o = new Double(0.0);
            }
            else if (clazz == Float.TYPE)
            {
                o = new Float(0.0f);
            }
            else if (clazz == Integer.TYPE)
            {
                o = Integer.valueOf(0);
            }
            else if (clazz == Long.TYPE)
            {
                o = Long.valueOf(0L);
            }
            else if (clazz == Short.TYPE)
            {
                o = Short.valueOf((short) 0);
            }
        }

        return (T) o;
    }

    @SuppressWarnings(Warnings.UNCHECKED)
    protected Object parseSpecialValue(String value, Class clazz) throws IllegalArgumentException
    {
        Object o;

        try
        {
            if (clazz == File.class)
            {
                o = new File(value);
            }
            else if (clazz == URL.class)
            {
                o = new URL(value);
            }
            else if (clazz == URI.class)
            {
                o = new URI(value);
            }
            else if (clazz == Class.class)
            {
                o = Class.forName(value);
            }
            else if (clazz == TimeZone.class)
            {
                o = TimeZone.getTimeZone(value);
            }
            else
            {

                // TODO handle constructor with String arg as converter from String
                // look for "valueOf" converter method
                Method parser = clazz.getMethod(PARSE_METHOD, new Class[] { String.class });

                o = parser.invoke(null, new Object[] { value });
            }
        }
        catch (Exception x)
        {
            throw (IllegalArgumentException) new IllegalArgumentException().initCause(x);
        }

        return o;
    }

    private PropertyDescriptor[] getPropertyDescriptors(Class clazz)
    {
        try
        {
            return Introspector.getBeanInfo(clazz).getPropertyDescriptors();
        }
        catch (IntrospectionException x)
        {
            throw new IllegalArgumentException(x);
        }
    }

    private Object parsePrimitiveValue(String value, Class clazz) throws IllegalArgumentException
    {
        Object o = null;

        try
        {
            if (clazz == Boolean.TYPE)
            {
                o = Boolean.valueOf(value);
            }
            else if (clazz == Byte.TYPE)
            {
                o = Byte.valueOf(value);
            }
            else if (clazz == Character.TYPE)
            {
                o = new Character(value.charAt(0));
            }
            else if (clazz == Double.TYPE)
            {
                o = Double.valueOf(value);
            }
            else if (clazz == Float.TYPE)
            {
                o = Float.valueOf(value);
            }
            else if (clazz == Integer.TYPE)
            {
                o = Integer.valueOf(value);
            }
            else if (clazz == Long.TYPE)
            {
                o = Long.valueOf(value);
            }
            else if (clazz == Short.TYPE)
            {
                o = Short.valueOf(value);
            }
        }
        catch (Exception x)
        {
            throw (IllegalArgumentException) new IllegalArgumentException().initCause(x);
        }

        return o;
    }

    static class BeanInvocationHandler extends AbstractBeanInvocationHandler
    {
        private final BeanAccess _backend;

        BeanInvocationHandler(BeanAccess backend)
        {
            _backend = backend;
        }

        @Override protected Object getPropertySpi(String property, Class<?> clazz)
        {
            Object ret = null;

            if (clazz.isArray())
            {
                int length = _backend.propLength(property);

                if (length != 0)
                {
                    String[] all = new String[length];

                    for (int i = 0; i < all.length; i++)
                    {
                        all[i] = _backend.propGet(property, i);
                    }

                    ret = all;
                }
            }
            else
            {
                ret = _backend.propGet(property);
            }

            return ret;
        }

        @Override protected void setPropertySpi(String property, Object value, Class<?> clazz)
        {
            if (clazz.isArray())
            {
                _backend.propDel(property);
                for (int i = 0; i < Array.getLength(value); i++)
                {
                    _backend.propAdd(property, Array.get(value, i).toString());
                }
            }
            else
            {
                _backend.propSet(property, value.toString());
            }
        }

        @Override protected boolean hasPropertySpi(String property)
        {
            return _backend.propLength(property) != 0;
        }
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

class EscapeTool
{
    private static final String ESCAPE_LETTERS = "\\tnfbr";
    private static final String ESCAPEABLE_CHARS = "\\\t\n\f\b\r";
    private static final char ESCAPE_CHAR = '\\';
    static final char[] HEX = "0123456789abcdef".toCharArray();
    private static final EscapeTool INSTANCE = ServiceFinder.findService(EscapeTool.class);
    private static final char ASCII_MIN = 0x20;
    private static final char ASCII_MAX = 0x7e;
    static final int HEX_DIGIT_MASK = 0x0f;
    static final int HEX_DIGIT_3_OFFSET = 4;
    static final int HEX_DIGIT_2_OFFSET = 8;
    static final int HEX_DIGIT_1_OFFSET = 12;
    static final int HEX_RADIX = 16;
    private static final int UNICODE_HEX_DIGITS = 4;
    static final char DOUBLE_QUOTE = '"';

    public static EscapeTool getInstance()
    {
        return INSTANCE;
    }

    public String escape(String line)
    {
        int len = line.length();
        StringBuilder buffer = new StringBuilder(len * 2);

        for (int i = 0; i < len; i++)
        {
            char c = line.charAt(i);
            int idx = ESCAPEABLE_CHARS.indexOf(c);

            if (idx >= 0)
            {
                buffer.append(ESCAPE_CHAR);
                buffer.append(ESCAPE_LETTERS.charAt(idx));
            }
            else
            {
                if ((c < ASCII_MIN) || (c > ASCII_MAX))
                {
                    escapeBinary(buffer, c);
                }
                else
                {
                    buffer.append(c);
                }
            }
        }

        return buffer.toString();
    }

    public String quote(String value)
    {
        String ret = value;

        if ((value != null) && (value.length() != 0))
        {
            StringBuilder buff = new StringBuilder();

            buff.append(DOUBLE_QUOTE);
            for (int i = 0; i < value.length(); i++)
            {
                char c = value.charAt(i);

                if ((c == ESCAPE_CHAR) || (c == DOUBLE_QUOTE))
                {
                    buff.append(ESCAPE_CHAR);
                }

                buff.append(c);
            }

            buff.append(DOUBLE_QUOTE);
            ret = buff.toString();
        }

        return ret;
    }

    String unescape(String line)
    {
        int n = line.length();
        StringBuilder buffer = new StringBuilder(n);
        int i = 0;

        while (i < n)
        {
            char c = line.charAt(i++);

            if (c == ESCAPE_CHAR)
            {
                c = line.charAt(i++);
                int next = unescapeBinary(buffer, c, line, i);

                if (next == i)
                {
                    int idx = ESCAPE_LETTERS.indexOf(c);

                    if (idx >= 0)
                    {
                        c = ESCAPEABLE_CHARS.charAt(idx);
                    }

                    buffer.append(c);
                }
                else
                {
                    i = next;
                }
            }
            else
            {
                buffer.append(c);
            }
        }

        return buffer.toString();
    }

    public String unquote(String value)
    {
        StringBuilder buff = new StringBuilder();
        boolean escape = false;

        for (int i = 1; i < (value.length() - 1); i++)
        {
            char c = value.charAt(i);

            if (c == ESCAPE_CHAR)
            {
                if (!escape)
                {
                    escape = true;

                    continue;
                }

                escape = false;
            }

            buff.append(c);
        }

        return buff.toString();
    }

    void escapeBinary(StringBuilder buff, char c)
    {
        buff.append("\\u");
        buff.append(HEX[(c >>> HEX_DIGIT_1_OFFSET) & HEX_DIGIT_MASK]);
        buff.append(HEX[(c >>> HEX_DIGIT_2_OFFSET) & HEX_DIGIT_MASK]);
        buff.append(HEX[(c >>> HEX_DIGIT_3_OFFSET) & HEX_DIGIT_MASK]);
        buff.append(HEX[c & HEX_DIGIT_MASK]);
    }

    int unescapeBinary(StringBuilder buff, char escapeType, String line, int index)
    {
        int ret = index;

        if (escapeType == 'u')
        {
            try
            {
                buff.append((char) Integer.parseInt(line.substring(index, index + UNICODE_HEX_DIGITS), HEX_RADIX));
                ret = index + UNICODE_HEX_DIGITS;
            }
            catch (Exception x)
            {
                throw new IllegalArgumentException("Malformed \\uxxxx encoding.", x);
            }
        }

        return ret;
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

interface HandlerBase
{
    void handleComment(String comment);

    void handleOption(String optionName, String optionValue);
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;
//import org.ini4j.Ini;
//import org.ini4j.Profile;

class IniBuilder extends AbstractProfileBuilder implements IniHandler
{
    private Ini _ini;

    public static IniBuilder newInstance(Ini ini)
    {
        IniBuilder instance = newInstance();

        instance.setIni(ini);

        return instance;
    }

    public void setIni(Ini value)
    {
        _ini = value;
    }

    @Override Config getConfig()
    {
        return _ini.getConfig();
    }

    @Override Profile getProfile()
    {
        return _ini;
    }

    private static IniBuilder newInstance()
    {
        return ServiceFinder.findService(IniBuilder.class);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;

//import java.io.PrintWriter;
//import java.io.Writer;

class IniFormatter extends AbstractFormatter implements IniHandler
{
    public static IniFormatter newInstance(Writer out, Config config)
    {
        IniFormatter instance = newInstance();

        instance.setOutput((out instanceof PrintWriter) ? (PrintWriter) out : new PrintWriter(out));
        instance.setConfig(config);

        return instance;
    }

    @Override public void endIni()
    {
        getOutput().flush();
    }

    @Override public void endSection()
    {
        getOutput().print(getConfig().getLineSeparator());
    }

    @Override public void startIni()
    {
        assert true;
    }

    @Override public void startSection(String sectionName)
    {
        setHeader(false);
        if (!getConfig().isGlobalSection() || !sectionName.equals(getConfig().getGlobalSectionName()))
        {
            getOutput().print(IniParser.SECTION_BEGIN);
            getOutput().print(escapeFilter(sectionName));
            getOutput().print(IniParser.SECTION_END);
            getOutput().print(getConfig().getLineSeparator());
        }
    }

    private static IniFormatter newInstance()
    {
        return ServiceFinder.findService(IniFormatter.class);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

interface IniHandler extends HandlerBase
{
    void endIni();

    void endSection();

    @Override void handleComment(String comment);

    @Override void handleOption(String optionName, String optionValue);

    void startIni();

    void startSection(String sectionName);
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;
//import org.ini4j.InvalidFileFormatException;

//import java.io.IOException;
//import java.io.InputStream;
//import java.io.Reader;
//
//import java.net.URL;
//
//import java.util.Locale;

class IniParser extends AbstractParser
{
    private static final String COMMENTS = ";#";
    private static final String OPERATORS = ":=";
    static final char SECTION_BEGIN = '[';
    static final char SECTION_END = ']';

    public IniParser()
    {
        super(OPERATORS, COMMENTS);
    }

    public static IniParser newInstance()
    {
        return ServiceFinder.findService(IniParser.class);
    }

    public static IniParser newInstance(Config config)
    {
        IniParser instance = newInstance();

        instance.setConfig(config);

        return instance;
    }

    public void parse(InputStream input, IniHandler handler) throws IOException, InvalidFileFormatException
    {
        parse(newIniSource(input, handler), handler);
    }

    public void parse(Reader input, IniHandler handler) throws IOException, InvalidFileFormatException
    {
        parse(newIniSource(input, handler), handler);
    }

    public void parse(URL input, IniHandler handler) throws IOException, InvalidFileFormatException
    {
        parse(newIniSource(input, handler), handler);
    }

    private void parse(IniSource source, IniHandler handler) throws IOException, InvalidFileFormatException
    {
        handler.startIni();
        String sectionName = null;

        for (String line = source.readLine(); line != null; line = source.readLine())
        {
            if (line.charAt(0) == SECTION_BEGIN)
            {
                if (sectionName != null)
                {
                    handler.endSection();
                }

                sectionName = parseSectionLine(line, source, handler);
            }
            else
            {
                if (sectionName == null)
                {
                    if (getConfig().isGlobalSection())
                    {
                        sectionName = getConfig().getGlobalSectionName();
                        handler.startSection(sectionName);
                    }
                    else
                    {
                        parseError(line, source.getLineNumber());
                    }
                }

                parseOptionLine(line, handler, source.getLineNumber());
            }
        }

        if (sectionName != null)
        {
            handler.endSection();
        }

        handler.endIni();
    }

    private String parseSectionLine(String line, IniSource source, IniHandler handler) throws InvalidFileFormatException
    {
        String sectionName;

        if (line.charAt(line.length() - 1) != SECTION_END)
        {
            parseError(line, source.getLineNumber());
        }

        sectionName = unescapeFilter(line.substring(1, line.length() - 1).trim());
        if ((sectionName.length() == 0) && !getConfig().isUnnamedSection())
        {
            parseError(line, source.getLineNumber());
        }

        if (getConfig().isLowerCaseSection())
        {
            sectionName = sectionName.toLowerCase(Locale.getDefault());
        }

        handler.startSection(sectionName);

        return sectionName;
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;

//import java.io.IOException;
//import java.io.InputStream;
//import java.io.LineNumberReader;
//import java.io.Reader;
//
//import java.net.URL;

class IniSource
{
    public static final char INCLUDE_BEGIN = '<';
    public static final char INCLUDE_END = '>';
    public static final char INCLUDE_OPTIONAL = '?';
    private static final char ESCAPE_CHAR = '\\';
    private URL _base;
    private IniSource _chain;
    private final String _commentChars;
    private final Config _config;
    private final HandlerBase _handler;
    private final LineNumberReader _reader;

    IniSource(InputStream input, HandlerBase handler, String comments, Config config)
    {
        this(new UnicodeInputStreamReader(input, config.getFileEncoding()), handler, comments, config);
    }

    IniSource(Reader input, HandlerBase handler, String comments, Config config)
    {
        _reader = new LineNumberReader(input);
        _handler = handler;
        _commentChars = comments;
        _config = config;
    }

    IniSource(URL input, HandlerBase handler, String comments, Config config) throws IOException
    {
        this(new UnicodeInputStreamReader(input.openStream(), config.getFileEncoding()), handler, comments, config);
        _base = input;
    }

    int getLineNumber()
    {
        int ret;

        if (_chain == null)
        {
            ret = _reader.getLineNumber();
        }
        else
        {
            ret = _chain.getLineNumber();
        }

        return ret;
    }

    String readLine() throws IOException
    {
        String line;

        if (_chain == null)
        {
            line = readLineLocal();
        }
        else
        {
            line = _chain.readLine();
            if (line == null)
            {
                _chain = null;
                line = readLine();
            }
        }

        return line;
    }

    private void close() throws IOException
    {
        _reader.close();
    }

    private int countEndingEscapes(String line)
    {
        int escapeCount = 0;

        for (int i = line.length() - 1; (i >= 0) && (line.charAt(i) == ESCAPE_CHAR); i--)
        {
            escapeCount++;
        }

        return escapeCount;
    }

    private void handleComment(StringBuilder buff)
    {
        if (buff.length() != 0)
        {
            buff.deleteCharAt(buff.length() - 1);
            _handler.handleComment(buff.toString());
            buff.delete(0, buff.length());
        }
    }

    private String handleInclude(String input) throws IOException
    {
        String line = input;

        if (_config.isInclude() && (line.length() > 2) && (line.charAt(0) == INCLUDE_BEGIN) && (line.charAt(line.length() - 1) == INCLUDE_END))
        {
            line = line.substring(1, line.length() - 1).trim();
            boolean optional = line.charAt(0) == INCLUDE_OPTIONAL;

            if (optional)
            {
                line = line.substring(1).trim();
            }

            URL loc = (_base == null) ? new URL(line) : new URL(_base, line);

            if (optional)
            {
                try
                {
                    _chain = new IniSource(loc, _handler, _commentChars, _config);
                }
                catch (IOException x)
                {
                    assert true;
                }
                finally
                {
                    line = readLine();
                }
            }
            else
            {
                _chain = new IniSource(loc, _handler, _commentChars, _config);
                line = readLine();
            }
        }

        return line;
    }

    private String readLineLocal() throws IOException
    {
        String line = readLineSkipComments();

        if (line == null)
        {
            close();
        }
        else
        {
            line = handleInclude(line);
        }

        return line;
    }

    private String readLineSkipComments() throws IOException
    {
        String line;
        StringBuilder comment = new StringBuilder();
        StringBuilder buff = new StringBuilder();

        for (line = _reader.readLine(); line != null; line = _reader.readLine())
        {
            line = line.trim();
            if (line.length() == 0)
            {
                handleComment(comment);
            }
            else if ((_commentChars.indexOf(line.charAt(0)) >= 0) && (buff.length() == 0))
            {
                comment.append(line.substring(1));
                comment.append(_config.getLineSeparator());
            }
            else
            {
                handleComment(comment);
                if (!_config.isEscapeNewline() || ((countEndingEscapes(line) & 1) == 0))
                {
                    buff.append(line);
                    line = buff.toString();

                    break;
                }

                buff.append(line.subSequence(0, line.length() - 1));
            }
        }

        // handle end comments
        if ((line == null) && (comment.length() != 0))
        {
            handleComment(comment);
        }

        return line;
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;
//import org.ini4j.Options;

class OptionsBuilder implements OptionsHandler
{
    private boolean _header;
    private String _lastComment;
    private Options _options;

    public static OptionsBuilder newInstance(Options opts)
    {
        OptionsBuilder instance = newInstance();

        instance.setOptions(opts);

        return instance;
    }

    public void setOptions(Options value)
    {
        _options = value;
    }

    @Override public void endOptions()
    {

        // comment only .opt file ...
        if ((_lastComment != null) && _header)
        {
            setHeaderComment();
        }
    }

    @Override public void handleComment(String comment)
    {
        if ((_lastComment != null) && _header)
        {
            setHeaderComment();
            _header = false;
        }

        _lastComment = comment;
    }

    @Override public void handleOption(String name, String value)
    {
        if (getConfig().isMultiOption())
        {
            _options.add(name, value);
        }
        else
        {
            _options.put(name, value);
        }

        if (_lastComment != null)
        {
            if (_header)
            {
                setHeaderComment();
            }
            else
            {
                putComment(name);
            }

            _lastComment = null;
        }

        _header = false;
    }

    @Override public void startOptions()
    {
        if (getConfig().isHeaderComment())
        {
            _header = true;
        }
    }

    protected static OptionsBuilder newInstance()
    {
        return ServiceFinder.findService(OptionsBuilder.class);
    }

    private Config getConfig()
    {
        return _options.getConfig();
    }

    private void setHeaderComment()
    {
        if (getConfig().isComment())
        {
            _options.setComment(_lastComment);
        }
    }

    private void putComment(String key)
    {
        if (getConfig().isComment())
        {
            _options.putComment(key, _lastComment);
        }
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;

//import java.io.PrintWriter;
//import java.io.Writer;

class OptionsFormatter extends AbstractFormatter implements OptionsHandler
{
    public static OptionsFormatter newInstance(Writer out, Config config)
    {
        OptionsFormatter instance = newInstance();

        instance.setOutput((out instanceof PrintWriter) ? (PrintWriter) out : new PrintWriter(out));
        instance.setConfig(config);

        return instance;
    }

    public void endOptions()
    {
        getOutput().flush();
    }

    public void startOptions()
    {
        assert true;
    }

    private static OptionsFormatter newInstance()
    {
        return ServiceFinder.findService(OptionsFormatter.class);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

interface OptionsHandler extends HandlerBase
{
    void endOptions();

    @Override void handleComment(String comment);

    @Override void handleOption(String optionName, String optionValue);

    void startOptions();
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;
//import org.ini4j.InvalidFileFormatException;

//import java.io.IOException;
//import java.io.InputStream;
//import java.io.Reader;
//
//import java.net.URL;

class OptionsParser extends AbstractParser
{
    private static final String COMMENTS = "!#";
    private static final String OPERATORS = ":=";

    public OptionsParser()
    {
        super(OPERATORS, COMMENTS);
    }

    public static OptionsParser newInstance()
    {
        return ServiceFinder.findService(OptionsParser.class);
    }

    public static OptionsParser newInstance(Config config)
    {
        OptionsParser instance = newInstance();

        instance.setConfig(config);

        return instance;
    }

    public void parse(InputStream input, OptionsHandler handler) throws IOException, InvalidFileFormatException
    {
        parse(newIniSource(input, handler), handler);
    }

    public void parse(Reader input, OptionsHandler handler) throws IOException, InvalidFileFormatException
    {
        parse(newIniSource(input, handler), handler);
    }

    public void parse(URL input, OptionsHandler handler) throws IOException, InvalidFileFormatException
    {
        parse(newIniSource(input, handler), handler);
    }

    private void parse(IniSource source, OptionsHandler handler) throws IOException, InvalidFileFormatException
    {
        handler.startOptions();
        for (String line = source.readLine(); line != null; line = source.readLine())
        {
            parseOptionLine(line, handler, source.getLineNumber());
        }

        handler.endOptions();
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Config;
//import org.ini4j.Profile;
//import org.ini4j.Reg;
//
//import org.ini4j.Registry.Key;
//import org.ini4j.Registry.Type;

class RegBuilder extends AbstractProfileBuilder
{
    private Reg _reg;

    public static RegBuilder newInstance(Reg reg)
    {
        RegBuilder instance = newInstance();

        instance.setReg(reg);

        return instance;
    }

    public void setReg(Reg value)
    {
        _reg = value;
    }

    @Override public void handleOption(String rawName, String rawValue)
    {
        String name = (rawName.charAt(0) == EscapeTool.DOUBLE_QUOTE) ? RegEscapeTool.getInstance().unquote(rawName) : rawName;
//        TypeValuesPair tv = RegEscapeTool.getInstance().decode(rawValue);
//
//        if (tv.getType() != Type.REG_SZ)
//        {
//            ((Key) getCurrentSection()).putType(name, tv.getType());
//        }
//
//        for (String value : tv.getValues())
//        {
//            super.handleOption(name, value);
//        }
    }

    @Override Config getConfig()
    {
        return _reg.getConfig();
    }

    @Override Profile getProfile()
    {
        return _reg;
    }

    private static RegBuilder newInstance()
    {
        return ServiceFinder.findService(RegBuilder.class);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Registry;
//
//import org.ini4j.Registry.Type;

//import java.io.UnsupportedEncodingException;
//
//import java.nio.charset.Charset;
//
//import java.util.Arrays;

class RegEscapeTool extends EscapeTool
{
    private static final RegEscapeTool INSTANCE = ServiceFinder.findService(RegEscapeTool.class);
    private static final Charset HEX_CHARSET = Charset.forName("UTF-16LE");
    private static final int LOWER_DIGIT = 0x0f;
    private static final int UPPER_DIGIT = 0xf0;
    private static final int DIGIT_SIZE = 4;

    public static final RegEscapeTool getInstance()
    {
        return INSTANCE;
    }

//    public TypeValuesPair decode(String raw)
//    {
//        Type type = type(raw);
//        String value = (type == Type.REG_SZ) ? unquote(raw) : raw.substring(type.toString().length() + 1);
//        String[] values;
//
//        switch (type)
//        {
//
//            case REG_EXPAND_SZ:
//            case REG_MULTI_SZ:
//                value = bytes2string(binary(value));
//                break;
//
//            case REG_DWORD:
//                value = String.valueOf(Long.parseLong(value, HEX_RADIX));
//                break;
//
//            case REG_SZ:
//                break;
//
//            default:
//                break;
//        }
//
//        if (type == Type.REG_MULTI_SZ)
//        {
//            values = splitMulti(value);
//        }
//        else
//        {
//            values = new String[] { value };
//        }
//
//        return new TypeValuesPair(type, values);
//    }
//
//    public String encode(TypeValuesPair data)
//    {
//        String ret = null;
//
//        if (data.getType() == Type.REG_SZ)
//        {
//            ret = quote(data.getValues()[0]);
//        }
//        else if (data.getValues()[0] != null)
//        {
//            ret = encode(data.getType(), data.getValues());
//        }
//
//        return ret;
//    }

    byte[] binary(String value)
    {
        byte[] bytes = new byte[value.length()];
        int idx = 0;
        int shift = DIGIT_SIZE;

        for (int i = 0; i < value.length(); i++)
        {
            char c = value.charAt(i);

            if (Character.isWhitespace(c))
            {
                continue;
            }

            if (c == ',')
            {
                idx++;
                shift = DIGIT_SIZE;
            }
            else
            {
                int digit = Character.digit(c, HEX_RADIX);

                if (digit >= 0)
                {
                    bytes[idx] |= digit << shift;
                    shift = 0;
                }
            }
        }

        return Arrays.copyOfRange(bytes, 0, idx + 1);
    }

//    String encode(Type type, String[] values)
//    {
//        StringBuilder buff = new StringBuilder();
//
//        buff.append(type.toString());
//        buff.append(Type.SEPARATOR_CHAR);
//        switch (type)
//        {
//
//            case REG_EXPAND_SZ:
//                buff.append(hexadecimal(values[0]));
//                break;
//
//            case REG_DWORD:
//                buff.append(String.format("%08x", Long.parseLong(values[0])));
//                break;
//
//            case REG_MULTI_SZ:
//                int n = values.length;
//
//                for (int i = 0; i < n; i++)
//                {
//                    buff.append(hexadecimal(values[i]));
//                    buff.append(',');
//                }
//
//                buff.append("00,00");
//                break;
//
//            default:
//                buff.append(values[0]);
//                break;
//        }
//
//        return buff.toString();
//    }

    String hexadecimal(String value)
    {
        StringBuilder buff = new StringBuilder();

        if ((value != null) && (value.length() != 0))
        {
            byte[] bytes = string2bytes(value);

            for (int i = 0; i < bytes.length; i++)
            {
                buff.append(Character.forDigit((bytes[i] & UPPER_DIGIT) >> DIGIT_SIZE, HEX_RADIX));
                buff.append(Character.forDigit(bytes[i] & LOWER_DIGIT, HEX_RADIX));
                buff.append(',');
            }

            buff.append("00,00");
        }

        return buff.toString();
    }

    Registry.Type type(String raw)
    {
        Registry.Type type;

        if (raw.charAt(0) == DOUBLE_QUOTE)
        {
            type = Registry.Type.REG_SZ;
        }
        else
        {
            int idx = raw.indexOf(Registry.TYPE_SEPARATOR);

            type = (idx < 0) ? Registry.Type.REG_SZ : Registry.Type.fromString(raw.substring(0, idx));
        }

        return type;
    }

    // XXX Java 1.4 compatibility hack
    private String bytes2string(byte[] bytes)
    {
        String str;

        try
        {
            str = new String(bytes, 0, bytes.length - 2, HEX_CHARSET);
        }
        catch (NoSuchMethodError x)
        {
            try
            {
                str = new String(bytes, 0, bytes.length, HEX_CHARSET.name());
            }
            catch (UnsupportedEncodingException ex)
            {
                throw new IllegalStateException(ex);
            }
        }

        return str;
    }

    private String[] splitMulti(String value)
    {
        int len = value.length();
        int start;
        int end;
        int n = 0;

        start = 0;
        for (end = value.indexOf(0, start); end >= 0; end = value.indexOf(0, start))
        {
            n++;
            start = end + 1;
            if (start >= len)
            {
                break;
            }
        }

        String[] values = new String[n];

        start = 0;
        for (int i = 0; i < n; i++)
        {
            end = value.indexOf(0, start);
            values[i] = value.substring(start, end);
            start = end + 1;
        }

        return values;
    }

    // XXX Java 1.4 compatibility hack
    private byte[] string2bytes(String value)
    {
        byte[] bytes;

        try
        {
            bytes = value.getBytes(HEX_CHARSET);
        }
        catch (NoSuchMethodError x)
        {
            try
            {
                bytes = value.getBytes(HEX_CHARSET.name());
            }
            catch (UnsupportedEncodingException ex)
            {
                throw new IllegalStateException(ex);
            }
        }

        return bytes;
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

//import java.io.BufferedReader;
//import java.io.InputStream;
//import java.io.InputStreamReader;

/**
 * JDK JAR Services API alapï¿½ service keresï¿½ osztï¿½ly.
 *
 * @author Szkiba Ivï¿½n
 * @version $Name:  $
 */
final class ServiceFinder
{
    private static final String SERVICES_PATH = "META-INF/services/";

    private ServiceFinder()
    {
    }

    /**
     * Service objektum keresï¿½s ï¿½s pï¿½ldï¿½nyosï¿½tï¿½s
     *
     * a JDK JAR specifikï¿½ciï¿½ban definiï¿½lt <B>Services API</B>-nak
     * megfelelï¿½en service osztï¿½ly keresï¿½s, majd pedig pï¿½ldï¿½ny kï¿½pzï¿½s a context
     * ClassLoader segï¿½tsï¿½gï¿½vel.</p><p>
     * Az implementï¿½lï¿½ osztï¿½ly nï¿½v keresï¿½se a <CODE>serviceId</CODE> nevï¿½
     * system property vizsgï¿½latï¿½val kezdï¿½dik. Amennyiben nincs ilyen
     * property, ï¿½gy a keresï¿½s a
     * <CODE>/META-INF/services/<I>serviceId</I></CODE> nevï¿½ file tartalmï¿½val
     * folytatï¿½dik. Amennyiben nincs ilyen nevï¿½ file, ï¿½gy a paramï¿½terkï¿½nt ï¿½tadott
     * <CODE>defaultService</CODE> lesz az osztï¿½ly neve.</p><p>
     * A fenti keresï¿½st kï¿½vetï¿½en tï¿½rtï¿½nik a pï¿½ldï¿½ny kï¿½pzï¿½s. A visszatï¿½rï¿½si
     * ï¿½rtï¿½k mindig egy valï¿½di objektum, lï¿½vï¿½n minden hiba exception-t generï¿½l.
     * @param <T> type
     * @param clazz keresett osztï¿½ly/service neve
     * @throws IllegalArgumentException keresï¿½si vagy pï¿½ldï¿½nyosï¿½tï¿½si hiba esetï¿½n
     * @return a keresett osztï¿½ly implementï¿½lï¿½ objektum
     */
    static <T> T findService(Class<T> clazz)
    {
        try
        {

            // ez a cast nem lenne szÃ¼ksÃ©ges, de Ãºgy a ClassCastException csak a hÃ­vÃ³nÃ¡l jÃ¶n...
            return clazz.cast(findServiceClass(clazz).newInstance());
        }
        catch (Exception x)
        {
            throw (IllegalArgumentException) new IllegalArgumentException("Provider " + clazz.getName() + " could not be instantiated: " + x)
              .initCause(x);
        }
    }

    @SuppressWarnings(Warnings.UNCHECKED)
    static <T> Class<? extends T> findServiceClass(Class<T> clazz) throws IllegalArgumentException
    {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String serviceClassName = findServiceClassName(clazz.getName());
        Class<T> ret = clazz;

        if (serviceClassName != null)
        {
            try
            {
                ret = (Class<T>) ((classLoader == null) ? Class.forName(serviceClassName) : classLoader.loadClass(serviceClassName));
            }
            catch (ClassNotFoundException x)
            {
                throw (IllegalArgumentException) new IllegalArgumentException("Provider " + serviceClassName + " not found").initCause(x);
            }
        }

        return ret;
    }

    static String findServiceClassName(String serviceId) throws IllegalArgumentException
    {
        String serviceClassName = null;

        // Use the system property first
        try
        {
            String systemProp = System.getProperty(serviceId);

            if (systemProp != null)
            {
                serviceClassName = systemProp;
            }
        }
        catch (SecurityException x)
        {
            assert true;
        }

        if (serviceClassName == null)
        {
            serviceClassName = loadLine(SERVICES_PATH + serviceId);
        }

        return serviceClassName;
    }

    private static String loadLine(String servicePath)
    {
        String ret = null;

        // try to find services in CLASSPATH
        try
        {
            InputStream is = null;
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

            if (classLoader == null)
            {
                is = ClassLoader.getSystemResourceAsStream(servicePath);
            }
            else
            {
                is = classLoader.getResourceAsStream(servicePath);
            }

            if (is != null)
            {
                BufferedReader rd = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                String line = rd.readLine();

                rd.close();
                if (line != null)
                {
                    line = line.trim();
                    if (line.length() != 0)
                    {
                        ret = line.split("\\s|#")[0];
                    }
                }
            }
        }
        catch (Exception x)
        {
            assert true;
        }

        return ret;
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;
//
//import org.ini4j.Registry.Type;

//class TypeValuesPair
//{
//    private final Type _type;
//    private final String[] _values;
//
//    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
//    public TypeValuesPair(Type type, String[] values)
//    {
//        _type = type;
//        _values = values;
//    }
//
//    public Type getType()
//    {
//        return _type;
//    }
//
//    public String[] getValues()
//    {
//        return _values;
//    }
//}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

//import java.io.IOException;
//import java.io.InputStream;
//import java.io.InputStreamReader;
//import java.io.PushbackInputStream;
//import java.io.Reader;
//
//import java.nio.charset.Charset;

class UnicodeInputStreamReader extends Reader
{
    private static final int BOM_SIZE = 4;

    private static enum Bom
    {
        UTF32BE("UTF-32BE", new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0xFE, (byte) 0xFF }),
        UTF32LE("UTF-32LE", new byte[] { (byte) 0xFF, (byte) 0xFE, (byte) 0x00, (byte) 0x00 }),
        UTF16BE("UTF-16BE", new byte[] { (byte) 0xFE, (byte) 0xFF }),
        UTF16LE("UTF-16LE", new byte[] { (byte) 0xFF, (byte) 0xFE }),
        UTF8("UTF-8", new byte[] { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF });
        private final byte[] _bytes;
        private Charset _charset;

        @SuppressWarnings("PMD.ArrayIsStoredDirectly")
        private Bom(String charsetName, byte[] bytes)
        {
            try
            {
                _charset = Charset.forName(charsetName);
            }
            catch (Exception x)
            {
                _charset = null;
            }

            _bytes = bytes;
        }

        private static Bom find(byte[] data)
        {
            Bom ret = null;

            for (Bom bom : values())
            {
                if (bom.supported() && bom.match(data))
                {
                    ret = bom;

                    break;
                }
            }

            return ret;
        }

        private boolean match(byte[] data)
        {
            boolean ok = true;

            for (int i = 0; i < _bytes.length; i++)
            {
                if (data[i] != _bytes[i])
                {
                    ok = false;

                    break;
                }
            }

            return ok;
        }

        private boolean supported()
        {
            return _charset != null;
        }
    }

    private final Charset _defaultEncoding;
    private InputStreamReader _reader;
    private final PushbackInputStream _stream;

    UnicodeInputStreamReader(InputStream in, Charset defaultEnc)
    {
        _stream = new PushbackInputStream(in, BOM_SIZE);
        _defaultEncoding = defaultEnc;
    }

    public void close() throws IOException
    {
        init();
        _reader.close();
    }

    public int read(char[] cbuf, int off, int len) throws IOException
    {
        init();

        return _reader.read(cbuf, off, len);
    }

    /**
     * Read-ahead four bytes and check for BOM marks. Extra bytes are
     * unread back to the stream, only BOM bytes are skipped.
     */
    protected void init() throws IOException
    {
        if (_reader != null)
        {
            return;
        }

        Charset encoding;
        byte[] data = new byte[BOM_SIZE];
        int n;
        int unread;

        n = _stream.read(data, 0, data.length);
        Bom bom = Bom.find(data);

        if (bom == null)
        {
            encoding = _defaultEncoding;
            unread = n;
        }
        else
        {
            encoding = bom._charset;
            unread = data.length - bom._bytes.length;
        }

        if (unread > 0)
        {
            _stream.unread(data, (n - unread), unread);
        }

        _reader = new InputStreamReader(_stream, encoding);
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

final class Warnings
{
    public static final String UNCHECKED = "unchecked";

    private Warnings()
    {
        assert true;
    }
}

/*
 * Copyright 2005,2009 Ivan SZKIBA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//package org.ini4j.spi;

class WinEscapeTool extends EscapeTool
{
    private static final int ANSI_HEX_DIGITS = 2;
    private static final int ANSI_OCTAL_DIGITS = 3;
    private static final int OCTAL_RADIX = 8;
    private static final WinEscapeTool INSTANCE = new WinEscapeTool();

    public static WinEscapeTool getInstance()
    {
        return INSTANCE;
    }

    @Override void escapeBinary(StringBuilder buff, char c)
    {
        buff.append("\\x");
        buff.append(HEX[(c >>> HEX_DIGIT_3_OFFSET) & HEX_DIGIT_MASK]);
        buff.append(HEX[c & HEX_DIGIT_MASK]);
    }

    @Override int unescapeBinary(StringBuilder buff, char escapeType, String line, int index)
    {
        int ret = index;

        if (escapeType == 'x')
        {
            try
            {
                buff.append((char) Integer.parseInt(line.substring(index, index + ANSI_HEX_DIGITS), HEX_RADIX));
                ret = index + ANSI_HEX_DIGITS;
            }
            catch (Exception x)
            {
                throw new IllegalArgumentException("Malformed \\xHH encoding.", x);
            }
        }
        else if (escapeType == 'o')
        {
            try
            {
                buff.append((char) Integer.parseInt(line.substring(index, index + ANSI_OCTAL_DIGITS), OCTAL_RADIX));
                ret = index + ANSI_OCTAL_DIGITS;
            }
            catch (Exception x)
            {
                throw new IllegalArgumentException("Malformed \\oOO encoding.", x);
            }
        }

        return ret;
    }
    
    //********************************************
    // End of the ini4j.jar code
    //********************************************
}
